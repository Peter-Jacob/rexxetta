-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:29
-------------------------------------------------------------------------
0001 /*REXX program  finds  (and maybe displays)  Smith  (or joke)  numbers up to a given  N.*/
0002 parse arg N .                                    /*obtain optional argument from the CL.*/
0003 if N=='' | N==","  then N=10000                  /*Not specified?  Then use the default.*/
0004 tell= (N>0);            N=abs(N) - 1             /*use the  │N│  for computing  (below).*/
0005 #=0                                              /*the number of Smith numbers (so far).*/
0006 w=length(N)                                      /*W:  used for aligning Smith numbers. */
0007 @=;    do j=4  for  max(0, N-3)                  /*process almost all numbers up to  N. */
0008 if sumD(j) \== sumFactr(j)  then iterate  /*Not a Smith number?   Then ignore it.*/
0009 #=#+1                                     /*bump the Smith number counter.       */
0010 if \tell  then iterate                    /*Not showing the numbers? Keep looking*/
0011 @=@ right(j, w);        if length(@)>199 then do;   say substr(@, 2);    @=;    end
0012 end   /*j*/                               /* [↑]  if N>0,  then display Smith #s.*/
0013 
0014 if @\==''  then say substr(@, 2)                 /*if any residual Smith #s, display 'em*/
0015 say                                              /* [↓]  display the number of Smith #s.*/
0016 say #   ' Smith numbers found  ≤ '  max(0,N)"."  /*display number of Smith numbers found*/
0017 exit                                             /*stick a fork in it,  we're all done. */
0018 /*──────────────────────────────────────────────────────────────────────────────────────*/
0019 sumD:     parse arg x 1 s 2;   do d=2  for length(x)-1; s=s+substr(x,d,1); end;   return s
0020 /*──────────────────────────────────────────────────────────────────────────────────────*/
0021 sumFactr: procedure;  parse arg z;      $=0;   f=0           /*obtain  Z  number (arg1).*/
0022 do  while z// 2==0; $=$+ 2; f=f+1; z=z% 2;  end /*maybe add factor of   2. */
0023 do  while z// 3==0; $=$+ 3; f=f+1; z=z% 3;  end /*  "    "     "    "   3. */
0024 do  while z// 5==0; $=$+ 5; f=f+1; z=z% 5;  end /*  "    "     "    "   5. */
0025 do  while z// 7==0; $=$+ 7; f=f+1; z=z% 7;  end /*  "    "     "    "   7. */
0026 t=z;  r=0;  q=1;       do while q<=t; q=q*4;   end /*R:  will be the iSqrt(Z).*/
0027 do while q>1;  q=q%4;  _=t-r-q;  r=r%2;  if _>=0  then do;  t=_;  r=r+q;  end
0028 end   /*while q>1*/                             /* [↑] compute int. SQRT(Z)*/
0029 
0030 do j=11  by 6  to r  while j<=z                 /*skip factors that are ÷ 3*/
0031 parse var  j  ''  -1  _;     if _\==5 then,     /*is last dec. digit ¬a 5 ?*/
0032 do  while z//j==0; f=f+1; $=$+sumD(j); z=z%j; end   /*maybe reduce Z by J*/
0033 if _==3  then iterate;      y=j+2
0034 do  while z//y==0; f=f+1; $=$+sumD(y); z=z%y; end   /*maybe reduce Z by Y*/
0035 end   /*j*/                                     /* [↓]  Z  is what's left. */
0036 if z\==1  then do;      f=f+1; $=$+sumD(z);  end   /*if a residual, then add Z*/
0037 if f<2    then return 0                            /*Is prime? It's not Smith#*/
0038 return $                            /*else, return sum of digs.*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j                31
002 while            32 34
003 f                32 34 36
004 z                32 34
005 y                33
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #                -> newV1            5 9
002 @                -> newV2            7 11 11
003 $                -> newV3            21 22 23 24 25 32 34 36
004 _                -> newV4            27 31
