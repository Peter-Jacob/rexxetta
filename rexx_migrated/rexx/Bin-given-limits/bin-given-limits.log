-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:06
-------------------------------------------------------------------------
0001 /*REXX program counts how many   numbers of a set   that fall in the range of each bin. */
0002 lims= 23 37 43 53 67 83                          /* ◄■■■■■■1st set of bin limits & data.*/
0003 data= 95 21 94 12 99 4 70 75 83 93 52 80 57 5 53 86 65 17 92 83 71 61 54 58 47  ,
0004 16 8 9 32 84 7 87 46 19 30 37 96 6 98 40 79 97 45 64 60 29 49 36 43 55
0005 call lims lims;     call bins data
0006 call show 'the 1st set of bin counts for the specified data:'
0007 say;    say;    say
0008 lims=  14  18 249 312 389 392 513 591 634 720    /* ◄■■■■■■2nd set of bin limits & data.*/
0009 data= 445 814 519 697 700 130 255 889 481 122 932  77 323 525 570 219 367 523 442 933  ,
0010 416 589 930 373 202 253 775  47 731 685 293 126 133 450 545 100 741 583 763 306  ,
0011 655 267 248 477 549 238  62 678  98 534 622 907 406 714 184 391 913  42 560 247  ,
0012 346 860  56 138 546  38 985 948  58 213 799 319 390 634 458 945 733 507 916 123  ,
0013 345 110 720 917 313 845 426   9 457 628 410 723 354 895 881 953 677 137 397  97  ,
0014 854 740  83 216 421  94 517 479 292 963 376 981 480  39 257 272 157   5 316 395  ,
0015 787 942 456 242 759 898 576  67 298 425 894 435 831 241 989 614 987 770 384 692  ,
0016 698 765 331 487 251 600 879 342 982 527 736 795 585  40  54 901 408 359 577 237  ,
0017 605 847 353 968 832 205 838 427 876 959 686 646 835 127 621 892 443 198 988 791  ,
0018 466  23 707 467  33 670 921 180 991 396 160 436 717 918   8 374 101 684 727 749
0019 call lims lims;     call bins data
0020 call show 'the 2nd set of bin counts for the specified data:'
0021 exit 0                                           /*stick a fork in it,  we're all done. */
0022 /*──────────────────────────────────────────────────────────────────────────────────────*/
0023 bins: parse arg nums; !.= 0;  datum= words(nums);  wc= length(datum)  /*max width count.*/
0024 do   j=1  for datum;  x= word(nums, j)
0025 do k=0  for #                          /*find the bin that this number is in. */
0026 if x < @.k  then do;  !.k= !.k + 1;  iterate j;  end        /*bump a bin count*/
0027 end   /*k*/
0028 !.k= !.k + 1     /*number is > the highest bin specified*/
0029 end     /*j*/;                   return
0030 /*──────────────────────────────────────────────────────────────────────────────────────*/
0031 lims: parse arg limList;  #= words(limList);                 wb= 0    /*max width binLim*/
0032 do j=1  for #;  _= j - 1;   @._= word(limList, j);   wb= max(wb, length(@._) )
0033 end   /*j*/;                     return
0034 /*──────────────────────────────────────────────────────────────────────────────────────*/
0035 show: parse arg t;    say center(t,  51     );   $= left('', 9)  /*$:    for indentation*/
0036 say center('', 51, "═")                    /*show title separator.*/
0037 jp= # - 1;        ge= '≥';              le='<'; eq= '   count='
0038 do j=0  for #;    jm= j - 1;  bin= right(@.j, wb)
0039 if j==0  then say $ left('', length(ge) +3+wb+length(..) )le bin eq right(!.j, wc)
0040 else say $                 ge right(@.jm, wb) .. le bin eq right(!.j, wc)
0041 if j==jp  then say $ ge right(@.jp,wb) left('', 3+length(..)+wb) eq right(!.#, wc)
0042 end   /*j*/;                     return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 t                35
002 jp               37
003 ge               37
004 le               37
005 eq               37
006 j                38
007 jm               38
008 bin              38
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 !.               -> newV1.           23 26 28
002 @.               -> newV2.           32
003 #                -> newV3            31
004 _                -> newV4            32
005 $                -> newV5            35
