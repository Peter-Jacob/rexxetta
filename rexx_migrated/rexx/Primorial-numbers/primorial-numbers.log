-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:25
-------------------------------------------------------------------------
0001 /*REXX program computes some  primorial numbers  for low numbers,  and for various 10^n.*/
0002 parse arg N H .                                  /*get optional arguments:  N,  L,  H   */
0003 if N=='' | N==','  then N=     10                /*Not specified?  Then use the default.*/
0004 if H=='' | H==','  then H= 100000                /* "      "         "   "   "     "    */
0005 numeric digits 600000                            /*be able to handle gihugic numbers.   */
0006 w= length( commas( digits() ) )                  /*W:  width of the largest commatized #*/
0007 @.=.; @.0= 1;  @.1= 2;  @.2= 3;  @.3=  5; @.4=  7; @.5=  11; @.6=  13 /*some low primes.*/
0008 s.1= 4;  s.2= 9;  s.3= 25; s.4= 49; s.5= 121; s.6= 169 /*squared primes. */
0009 #= 6                                                                  /*number of primes*/
0010 do j=0  for N                               /*calculate the first  N  primorial #s.*/
0011 say right(j, length(N))th(j)   " primorial is: "    right(commas(primorial(j) ), N+2)
0012 end   /*j*/
0013 say
0014 iw= length( commas(H) ) + 2                      /*IW: width of largest commatized index*/
0015 p= 1                                             /*initialize the first multiplier for P*/
0016 do k=1  for H                               /*process a large range of numbers.    */
0017 p= p * prime(k)                             /*calculate the next primorial number. */
0018 parse var  k   L  2  ''  -1  R              /*get the left and rightmost dec digits*/
0019 if R\==0              then iterate          /*if right─most decimal digit\==0, skip*/
0020 if L\==1              then iterate          /* "  left─most    "      "  \==1,   " */
0021 if strip(k, , 0)\==1  then iterate          /*Not a power of 10?  Then skip this K.*/
0022 say right( commas(k), iw)th(k)     ' primorial number length in decimal digits is:' ,
0023 right( commas( length(p) ), w)
0024 end   /*k*/
0025 exit                                             /*stick a fork in it,  we're all done. */
0026 /*──────────────────────────────────────────────────────────────────────────────────────*/
0027 commas:  parse arg _;  do ?=length(_)-3  to 1  by -3; _=insert(',', _, ?); end;   return _
0028 th:      parse arg th; return word('th st nd rd', 1+ (th//10)*(th//100%10\==1)*(th//10<4))
0029 /*──────────────────────────────────────────────────────────────────────────────────────*/
0030 primorial: procedure expose @. s. #;  parse arg y;    != 1         /*obtain the arg  Y. */
0031 do p=0  to y;   != ! * prime(p)                     /*calculate product. */
0032 end   /*p*/;                           return !     /*return with the #. */
0033 /*──────────────────────────────────────────────────────────────────────────────────────*/
0034 prime: procedure expose @. s. #; parse arg n;  if @.n\==.  then return @.n
0035 numeric digits 9                                             /*limit digs to min.*/
0036 do j=@.#+2  by 2                                           /*start looking at #*/
0037 if j//2==0  then iterate;     if j//3==0    then iterate   /*divisible by 2│3 ?*/
0038 parse var  j   ''  -1  _;     if _==5       then iterate   /*right─most dig≡5? */
0039 if j//7==0  then iterate;     if j//11==0   then iterate   /*divisible by 7│11?*/
0040 do k=6  while s.k<=j;     if j//@.k==0  then iterate j /*divide by primes. */
0041 end   /*k*/
0042 #= # + 1;         @.#= j;     s.#= j * j;        return j  /*next prime; return*/
0043 end     /*j*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j                38
002 k                40
003 s.               42
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           7 7 7 7 7 7 7 7 42
002 #                -> newV2            9 42
003 _                -> newV3            27 27 38
004 ?                -> newV4            27
005 !                -> newV5            30 31
