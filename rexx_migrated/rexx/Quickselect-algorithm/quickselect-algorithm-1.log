-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:25
-------------------------------------------------------------------------
0001 /*REXX program sorts a list (which may be numbers)  by using the quick select algorithm.*/
0002 parse arg list;  if list=''  then list= 9 8 7 6 5 0 1 2 3 4   /*Not given?  Use default.*/
0003 say right('list: ', 22)           list
0004 #= words(list)
0005 do i=1  for #;  @.i= word(list, i) /*assign all the items ──► @. (array). */
0006 end   /*i*/                        /* [↑]  #: number of items in the list.*/
0007 say
0008 do j=1  for #                              /*show  1 ──►  # items place and value.*/
0009 say right('item', 20)     right(j, length(#))",  value:  "      qSel(1, #, j)
0010 end   /*j*/
0011 exit                                             /*stick a fork in it,  we're all done. */
0012 /*──────────────────────────────────────────────────────────────────────────────────────*/
0013 qPart: procedure expose @.;  parse arg L 1 ?,R,X;               xVal= @.X
0014 parse value  @.X @.R   with   @.R @.X     /*swap the two names items  (X and R). */
0015 do k=L  to R-1                      /*process the left side of the list.   */
0016 if @.k>xVal  then iterate           /*when an item > item #X, then skip it.*/
0017 parse value @.? @.k  with  @.k @.?  /*swap the two named items  (? and K). */
0018 ?= ? + 1                            /*bump the item number (point to next).*/
0019 end   /*k*/
0020 parse       value @.R @.?  with  @.? @.R  /*swap the two named items  (R and ?). */
0021 return ?                                  /*return the item number to invoker.   */
0022 /*──────────────────────────────────────────────────────────────────────────────────────*/
0023 qSel: procedure expose @.;  parse arg L,R,z;  if L==R  then return @.L  /*only one item?*/
0024 do forever                               /*keep searching until we're all done. */
0025 new= qPart(L, R, (L+R) % 2)              /*partition the list into roughly  ½.  */
0026 $= new - L + 1                           /*calculate pivot distance less  L+1.  */
0027 if $==z  then return @.new               /*we're all done with this pivot part. */
0028 else if  z<$  then     R= new-1 /*decrease the right half of the array.*/
0029 else do; z= z-$   /*decrease the distance.               */
0030 L= new+1 /*increase the  left half *f the array.*/
0031 end
0032 end   /*forever*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 L                23 30
002 R                23
003 z                23 29
004 new              25
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           5 14 14 17 17 20 20
002 #                -> newV2            4
003 ?                -> newV3            13 18
004 $                -> newV4            26
