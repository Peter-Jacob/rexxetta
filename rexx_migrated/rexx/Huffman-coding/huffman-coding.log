-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:16
-------------------------------------------------------------------------
0001 /* REXX ---------------------------------------------------------------
0002 * 27.12.2013 Walter Pachl
0003 * 29.12.2013 -"- changed for test of s=xrange('00'x,'ff'x)
0004 * 14.03.2018 -"- use format instead of right to diagnose size poblems
0005 * Stem m contains eventually the following node data
0006 * m.i.0id Node id
0007 * m.i.0c  character
0008 * m.i.0o  number of occurrences
0009 * m.i.0l  left child
0010 * m.i.0r  right child
0011 * m.i.0f  father
0012 * m.i.0d  digit (0 or 1)
0013 * m.i.0t  1=a terminal node 0=an intermediate or the top node
0014 *--------------------------------------------------------------------*/
0015 Parse Arg s
0016 If s='' Then
0017 s='this is an example for huffman encoding'
0018 Say 'We encode this string:'
0019 Say s
0020 debug=0
0021 o.=0
0022 c.=0
0023 codel.=0
0024 code.=''
0025 father.=0
0026 cl=''                                  /* list of characters         */
0027 do i=1 To length(s)
0028 Call memorize substr(s,i,1)
0029 End
0030 If debug Then Do
0031 Do i=1 To c.0
0032 c=c.i
0033 Say i c o.c
0034 End
0035 End
0036 n.=0
0037 Do i=1 To c.0
0038 c=c.i
0039 n.i.0c=c
0040 n.i.0o=o.c
0041 n.i.0id=i
0042 Call dbg i n.i.0id n.i.0c n.i.0o
0043 End
0044 n=c.0                                  /* number of nodes            */
0045 m.=0
0046 Do i=1 To n                            /* construct initial array    */
0047 Do j=1 To m.0                        /* sorted by occurrences      */
0048 If m.j.0o>n.i.0o Then
0049 Leave
0050 End
0051 Do k=m.0 To j By -1
0052 k1=k+1
0053 m.k1.0id=m.k.0id
0054 m.k1.0c =m.k.0c
0055 m.k1.0o =m.k.0o
0056 m.k1.0t =m.k.0t
0057 End
0058 m.j.0id=i
0059 m.j.0c =n.i.0c
0060 m.j.0o =n.i.0o
0061 m.j.0t =1
0062 m.0=m.0+1
0063 End
0064 If debug Then
0065 Call show
0066 
0067 Do While pairs()>1    /* while there are at least 2 fatherless nodes */
0068 Call mknode         /* create and fill a new father node           */
0069 If debug Then
0070 Call show
0071 End
0072 
0073 Call show
0074 c.=0
0075 Do i=1 To m.0       /* now we loop over all lines representing nodes */
0076 If m.i.0t Then Do   /* for each terminal node                 */
0077 code=m.i.0d       /* its digit is the last code digit            */
0078 node=m.i.0id      /* its id                                      */
0079 Do fi=1 To 1000   /* actually Forever                            */
0080 fid=father.node           /* id of father                      */
0081 If fid<>0 Then Do         /* father exists                     */
0082 fidz=zeile(fid)         /* line that contains the father     */
0083 code=m.fidz.0d||code    /* prepend the digit                 */
0084 node=fid                /* look for next father              */
0085 End
0086 Else                      /* no father (we reached the top     */
0087 Leave
0088 End
0089 If length(code)>1 Then      /* more than one character in input  */
0090 code=substr(code,2)       /* remove the the top node's 0       */
0091 call dbg m.i.0c '->' code   /* character is encoded this way     */
0092 char=m.i.0c
0093 code.char=code
0094 z=codel.0+1
0095 codel.z=code
0096 codel.0=z
0097 char.code=char
0098 End
0099 End
0100 
0101 Call show_char2code  /* show used characters and corresponding codes */
0102 
0103 codes.=0               /* now we build the array of codes/characters */
0104 Do j=1 To codel.0
0105 z=codes.0+1
0106 code=codel.j
0107 codes.z=code
0108 chars.z=char.code
0109 codes.0=z
0110 Call dbg codes.z '----->' chars.z
0111 End
0112 
0113 sc=''                  /* here we ecnode the string                  */
0114 Do i=1 To length(s)    /* loop over input                            */
0115 c=substr(s,i,1)      /* a character                                */
0116 sc=sc||code.c        /* append the corresponding code              */
0117 End
0118 Say 'Length of encoded string:' length(sc)
0119 Do i=1 To length(sc) by 70
0120 Say substr(sc,i,70)
0121 End
0122 
0123 sr=''                  /* now decode the string                      */
0124 Do si=1 To 999 While sc<>''
0125 Do i=codes.0 To 1 By -1              /* loop over codes            */
0126 cl=length(codes.i)                 /* length of code             */
0127 If left(sc,cl)==codes.i Then Do    /* found on top of string     */
0128 sr=sr||chars.i                   /* append character to result */
0129 sc=substr(sc,cl+1)               /* cut off the used code      */
0130 Leave                            /* this was one character     */
0131 End
0132 End
0133 End
0134 Say 'Input ="'s'"'
0135 Say 'result="'sr'"'
0136 
0137 Exit
0138 
0139 show:
0140 /*---------------------------------------------------------------------
0141 * show all lines representing node data
0142 *--------------------------------------------------------------------*/
0143 Say '  i   pp  id   c   f   l r d'
0144 Do i=1 To m.0
0145 Say format(i,3) format(m.i.0o,4) format(m.i.0id,3),
0146 format(m.i.0f,3) format(m.i.0l,3) format(m.i.0r,3) m.i.0d m.i.0t
0147 End
0148 Call dbg copies('-',21)
0149 Return
0150 
0151 pairs: Procedure Expose m.
0152 /*---------------------------------------------------------------------
0153 * return number of fatherless nodes
0154 *--------------------------------------------------------------------*/
0155 res=0
0156 Do i=1 To m.0
0157 If m.i.0f=0 Then
0158 res=res+1
0159 End
0160 Return res
0161 
0162 mknode:
0163 /*---------------------------------------------------------------------
0164 * construct and store a new intermediate or the top node
0165 *--------------------------------------------------------------------*/
0166 new.=0
0167 ni=m.0+1                 /* the next node id                         */
0168 Do i=1 To m.0            /* loop over node lines                     */
0169 If m.i.0f=0 Then Do    /* a fatherless node                        */
0170 z=m.i.0id            /* its id                                   */
0171 If new.0l=0 Then Do  /* new node has no left child               */
0172 new.0l=z           /* make this the lect child                 */
0173 new.0o=m.i.0o      /* occurrences                              */
0174 m.i.0f=ni          /* store father info                        */
0175 m.i.0d='0'         /* digit 0 to be used                       */
0176 father.z=ni        /* remember z's father (redundant)          */
0177 End
0178 Else Do              /* New node has already left child          */
0179 new.0r=z           /* make this the right child                */
0180 new.0o=new.0o+m.i.0o  /* add in the occurrences                */
0181 m.i.0f=ni          /* store father info                        */
0182 m.i.0d=1           /* digit 1 to be used                       */
0183 father.z=ni        /* remember z's father (redundant)          */
0184 Leave
0185 End
0186 End
0187 End
0188 Do i=1 To m.0            /* Insert new node according to occurrences */
0189 If m.i.0o>=new.0o Then Do
0190 Do k=m.0 To i By -1
0191 k1=k+1
0192 m.k1.0id=m.k.0id
0193 m.k1.0o =m.k.0o
0194 m.k1.0c =m.k.0c
0195 m.k1.0l =m.k.0l
0196 m.k1.0r =m.k.0r
0197 m.k1.0f =m.k.0f
0198 m.k1.0d =m.k.0d
0199 m.k1.0t =m.k.0t
0200 End
0201 Leave
0202 End
0203 End
0204 m.i.0id=ni
0205 m.i.0c ='*'
0206 m.i.0o =new.0o
0207 m.i.0l =new.0l
0208 m.i.0r =new.0r
0209 m.i.0t =0
0210 father.ni=0
0211 m.0=ni
0212 Return
0213 
0214 zeile:
0215 /*---------------------------------------------------------------------
0216 * find and return line number containing node-id
0217 *--------------------------------------------------------------------*/
0218 do fidz=1 To m.0
0219 If m.fidz.0id=arg(1) Then
0220 Return fidz
0221 End
0222 Call dbg arg(1) 'not found'
0223 Pull .
0224 
0225 dbg:
0226 /*---------------------------------------------------------------------
0227 * Show text if debug is enabled
0228 *--------------------------------------------------------------------*/
0229 If debug=1 Then
0230 Say arg(1)
0231 Return
0232 
0233 
0234 memorize: Procedure Expose c. o.
0235 /*---------------------------------------------------------------------
0236 * store characters and corresponding occurrences
0237 *--------------------------------------------------------------------*/
0238 Parse Arg c
0239 If o.c=0 Then Do
0240 z=c.0+1
0241 c.z=c
0242 c.0=z
0243 End
0244 o.c=o.c+1
0245 Return
0246 
0247 show_char2code:
0248 /*---------------------------------------------------------------------
0249 * show used characters and corresponding codes
0250 *--------------------------------------------------------------------*/
0251 cl=xrange('00'x,'ff'x)
0252 Say 'char --> code'
0253 Do While cl<>''
0254 Parse Var cl c +1 cl
0255 If code.c<>'' Then
0256 Say '   'c '-->' code.c
0257 End
0258 Return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 cl               254 254
002 c                254
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
