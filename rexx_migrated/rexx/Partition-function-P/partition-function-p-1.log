-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:23
-------------------------------------------------------------------------
0001 /*REXX program calculates and displays a specific value (or a range of)  partitionsP(N).*/
0002 numeric digits 1000                              /*able to handle some ginormous numbers*/
0003 parse arg lo hi .                                /*obtain optional arguments from the CL*/
0004 if lo=='' | lo==","  then lo=  0                 /*Not specified?  Then use the default.*/
0005 if hi=='' | hi==","  then hi= lo                 /* "      "         "   "   "     "    */
0006 @.= 0;    @.0= 1; @.1= 1; @.2= 2; @.3= 3; @.4= 5 /*assign default value and low values. */
0007 !.= @.;   !.1= 1; !.3= 1; !.5= 1; !.7= 1; !.9= 1 /*assign default value and even digits.*/
0008 w= length( commas(hi) )                          /*W:  is used for aligning the index.  */
0009 
0010 do j=lo  to hi                            /*compute a range of  partitionsP.     */
0011 say right( commas(j), w)    ' '     commas( partP(j) )
0012 end   /*j*/
0013 exit 0                                           /*stick a fork in it,  we're all done. */
0014 /*──────────────────────────────────────────────────────────────────────────────────────*/
0015 commas: parse arg ?;  do jc=length(?)-3  to 1  by -3; ?=insert(',', ?, jc); end;  return ?
0016 /*──────────────────────────────────────────────────────────────────────────────────────*/
0017 partP:  procedure expose @. !.;  parse arg n     /*obtain number (index) for computation*/
0018 if @.n\==0  then return @.n              /*Is it already computed?   Return it. */
0019 #= 0                                               /*initialize part  P  number.*/
0020 do k=1  for n;  z= n  -  (k*3 - 1) * k % 2  /*compute the partition P num*/
0021 if z<0  then leave                          /*Is Z negative?  Then leave.*/
0022 if @.z==0  then x= partP(z)                 /*use recursion if not known.*/
0023 else x= @.z                      /*use the pre─computed number*/
0024 z= z - k                                    /*subtract index (K) from Z. */
0025 if z<0     then y= 0                        /*Is Z negative? Then set Y=0*/
0026 else if @.z==0  then y= partP(z) /*use recursion if not known.*/
0027 else y= @.z      /*use the pre─computed number*/
0028 if k//2    then #= # +  x + y               /*Odd? Then   sum    X and Y.*/
0029 else #= # - (x + y)              /*Even?  "  subtract "  "  " */
0030 end   /*k*/
0031 @.n= #;                   return #       /*define and return partitionsP of  N. */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 n                17
002 k                20
003 z                20 24
004 x                22
005 y                25
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           6 6 6 6 6 6 31
002 !.               -> newV2.           7 7 7 7 7 7
003 ?                -> newV3            15 15
004 #                -> newV4            19 28
