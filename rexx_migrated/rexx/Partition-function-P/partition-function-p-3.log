-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:23
-------------------------------------------------------------------------
0001 /*REXX program calculates and displays a specific value (or a range of)  partitionsP(N).*/
0002 numeric digits 1000                              /*able to handle some ginormous numbers*/
0003 parse arg lo hi .                                /*obtain optional arguments from the CL*/
0004 if lo=='' | lo==","  then lo=  0                 /*Not specified?  Then use the default.*/
0005 if hi=='' | hi==","  then hi= lo                 /* "      "         "   "   "     "    */
0006 @.= 0;   @.0= 1; @.1= 1; @.2= 2; @.3= 3; @.4= 5  /*default values for some low numbers. */
0007 !.= @.;  !.1= 1; !.3= 1; !.5= 1; !.7= 1; !.9= 1  /*   "       "    "  all the 1─digit #s*/
0008 w= length( commas(hi) )                          /*W:  is used for aligning the index.  */
0009 do i=1  for hi;  a.i= (i+i+i - 1) * i % 2 /*calculate HI expressions (for partP).*/
0010 end   /*i*/
0011 
0012 do j=lo  to hi                            /*compute a range of  partitionsP.     */
0013 say right( commas(j), w)    ' '     commas( partP(j) )
0014 end   /*j*/
0015 exit 0                                           /*stick a fork in it,  we're all done. */
0016 /*──────────────────────────────────────────────────────────────────────────────────────*/
0017 commas: parse arg ?;  do jc=length(?)-3  to 1  by -3; ?=insert(',', ?, jc); end;  return ?
0018 /*──────────────────────────────────────────────────────────────────────────────────────*/
0019 partP:  procedure expose @. !. a.;  parse arg n  /*obtain number (index) for computation*/
0020 if @.n\==0  then return @.n              /*Is it already computed?   Return it. */
0021 #= 0                                               /*initialize part  P  number.*/
0022 do k=1  for n;  z= n - a.k                  /*compute the partition P num*/
0023 if z<0  then leave                          /*Is Z negative?  Then leave.*/
0024 if @.z==0  then x= partP(z)                 /*use recursion if not known.*/
0025 else x= @.z                      /*use the pre─computed number*/
0026 z= z - k                                    /*subtract index (K) from Z. */
0027 if z<0     then y= 0                        /*Is Z negative? Then set Y=0*/
0028 else if @.z==0  then y= partP(z) /*use recursion if not known.*/
0029 else y= @.z      /*use the pre─computed number*/
0030 parse var   k   ''  -1  _                   /*obtain K's last decimal dig*/
0031 if !._     then #= # +  x + y               /*Odd? Then   sum    X and Y.*/
0032 else #= # - (x + y)              /*Even?  "  subtract "  "  " */
0033 end   /*k*/
0034 @.n= #;                   return #       /*define and return partitionsP of  N. */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 k                30
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           6 6 6 6 6 6 34
002 !.               -> newV2.           7 7 7 7 7 7
003 ?                -> newV3            17 17
004 #                -> newV4            21 31
005 _                -> newV5            30
