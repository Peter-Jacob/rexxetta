-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:23
-------------------------------------------------------------------------
0001 /*REXX program  generates and displays  three forms  of an   NxN   Pascal matrix.       */
0002 numeric digits 50                                /*be able to calculate huge factorials.*/
0003 parse arg N .                                    /*obtain the optional matrix  size (N).*/
0004 if N==''  | N==","  then N= 5                    /*Not specified?  Then use the default.*/
0005 call show N, Pmat(N, 'upper'), 'Pascal upper triangular matrix'
0006 call show N, Pmat(N, 'lower'), 'Pascal lower triangular matrix'
0007 call show N, Pmat(N, 'sym')  , 'Pascal symmetric matrix'
0008 exit                                             /*stick a fork in it,  we're all done. */
0009 /*──────────────────────────────────────────────────────────────────────────────────────*/
0010 Pmat: procedure; parse arg N;    $=              /*generate a format of a Pascal matrix.*/
0011 arg , ?                                    /*get uppercase version of the 2nd arg.*/
0012 do i=0  for N; do j=0  for N       /*pick a format to use  [↓]            */
0013 if abbrev('UPPER'      , ?, 1)  then $= $ comb(j  , i)
0014 if abbrev('LOWER'      , ?, 1)  then $= $ comb(i  , j)
0015 if abbrev('SYMMETRICAL', ?, 1)  then $= $ comb(i+j, j)
0016 end  /*j*/         /*       ↑                              */
0017 end   /*i*/                       /*       │                              */
0018 return $                                  /*       └──min. abbreviation is 1 char.*/
0019 /*──────────────────────────────────────────────────────────────────────────────────────*/
0020 !:    procedure; parse arg x;  !=1;    do j=2  to x;    != ! * j;    end;      return !
0021 /*──────────────────────────────────────────────────────────────────────────────────────*/
0022 comb: procedure; parse arg x,y;        if x=y  then return 1                /* {=} case.*/
0023 if y>x  then return 0                /* {>} case.*/
0024 if x-y<y  then y=x-y; _= 1;      do j=x-y+1  to x;  _= _ * j;  end;  return _ / !(y)
0025 /*──────────────────────────────────────────────────────────────────────────────────────*/
0026 show: procedure; parse arg s,@;   w=0;    #=0                               /*get args. */
0027 do x=1  for s**2;  w=max(w,1+length(word(@,x)));  end
0028 say;   say center( arg(3), 50, '─')                                   /*show title*/
0029 do   r=1  for s;   if r==1  then $= '[['             /*row  1    */
0030 else $= ' ['             /*rows 2   N*/
0031 do c=1  for s;  #= # + 1;     e= (c==s)           /*e ≡ "end".*/
0032 $=$ || right( word(@, #), w) || left(', ',\e) || left("]", e)
0033 end   /*c*/                                       /* [↑]  row.*/
0034 say $ || left(',', r\==s)left(']', r==s)             /*show row. */
0035 end     /*r*/
0036 return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 s                26
002 w                26 27
003 x                27
004 r                29
005 c                31
006 e                31
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $                -> newV1            10 13 14 15 29 32
002 !                -> newV2            20 20
003 _                -> newV3            24 24
004 @                -> newV4            26
005 #                -> newV5            26 31
