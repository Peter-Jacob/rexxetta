-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:18
-------------------------------------------------------------------------
0001 /*REXX program solves a  knapsack problem  (22 items + repeats, with weight restriction.*/
0002 call @gen                                        /*generate items and initializations.  */
0003 call @sort                                       /*sort items by decreasing their weight*/
0004 call build                                       /*build a list of choices (objects).   */
0005 call showOBJ                                     /*display the list of choices (objects)*/
0006 call findBest                                    /*examine and find the possible choices*/
0007 call showBest                                    /*display best choice  (weight, value).*/
0008 exit                                             /*stick a fork in it,  we're all done. */
0009 /*──────────────────────────────────────────────────────────────────────────────────────*/
0010 @gen: @.=;        @.1  = 'map                       9  150'
0011 @.2  = 'compass                  13   35'
0012 @.3  = 'water                   153  200   2'
0013 @.4  = 'sandwich                 50   60   2'
0014 @.5  = 'glucose                  15   60   2'
0015 @.6  = 'tin                      68   45   3'
0016 @.7  = 'banana                   27   60   3'
0017 @.8  = 'apple                    39   40   3'
0018 @.9  = 'cheese                   23   30'
0019 @.10 = 'beer                     52   10   3'
0020 @.11 = 'suntan_cream             11   70'
0021 @.12 = 'camera                   32   30'
0022 @.13 = 'T-shirt                  24   15   2'
0023 @.14 = 'trousers                 48   10   2'
0024 @.15 = 'umbrella                 73   40'
0025 @.16 = 'waterproof_trousers      42   70'
0026 @.17 = 'waterproof_overclothes   43   75'
0027 @.18 = 'note-case                22   80'
0028 @.19 = 'sunglasses                7   20'
0029 @.20 = 'towel                    18   12   2'
0030 @.21 = 'socks                     4   50'
0031 @.22 = 'book                     30   10   2'
0032 highQ = 0                                    /*maximum quantity specified (if any). */
0033 maxL = length('knapsack items')             /* "     "    width for the table names*/
0034 maxW = length('weight')                     /* "     "      "    "    "   weights. */
0035 maxV = length('value')                      /* "     "      "    "    "   values.  */
0036 maxQ = length('pieces')                     /* "     "      "    "    "   quantity.*/
0037 maxWeight=400                               /*the maximum weight for the knapsack. */
0038 items= 0;   i.=;    w.=0;    v.=0;   q.=0   /*initialize some stuff and things.    */
0039 Tw= 0;   Tv=0;   Tq=0;    m=maxWeight    /*     "     more   "    "     "       */
0040 say;  say 'maximum weight allowed for a knapsack: '   commas(maxWeight);     say
0041 return
0042 /*──────────────────────────────────────────────────────────────────────────────────────*/
0043 @sort:        do j=1  while @.j\==''             /*process each choice and sort the item*/
0044 @.j=space(@.j);   _wt=word(@.j, 2) /*choose first item (arbitrary).       */
0045 do k=j+1  while @.k\==''       /*find a possible heavier item.        */
0046 ?wt=word(@.k, 2)
0047 if ?wt>_wt  then do;  _=@.k;  @.k=@.j;  @.j=_;  _wt=?wt;  end   /*swap*/
0048 end   /*k*/
0049 end       /*j*/                    /* [↑]  minimizes the # of combinations*/
0050 obj=j-1                                    /*adjust for the   DO   loop index.    */
0051 return
0052 /*──────────────────────────────────────────────────────────────────────────────────────*/
0053 build:        do j=1  for obj                    /*build a list of choices (objects).   */
0054 parse var  @.j  item  w  v  q  .   /*parse the original choice for table. */
0055 if w>maxWeight  then iterate       /*Is the weight > maximum?  Then ignore*/
0056 Tw=Tw+w;  Tv=Tv+v;   Tq=Tq+1       /*add the totals up  (for alignment).  */
0057 maxL=max(maxL, length(item))       /*find the maximum width for an item.  */
0058 if q==''  then q=1
0059 highQ=max(highQ, q)
0060 items=items+1                      /*bump the item counter.               */
0061 i.items=item;  w.items=w;  v.items=v;  q.items=q
0062 do k=2  to q  ;  items=items+1 /*bump the item counter  (each piece). */
0063 i.items=item;  w.items=w;  v.items=v;  q.items=q
0064 Tw=Tw+w;    Tv=Tv+v;    Tq=Tq+1
0065 end   /*k*/
0066 end       /*j*/
0067 maxW = max(maxW, length( commas(Tw) ) )    /*find the maximum width for weight.   */
0068 maxV = max(maxV, length( commas(Tv) ) )    /*  "   "     "      "    "  value.    */
0069 maxQ = max(maxQ, length( commas(Tq) ) )    /*  "   "     "      "    "  quantity. */
0070 maxL = maxL + maxL %4 + 4                  /*extend the width of name for table.  */
0071 return                                     /* [↑]    %  is REXX integer division. */
0072 /*──────────────────────────────────────────────────────────────────────────────────────*/
0073 commas: procedure;  parse arg _;   n=_'.9';   #=123456789;    b=verify(n, #, "M");   x=','
0074 e=verify(n, #'0', , verify(n, #"0.", 'M') ) - 4     /* [↓]  add commas to number*/
0075 do j=e  to b  by -3;    _=insert(x, _, j);  end  /*j*/;                return _
0076 /*──────────────────────────────────────────────────────────────────────────────────────*/
0077 hdr:  parse arg _item_, _;         if highq\==1  then _=center('pieces', maxq)
0078 call show center(_item_,  maxL), center('weight', maxW), center('value',  maxV), ,
0079 center(_     ,  maxQ);                          call hdr2;        return
0080 /*──────────────────────────────────────────────────────────────────────────────────────*/
0081 hdr2: _=maxQ;   x='═';          if highq==1  then _=0
0082 call show copies(x, maxL), copies(x, maxW), copies(x, maxV), copies(x, _);  return
0083 /*──────────────────────────────────────────────────────────────────────────────────────*/
0084 j?:   parse arg _,?;  $=value('Z'_);    do k=1  for _;  ?=? value('J'k);  end;    return
0085 /*──────────────────────────────────────────────────────────────────────────────────────*/
0086 show: parse arg _item, _weight, _value, _quant
0087 say translate(left(_item, maxL,'─'), ,'_')  right(commas(_weight), maxW),
0088 right(commas(_value ), maxV)            right(commas(_quant ), maxQ);   return
0089 /*──────────────────────────────────────────────────────────────────────────────────────*/
0090 showOBJ: call hdr 'item';     do j=1  for obj             /*show the formatted choices. */
0091 parse var  @.j  item weight value q .
0092 if highq==1  then  q=
0093 else  if q==''  then q=1
0094 call show  item, weight, value, q
0095 end   /*j*/
0096 say;    say  'number of   unique   named items: '    obj
0097 say  'number of items (including reps): '  items;    say;        return
0098 /*──────────────────────────────────────────────────────────────────────────────────────*/
0099 showBest:                     do words(?);  ?=strip(space(?), "L", 0);  end   /*words(?)*/
0100 bestC=?;   bestW=0;   bestV=$;   highQ=0;   totP=words(bestC);   say
0101 call hdr 'best choice'
0102 do j=1  to totP         /*J  is modified within  DO  loop.*/
0103 _=word(bestC, j);     _w=w._;     _v=v._;     q=1
0104 if _==0  then iterate
0105 do k=j+1  to totP;  __=word(bestC, k)  /*get a choice.*/
0106 if i._\==i.__  then leave              /*not equal ?  */
0107 j=j+1;       w._=w._+_w;       v._=v._+_v;         q=q+1
0108 end   /*k*/
0109 call show  i._,  w._,  v._,  q;            bestW=bestw+w._
0110 end       /*j*/
0111 call hdr2;    say
0112 call show 'best weight'   ,     bestW        /*show a nicely formatted winnerW.*/
0113 call show 'best value'    , ,   bestV        /*  "  "    "       "     winnerV.*/
0114 call show 'knapsack items', , , totP         /*  "  "    "       "     pieces. */
0115 return
0116 /*─────────────────────────────────────────────────────────────────────────────────────────────────────────*/
0117 findBest:      h=items;      $=0
0118 do j1 =0  for h+1;                                       w1=    w.j1 ; z1=    v.j1 ;if  z1>$ then call j?  1
0119 do j2 =j1 +(j1 >0) to h;if w.j2 +w1 >m then iterate  j1; w2=w1 +w.j2 ; z2=z1 +v.j2 ;if  z2>$ then call j?  2
0120 do j3 =j2 +(j2 >0) to h;if w.j3 +w2 >m then iterate  j2; w3=w2 +w.j3 ; z3=z2 +v.j3 ;if  z3>$ then call j?  3
0121 do j4 =j3 +(j3 >0) to h;if w.j4 +w3 >m then iterate  j3; w4=w3 +w.j4 ; z4=z3 +v.j4 ;if  z4>$ then call j?  4
0122 do j5 =j4 +(j4 >0) to h;if w.j5 +w4 >m then iterate  j4; w5=w4 +w.j5 ; z5=z4 +v.j5 ;if  z5>$ then call j?  5
0123 do j6 =j5 +(j5 >0) to h;if w.j6 +w5 >m then iterate  j5; w6=w5 +w.j6 ; z6=z5 +v.j6 ;if  z6>$ then call j?  6
0124 do j7 =j6 +(j6 >0) to h;if w.j7 +w6 >m then iterate  j6; w7=w6 +w.j7 ; z7=z6 +v.j7 ;if  z7>$ then call j?  7
0125 do j8 =j7 +(j7 >0) to h;if w.j8 +w7 >m then iterate  j7; w8=w7 +w.j8 ; z8=z7 +v.j8 ;if  z8>$ then call j?  8
0126 do j9 =j8 +(j8 >0) to h;if w.j9 +w8 >m then iterate  j8; w9=w8 +w.j9 ; z9=z8 +v.j9 ;if  z9>$ then call j?  9
0127 do j10=j9 +(j9 >0) to h;if w.j10+w9 >m then iterate  j9;w10=w9 +w.j10;z10=z9 +v.j10;if z10>$ then call j? 10
0128 do j11=j10+(j10>0) to h;if w.j11+w10>m then iterate j10;w11=w10+w.j11;z11=z10+v.j11;if z11>$ then call j? 11
0129 do j12=j11+(j11>0) to h;if w.j12+w11>m then iterate j11;w12=w11+w.j12;z12=z11+v.j12;if z12>$ then call j? 12
0130 do j13=j12+(j12>0) to h;if w.j13+w12>m then iterate j12;w13=w12+w.j13;z13=z12+v.j13;if z13>$ then call j? 13
0131 do j14=j13+(j13>0) to h;if w.j14+w13>m then iterate j13;w14=w13+w.j14;z14=z13+v.j14;if z14>$ then call j? 14
0132 do j15=j14+(j14>0) to h;if w.j15+w14>m then iterate j14;w15=w14+w.j15;z15=z14+v.j15;if z15>$ then call j? 15
0133 do j16=j15+(j15>0) to h;if w.j16+w15>m then iterate j15;w16=w15+w.j16;z16=z15+v.j16;if z16>$ then call j? 16
0134 do j17=j16+(j16>0) to h;if w.j17+w16>m then iterate j16;w17=w16+w.j17;z17=z16+v.j17;if z17>$ then call j? 17
0135 do j18=j17+(j17>0) to h;if w.j18+w17>m then iterate j17;w18=w17+w.j18;z18=z17+v.j18;if z18>$ then call j? 18
0136 do j19=j18+(j18>0) to h;if w.j19+w18>m then iterate j18;w19=w18+w.j19;z19=z18+v.j19;if z19>$ then call j? 19
0137 do j20=j19+(j19>0) to h;if w.j20+w19>m then iterate j19;w20=w19+w.j20;z20=z19+v.j20;if z20>$ then call j? 20
0138 do j21=j20+(j20>0) to h;if w.j21+w20>m then iterate j20;w21=w20+w.j21;z21=z20+v.j21;if z21>$ then call j? 21
0139 do j22=j21+(j21>0) to h;if w.j22+w21>m then iterate j21;w22=w21+w.j22;z22=z21+v.j22;if z22>$ then call j? 22
0140 do j23=j22+(j22>0) to h;if w.j23+w22>m then iterate j22;w23=w22+w.j23;z23=z22+v.j23;if z23>$ then call j? 23
0141 do j24=j23+(j23>0) to h;if w.j24+w23>m then iterate j23;w24=w23+w.j24;z24=z23+v.j24;if z24>$ then call j? 24
0142 do j25=j24+(j24>0) to h;if w.j25+w24>m then iterate j24;w25=w24+w.j25;z25=z24+v.j25;if z25>$ then call j? 25
0143 do j26=j25+(j25>0) to h;if w.j26+w25>m then iterate j25;w26=w25+w.j26;z26=z25+v.j26;if z26>$ then call j? 26
0144 do j27=j26+(j26>0) to h;if w.j27+w26>m then iterate j26;w27=w26+w.j27;z27=z26+v.j27;if z27>$ then call j? 27
0145 do j28=j27+(j27>0) to h;if w.j28+w27>m then iterate j27;w28=w27+w.j28;z28=z27+v.j28;if z28>$ then call j? 28
0146 do j29=j28+(j28>0) to h;if w.j29+w28>m then iterate j28;w29=w28+w.j29;z29=z28+v.j29;if z29>$ then call j? 29
0147 do j30=j29+(j29>0) to h;if w.j30+w29>m then iterate j29;w30=w29+w.j30;z30=z29+v.j30;if z30>$ then call j? 30
0148 do j31=j30+(j30>0) to h;if w.j31+w30>m then iterate j30;w31=w30+w.j31;z31=z30+v.j31;if z31>$ then call j? 31
0149 do j32=j31+(j31>0) to h;if w.j32+w31>m then iterate j31;w32=w31+w.j32;z32=z31+v.j32;if z32>$ then call j? 32
0150 do j33=j32+(j32>0) to h;if w.j33+w32>m then iterate j32;w33=w32+w.j33;z33=z32+v.j33;if z33>$ then call j? 33
0151 do j34=j33+(j33>0) to h;if w.j34+w33>m then iterate j33;w34=w33+w.j34;z34=z33+v.j34;if z34>$ then call j? 34
0152 do j35=j34+(j34>0) to h;if w.j35+w34>m then iterate j34;w35=w34+w.j35;z35=z34+v.j35;if z35>$ then call j? 35
0153 do j36=j35+(j35>0) to h;if w.j36+w35>m then iterate j35;w36=w35+w.j36;z36=z35+v.j36;if z36>$ then call j? 36
0154 do j37=j36+(j36>0) to h;if w.j37+w36>m then iterate j36;w37=w36+w.j37;z37=z36+v.j37;if z37>$ then call j? 37
0155 end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end;end
0156 end;end;end;end;end;end;end;end;end;end;        return      /* [↑]  there is one END for each DO loop.*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 item             91
002 weight           91
003 value            91
004 q                91 92 103 107
005 bestC            100
006 bestW            100 109
007 bestV            100
008 highQ            100
009 totP             100
010 j                102 107
011 k                105
012 w.               107
013 v.               107
014 j1               118
015 w1               118
016 z1               118
017 j2               119
018 w2               119
019 z2               119
020 j3               120
021 w3               120
022 z3               120
023 j4               121
024 w4               121
025 z4               121
026 j5               122
027 w5               122
028 z5               122
029 j6               123
030 w6               123
031 z6               123
032 j7               124
033 w7               124
034 z7               124
035 j8               125
036 w8               125
037 z8               125
038 j9               126
039 w9               126
040 z9               126
041 j10              127
042 w10              127
043 z10              127
044 j11              128
045 w11              128
046 z11              128
047 j12              129
048 w12              129
049 z12              129
050 j13              130
051 w13              130
052 z13              130
053 j14              131
054 w14              131
055 z14              131
056 j15              132
057 w15              132
058 z15              132
059 j16              133
060 w16              133
061 z16              133
062 j17              134
063 w17              134
064 z17              134
065 j18              135
066 w18              135
067 z18              135
068 j19              136
069 w19              136
070 z19              136
071 j20              137
072 w20              137
073 z20              137
074 j21              138
075 w21              138
076 z21              138
077 j22              139
078 w22              139
079 z22              139
080 j23              140
081 w23              140
082 z23              140
083 j24              141
084 w24              141
085 z24              141
086 j25              142
087 w25              142
088 z25              142
089 j26              143
090 w26              143
091 z26              143
092 j27              144
093 w27              144
094 z27              144
095 j28              145
096 w28              145
097 z28              145
098 j29              146
099 w29              146
100 z29              146
101 j30              147
102 w30              147
103 z30              147
104 j31              148
105 w31              148
106 z31              148
107 j32              149
108 w32              149
109 z32              149
110 j33              150
111 w33              150
112 z33              150
113 j34              151
114 w34              151
115 z34              151
116 j35              152
117 w35              152
118 z35              152
119 j36              153
120 w36              153
121 z36              153
122 j37              154
123 w37              154
124 z37              154
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 _weight          -> newV1            86
002 _item_           -> newV2            77
003 _value           -> newV3            86
004 _quant           -> newV4            86
005 _item            -> newV5            86
006 _wt              -> newV6            44 47
007 ?wt              -> newV7            46
008 @.               -> newV8.           10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 44 47 47 54 91
009 _w               -> newV9            103
010 _v               -> newV10           103
011 __               -> newV11           105
012 _                -> newV12           47 73 75 77 77 81 84 103
013 #                -> newV13           73
014 ?                -> newV14           84 84 99
015 $                -> newV15           84 117
