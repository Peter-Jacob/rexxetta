-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:08
-------------------------------------------------------------------------
0001 /*REXX program displays a (non-negative 4-digit) integer in  Cistercian (monk) numerals.*/
0002 parse arg m                                      /*obtain optional arguments from the CL*/
0003 if m='' | m=","  then m= 0 1 20 300 4000 5555 6789 9393  /*Not specified?  Use defaults.*/
0004 $.=;                     nnn= words(m)
0005 do j=1  for nnn;   z= word(m, j)            /*process each of the numbers. */
0006 if \datatype(z, 'W')  then call serr  "number isn't numeric: "           z
0007 if \datatype(z, 'N')  then call serr  "number isn't an integer: "        z
0008 z= z / 1                            /*normalize the number:  006  5.0  +4  */
0009 if z<0                then call serr  "number can't be negative: "       z
0010 if z>9999             then call serr  "number is too large (>9,999): "   z
0011 call monk z / 1                     /*create the Cistercian quad numeral.  */
0012 end   /*j*/
0013 call show                                        /*display   "      "       "     "     */
0014 exit 0                                           /*stick a fork in it,  we're all done. */
0015 /*──────────────────────────────────────────────────────────────────────────────────────*/
0016 @:    parse arg @x,@y;  return @.@x.@y           /*return a value from the point (@x,@y)*/
0017 quad: parse arg #;   if #\==0  then interpret 'call' #;  return       /*build a numeral.*/
0018 serr: say '***error*** '  arg(1);    exit 13                          /*issue error msg.*/
0019 app:   do r= 9 for 10 by -1; do c=-5 for 11; $.r= $.r||@.c.r; end; $.r=$.r b5; end; return
0020 eye:   do a=0  for 10; @.0.a= '│';   end; return /*build an "eye" glyph (vertical axis).*/
0021 p:     do k=1  by 3  until k>arg(); x= arg(k); y= arg(k+1); @.x.y= arg(k+2); end;   return
0022 sect:  do q=1  for 4; call quad s.q; end; return /*build a Cistercian numeral character.*/
0023 /*──────────────────────────────────────────────────────────────────────────────────────*/
0024 monk: parse arg n; n= right(n, 4, 0);  @.= ' '   /*zero─fill N;  blank─out numeral grid.*/
0025 b4= left('', 4);  b5= b4" ";   $.11= $.11  ||  b4  ||  n  ||  b4  ||  b5;   call eye
0026 parse var n s.4 2 s.3 3 s.2 4 s.1;    call sect;    call nice;    call app;   return
0027 /*──────────────────────────────────────────────────────────────────────────────────────*/
0028 nice: if @(-1, 9)=='─'     then call p 0, 9, "┐";    if @(1,9)=='─'  then call p 0, 9, "┌"
0029 if @(-1, 9)=='─'  &  @(1,9)=='─'                               then call p 0, 9, "┬"
0030 if @(-1, 0)=='─'     then call p 0, 0, "┘";    if @(1,0)=='─'  then call p 0, 0, "└"
0031 if @(-1, 0)=='─'  &  @(1,0)=='─'                               then call p 0, 0, "┴"
0032 do i=4  to 5
0033 if @(-1, i)=='─'  then call p 0, i, "┤";    if @(1,i)=='─'  then call p 0, i, "├"
0034 if @(-1, i)=='─'  &  @(1,i)=="─"                            then call p 0, i, "┼"
0035 end   /*i*/;                                                               return
0036 /*──────────────────────────────────────────────────────────────────────────────────────*/
0037 show:    do jj= 11  for 10+2  by -1;    say strip($.jj, 'T')  /*display 1 row at a time.*/
0038 if jj==5  then do 3;           say strip( copies(b5'│'b5 b5, nnn), 'T');     end
0039 end   /*r*/;                   return
0040 /*──────────────────────────────────────────────────────────────────────────────────────*/
0041 1: ?= '─';  if q==1  then call p  1, 9, ?,  2, 9, ?,  3, 9, ?,  4, 9, ?,  5, 9, ?
0042 if q==2  then call p -1, 9, ?, -2, 9, ?, -3, 9, ?, -4, 9, ?, -5, 9, ?
0043 if q==3  then call p  1, 0, ?,  2, 0, ?,  3, 0, ?,  4, 0, ?,  5, 0, ?
0044 if q==4  then call p -1, 0, ?, -2, 0, ?, -3, 0, ?, -4, 0, ?, -5, 0, ?;  return
0045 /*──────────────────────────────────────────────────────────────────────────────────────*/
0046 2: ?= '─';  if q==1  then call p  1, 5, ?,  2, 5, ?,  3, 5, ?,  4, 5, ?,  5, 5, ?
0047 if q==2  then call p -1, 5, ?, -2, 5, ?, -3, 5, ?, -4, 5, ?, -5, 5, ?
0048 if q==3  then call p  1, 4, ?,  2, 4, ?,  3, 4, ?,  4, 4, ?,  5, 4, ?
0049 if q==4  then call p -1, 4, ?, -2, 4, ?, -3, 4, ?, -4, 4, ?, -5, 4, ?;  return
0050 /*──────────────────────────────────────────────────────────────────────────────────────*/
0051 3: ?= '\';  if q==1  then call p  1, 9, ?,  2, 8, ?,  3, 7, ?,  4, 6, ?,  5, 5, ?
0052 ?= '/';  if q==2  then call p -1, 9, ?, -2, 8, ?, -3, 7, ?, -4, 6, ?, -5, 5, ?
0053 ?= '/';  if q==3  then call p  1, 0, ?,  2, 1, ?,  3, 2, ?,  4, 3, ?,  5, 4, ?
0054 ?= '\';  if q==4  then call p -5, 4, ?, -4, 3, ?, -3, 2, ?, -2, 1, ?, -1, 0, ?;  return
0055 /*──────────────────────────────────────────────────────────────────────────────────────*/
0056 4: ?= '/';  if q==1  then call p  1, 5, ?,  2, 6, ?,  3, 7, ?,  4, 8, ?,  5, 9, ?
0057 ?= '\';  if q==2  then call p -5, 9, ?, -4, 8, ?, -3, 7, ?, -2, 6, ?, -1, 5, ?
0058 ?= '\';  if q==3  then call p  1, 4, ?,  2, 3, ?,  3, 2, ?,  4, 1, ?,  5, 0, ?
0059 ?= '/';  if q==4  then call p -5, 0, ?, -4, 1, ?, -3, 2, ?, -2, 3, ?, -1, 4, ?;  return
0060 /*──────────────────────────────────────────────────────────────────────────────────────*/
0061 5: ?= '/';  if q==1  then call p  1, 5, ?,  2, 6, ?,  3, 7, ?,  4, 8, ?
0062 ?= '\';  if q==2  then call p -4, 8, ?, -3, 7, ?, -2, 6, ?, -1, 5, ?
0063 ?= '\';  if q==3  then call p  1, 4, ?,  2, 3, ?,  3, 2, ?,  4, 1, ?
0064 ?= '/';  if q==4  then call p -4, 1, ?, -3, 2, ?, -2, 3, ?, -1, 4, ?;  call 1;   return
0065 /*──────────────────────────────────────────────────────────────────────────────────────*/
0066 6: ?= '│';  if q==1  then call p  5, 9, ?,  5, 8, ?,  5, 7, ?,  5, 6, ?,  5, 5, ?
0067 if q==2  then call p -5, 9, ?, -5, 8, ?, -5, 7, ?, -5, 6, ?, -5, 5, ?
0068 if q==3  then call p  5, 0, ?,  5, 1, ?,  5, 2, ?,  5, 3, ?,  5, 4, ?
0069 if q==4  then call p -5, 0, ?, -5, 1, ?, -5, 2, ?, -5, 3, ?, -5, 4, ?;  return
0070 /*──────────────────────────────────────────────────────────────────────────────────────*/
0071 7:          call 1;  call 6;         if q==1  then call p  5, 9, '┐'
0072 if q==2  then call p -5, 9, '┌'
0073 if q==3  then call p  5, 0, '┘'
0074 if q==4  then call p -5, 0, '└';               return
0075 /*──────────────────────────────────────────────────────────────────────────────────────*/
0076 8:          call 2;  call 6;         if q==1  then call p  5, 5, '┘'
0077 if q==2  then call p -5, 5, '└'
0078 if q==3  then call p  5, 4, '┐'
0079 if q==4  then call p -5, 4, '┌';               return
0080 /*──────────────────────────────────────────────────────────────────────────────────────*/
0081 9:          call 1; call 2; call 6;  if q==1  then call p  5, 5, '┘',  5, 9, "┐"
0082 if q==2  then call p -5, 5, '└', -5, 9, "┌"
0083 if q==3  then call p  5, 0, '┘',  5, 4, "┐"
0084 if q==4  then call p -5, 0, '└', -5, 4, "┌";   return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 n                26
002 s.               26 26 26 26
003 i                32
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $.               -> newV1.           4 19 19 25
002 @x               -> newV2            16
003 @y               -> newV3            16
004 @.               -> newV4.           20 21 24
005 #                -> newV5            17
006 ?                -> newV6            52 53 54 57 58 59 62 63 64
