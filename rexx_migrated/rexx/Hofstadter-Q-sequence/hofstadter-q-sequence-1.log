-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:16
-------------------------------------------------------------------------
0001 /*REXX program generates the    Hofstadter  Q     sequence for any specified   N.       */
0002 parse arg a b c d .                              /*obtain optional arguments from the CL*/
0003 if a=='' | a==","  then a=       10              /*Not specified?  Then use the default.*/
0004 if b=='' | b==","  then b=    -1000              /* "      "         "   "   "      "   */
0005 if c=='' | c==","  then c=  -100000              /* "      "         "   "   "      "   */
0006 if d=='' | d==","  then d= -1000000              /* "      "         "   "   "      "   */
0007 @.= 1;                 ac=   abs(c)              /* [↑]  negative #'s don't show values.*/
0008 call HofstadterQ  a;   say
0009 call HofstadterQ  b;   say 'HofstadterQ '  commas(abs(b))th(b) " term is: " commas(result)
0010 call HofstadterQ  c;   say
0011 downs= 0;                         do j=2  for ac-1;     jm= j - 1
0012 downs= downs + (@.j<@.jm)
0013 end   /*j*/
0014 
0015 say commas(downs)    ' HofstatdterQ terms are less then the previous term,' ,
0016 ' HofstatdterQ('commas(ac)  ||  th(ac)")  term is: "     commas(@.ac)
0017 call HofstadterQ  d;                                             ad= abs(d);           say
0018 say 'The '   commas(ad) || th(ad)    ' HofstatdterQ term is: '       commas(@.ad)
0019 exit                                             /*stick a fork in it,  we're all done. */
0020 /*──────────────────────────────────────────────────────────────────────────────────────*/
0021 HofstadterQ: procedure expose @.; parse arg x 1 ox     /*get number to generate through.*/
0022 /* [↑]   OX    is the same as X. */
0023 x= abs(x);                    w= length( commas(x) )   /*use absolute value; get length.*/
0024 do j=1  for x                               /* [↓]  use short─circuit IF test*/
0025 if j>2   then if @.j==1  then  do;    jm1= j - 1;             jm2= j - 2
0026 one= j - @.jm1;         two= j - @.jm2
0027 @.j= @.one  +  @.two
0028 end
0029 if ox>0  then say 'HofstadterQ('right(j, w)"): "  right(@.j,max(w,length(@.j)))
0030 end    /*j*/
0031 return @.x                                             /*return the │X│th term to caller*/
0032 /*──────────────────────────────────────────────────────────────────────────────────────*/
0033 commas:  parse arg _;  do ?=length(_)-3  to 1  by -3; _=insert(',', _, ?); end;   return _
0034 th: procedure; #=abs(arg(1)); return word('th st nd rd',1+#//10*(#//100%10\==1)*(#//10<4))
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           7 27
002 _                -> newV2            33 33
003 ?                -> newV3            33
004 #                -> newV4            34
