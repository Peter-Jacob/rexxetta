-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:23
-------------------------------------------------------------------------
0001 /*REXX program  evaluates  a   ═════ Reverse Polish notation  (RPN) ═════   expression. */
0002 parse arg x                                      /*obtain optional arguments from the CL*/
0003 if x=''  then x= "3 4 2 * 1 5 - 2 3 ^ ^ / +"     /*Not specified?  Then use the default.*/
0004 tokens=words(x)                                  /*save the  number  of  tokens   "  ". */
0005 showSteps=1                                      /*set to 0 if working steps not wanted.*/
0006 ox=x                                             /*save the  original  value of  X.     */
0007 do i=1  for tokens;   @.i=word(x,i)  /*assign the input tokens to an array. */
0008 end   /*i*/
0009 x=space(x)                                       /*remove any superfluous blanks in  X. */
0010 L=max(20, length(x))                             /*use 20 for the minimum display width.*/
0011 numeric digits L                                 /*ensure enough decimal digits for ans.*/
0012 say center('operand', L, "─")        center('stack', L+L, "─")           /*display title*/
0013 $=                                               /*nullify the stack (completely empty).*/
0014 do k=1  for tokens;   ?=@.k;   ??=?       /*process each token from the  @. list.*/
0015 #=words($)                                /*stack the count (the number entries).*/
0016 if datatype(?,'N')  then do;  $=$ ?;   call show  "add to───►stack";  iterate;  end
0017 if ?=='^'           then ??= "**"         /*REXXify    ^ ───► **    (make legal).*/
0018 interpret 'y='word($,#-1)  ??  word($,#)  /*compute via the famous REXX INTERPRET*/
0019 if datatype(y,'N')  then y=y/1            /*normalize the number with ÷ by unity.*/
0020 $=subword($, 1, #-2)     y                /*rebuild the stack with the answer.   */
0021 call show ?                               /*display steps (tracing into),  maybe.*/
0022 end   /*k*/
0023 say                                              /*display a blank line, better perusing*/
0024 say ' RPN input:'  ox;   say "  answer──►"$      /*display original input;  display ans.*/
0025 parse source upper . y .                         /*invoked via  C.L.  or via a REXX pgm?*/
0026 if y=='COMMAND' | \datatype($,"W")  then exit    /*stick a fork in it,  we're all done. */
0027 else exit $  /*return the answer  ───►  the invoker.*/
0028 /*──────────────────────────────────────────────────────────────────────────────────────*/
0029 show: if showSteps  then say center(arg(1), L)            left(space($), L);        return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 source           25
002 y                25
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           7
002 ??               -> newV2            14 17
003 $                -> newV3            13 16 20
004 ?                -> newV4            14
005 #                -> newV5            15
