-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:12
-------------------------------------------------------------------------
0001 /*REXX pgm lists a bunch of esthetic numbers in bases 2 ──► 16, & base 10 in two ranges.*/
0002 parse arg baseL baseH range                      /*obtain optional arguments from the CL*/
0003 if baseL=='' | baseL==","  then baseL= 2         /*Not specified?  Then use the default.*/
0004 if baseH=='' | baseH==","  then baseH=16         /* "      "         "   "   "     "    */
0005 if range=='' | range==","  then range=1000..9999 /* "      "         "   "   "     "    */
0006 
0007 do radix=baseL  to baseH;  #= 0;  if radix<2  then iterate    /*process the bases. */
0008 start= radix * 4;                  stop = radix * 6
0009 $=;               do i=1  until #==stop;  y= base(i, radix)   /*convert I to base Y*/
0010 if \esthetic(y, radix)  then iterate        /*not esthetic?  Skip*/
0011 #= # + 1;   if #<start  then iterate        /*is  #  below range?*/
0012 $= $ y                                      /*append # to $ list.*/
0013 end   /*i*/
0014 say
0015 say center(' base '  radix",  the" th(start)   '──►'   th(stop) ,
0016 "esthetic numbers ",  max(80, length($) - 1),  '─')
0017 say strip($)
0018 end   /*radix*/
0019 say;                                                                            g= 25
0020 parse var  range   start  '..'  stop
0021 say center(' base 10 esthetic numbers between' start "and" stop '(inclusive) ', g*5-1,"─")
0022 #= 0;        $=
0023 do k=start  to  stop;  if \esthetic(k, 10)  then iterate;   #= # + 1;    $= $ k
0024 if #//g==0  then do;   say strip($);  $=;   end
0025 end   /*k*/
0026 say strip($);               say;                 say #   ' esthetic numbers listed.'
0027 exit                                             /*stick a fork in it,  we're all done. */
0028 /*──────────────────────────────────────────────────────────────────────────────────────*/
0029 PorA:  _= pos(z, @u);   p= substr(@u, _-1, 1);   a= substr(@u, _+1, 1);     return
0030 th: parse arg th; return th || word('th st nd rd', 1+(th//10)*(th//100%10\==1)*(th//10<4))
0031 vv: parse arg v,_;   vr= x2d(v) + _;   if vr==-1  then vr= r;               return d2x(vr)
0032 /*──────────────────────────────────────────────────────────────────────────────────────*/
0033 base: procedure expose @u;  arg x 1 #,toB,inB,,y /*Y  is assigned a  "null"  value.     */
0034 if tob==''  then tob= 10                   /*maybe assign a default for TObase.   */
0035 if inb==''  then inb= 10                   /*  "      "   "    "     "  INbase.   */
0036 @l= '0123456789abcdef';  @u= @l;  upper @u /*two versions of hexadecimal digits.  */
0037 if inB\==10  then do;   #= 0               /*only convert if  not  base 10.       */
0038 do j=1  for length(x) /*convert  X:   base inB  ──► base 10. */
0039 #= # * inB + pos(substr(x, j, 1), @u) -1  /*build new number.*/
0040 end    /*j*/          /* [↑]  this also verifies digits.     */
0041 end
0042 if toB==10   then return #                 /*if TOB is ten,  then simply return #.*/
0043 do  while  # >= toB                     /*convert #:    base 10  ──►  base toB.*/
0044 y= substr(@l, (# // toB) + 1, 1)y       /*construct the output number.         */
0045 #= # % toB                              /*      ··· and whittle  #  down also. */
0046 end    /*while*/                        /* [↑]  algorithm may leave a residual.*/
0047 return substr(@l, # + 1, 1)y               /*prepend the residual, if any.        */
0048 /*──────────────────────────────────────────────────────────────────────────────────────*/
0049 esthetic: procedure expose @u; arg x,r;       L= length(x);       if L==1  then return 1
0050 if x<2  then return 0
0051 do d=0  to r-1;  _= d2x(d);        if pos(_ || _, x)\==0  then return 0
0052 end   /*d*/                     /* [↑]  check for a duplicated digits. */
0053 do j=1  for L;  @.j= substr(x, j, 1) /*assign (base) digits to stemmed array*/
0054 end   /*j*/
0055 if L==2  then do;  z= @.1;   call PorA;      if @.2==p | @.2==a  then nop
0056 else return 0
0057 end
0058 do e=2  to L-1;  z= @.e;   pe= e - 1;      ae= e + 1
0059 if (z==vv(@.pe,-1)|z==vv(@.pe,1))&(z==vv(@.ae,-1)|z==vv(@.ae,1))  then iterate
0060 return 0
0061 end   /*e*/;         return 1
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 v                31
002 vr               31 31
003 tob              34
004 inb              35
005 j                38 53
006 while            43
007 y                44
008 L                49
009 d                51
010 z                55 58
011 e                58
012 pe               58
013 ae               58
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @l               -> newV1            36
002 @u               -> newV2            36
003 @.               -> newV3.           53
004 #                -> newV4            7 11 22 23 37 39 45
005 $                -> newV5            9 12 22 23 24
006 _                -> newV6            31 51
