-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:21
-------------------------------------------------------------------------
0001 /*REXX program puts the  Miller─Rabin  primality test  through its paces.               */
0002 parse arg limit times seed .                     /*obtain optional arguments from the CL*/
0003 if limit=='' | limit==","  then limit= 1000      /*Not specified?  Then use the default.*/
0004 if times=='' | times==","  then times=   10      /*  "      "        "   "   "     "    */
0005 if datatype(seed, 'W')  then call random ,,seed  /*If seed specified, use it for RANDOM.*/
0006 numeric digits max(200, 2*limit)                 /*we're dealing with some ginormous #s.*/
0007 tell= times<0                                    /*display primes  only if times is neg.*/
0008 times= abs(times);         w= length(times)      /*use absolute value of TIMES; get len.*/
0009 call genP  limit                                 /*suspenders now, use a belt later ··· */
0010 @MR= 'Miller─Rabin primality test'               /*define a character literal for  SAY. */
0011 say "There are"     #     'primes ≤'     limit   /*might as well display some stuff.    */
0012 say                                              /* [↓]  (skipping unity); show sep line*/
0013 do a=2  to times;     say copies('─', 89)   /*(skipping unity)   do range of TIMEs.*/
0014 p= 0                                        /*the counter of primes for this pass. */
0015 do z=1  for limit                      /*now, let's get busy and crank primes.*/
0016 if \M_Rt(z, a)  then iterate           /*Not prime?   Then try another number.*/
0017 p= p + 1                               /*well, we found another one, by gum!  */
0018 if tell  then say z   'is prime according to'       @MR       "with K="a
0019 if !.z   then iterate
0020 say '[K='a"] "    z   "isn't prime !"  /*oopsy─doopsy  and/or  whoopsy─daisy !*/
0021 end   /*z*/
0022 say '        for 1──►'limit", K="right(a,w)',' @MR "found"  p  'primes {out of' #"}."
0023 end     /*a*/
0024 exit                                             /*stick a fork in it,  we're all done. */
0025 /*──────────────────────────────────────────────────────────────────────────────────────*/
0026 genP: parse arg high;    @.=0;    @.1=2;   @.2=3;    !.=@.;   !.2=1;   !.3=1;     #=2
0027 do j=@.#+2  by 2  to high               /*just examine odd integers from here. */
0028 do k=2  while k*k<=j;  if j//@.k==0  then iterate j;   end  /*k*/
0029 #= # + 1;       @.#= j;        !.j= 1   /*bump prime counter; add prime to the */
0030 end   /*j*/;      return                /*@. array; define a prime in !. array.*/
0031 /*──────────────────────────────────────────────────────────────────────────────────────*/
0032 M_Rt: procedure;  parse arg n,k;  d= n-1;   nL=d /*Miller─Rabin:   A.K.A.  Rabin─Miller.*/
0033 if n==2           then return 1            /*special case of (the)  even  prime.  */
0034 if n<2 | n//2==0  then return 0            /*check for too low, or an even number.*/
0035 
0036 do s=-1  while d//2==0;  d= d % 2       /*keep halving  until a zero remainder.*/
0037 end   /*while*/
0038 
0039 do k;       ?= random(2, nL)    /* [↓]  perform the DO loop   K  times.*/
0040 x= ?**d  //  n                  /*X  can get real gihugeic really fast.*/
0041 if x==1 | x==nL  then iterate   /*First or penultimate? Try another pow*/
0042 do s;     x= x**2  //  n      /*compute new  X   ≡   X²  modulus  N. */
0043 if x==1   then return 0       /*if unity,  it's definitely not prime.*/
0044 if x==nL  then leave          /*if  N-1,   then it  could  be prime. */
0045 end   /*r*/                   /* [↑]  // is REXX's division remainder*/
0046 if x\==nL   then return 0       /*nope, it ain't prime nohows, noway.  */
0047 end     /*k*/                   /*maybe it's prime, maybe it ain't ··· */
0048 return 1                                   /*coulda/woulda/shoulda be prime;  yup.*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 n                32
002 k                32
003 d                32 36
004 nL               32
005 s                36
006 x                40 42
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @MR              -> newV1            10
002 @.               -> newV2.           26 26 26 29
003 !.               -> newV3.           26 26 26 29
004 #                -> newV4            26 29
005 ?                -> newV5            39
