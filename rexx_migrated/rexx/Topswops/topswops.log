-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:33
-------------------------------------------------------------------------
0001 /*REXX program generates  N  decks of  numbered cards  and  finds the maximum  "swops". */
0002 parse arg things .;          if things=='' then things= 10
0003 
0004 do n=1  for things;         #= decks(n, n) /*create a (things) number of "decks". */
0005 mx= n\==1                                  /*handle the case of a  one-card  deck.*/
0006 do i=1  for #;  p= swops(!.i)  /*compute the SWOPS for this iteration.*/
0007 if p>mx  then mx= p            /*This a new maximum?   Use a new max. */
0008 end   /*i*/
0009 say '──────── maximum swops for a deck of'   right(n,2)   ' cards is'    right(mx,4)
0010 end   /*n*/
0011 exit 0                                           /*stick a fork in it,  we're all done. */
0012 /*──────────────────────────────────────────────────────────────────────────────────────*/
0013 decks:  procedure expose !.; parse arg x,y,,$ @. /*   X  things  taken   Y   at a time. */
0014 #= 0;                call .decks 1       /* [↑]  initialize  $  &   @.  to null.*/
0015 return #                                 /*return number of permutations (decks)*/
0016 /*──────────────────────────────────────────────────────────────────────────────────────*/
0017 .decks: procedure expose !. @. x y $ #;          parse arg ?
0018 if ?>y  then do;  _=@.1;  do j=2  for y-1;  _= _ @.j;  end /*j*/;   #= #+1;  !.#=_
0019 end
0020 else do;           qm= ? - 1
0021 if ?==1  then qs= 2         /*don't use 1-swops that start with  1 */
0022 else if @.1==?  then qs=2  /*skip the 1-swops: 3 x 1 x ···*/
0023 else qs=1
0024 do q=qs  to x           /*build the permutations recursively.  */
0025 do k=1  for qm;  if @.k==q  then iterate q
0026 end  /*k*/
0027 @.?=q ;                call .decks ? + 1
0028 end        /*q*/
0029 end
0030 return
0031 /*──────────────────────────────────────────────────────────────────────────────────────*/
0032 swops:  parse arg z;   do u=1;    parse var z t .;    if \datatype(t, 'W')  then t= x2d(t)
0033 if word(z, t)==1  then return u             /*found unity at  T. */
0034 do h=10  to things;    if pos(h, z)==0  then iterate
0035 z= changestr(h, z, d2x(h) )         /* [↑]  any H's in Z?*/
0036 end   /*h*/
0037 z= reverse( subword(z, 1, t) )     subword(z, t + 1)
0038 end   /*u*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 z                32 35 37
002 t                32 32
003 h                34
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           13 27
002 !.               -> newV2.           18
003 #                -> newV3            4 14 18
004 $                -> newV4            13
005 ?                -> newV5            17
006 _                -> newV6            18 18
