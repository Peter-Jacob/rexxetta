-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:35
-------------------------------------------------------------------------
0001 /*REXX program finds and displays  Wieferich primes  which are under a specified limit N*/
0002 parse arg n .                                    /*obtain optional argument from the CL.*/
0003 if n=='' | n==","  then n= 5000                  /*Not specified?  Then use the default.*/
0004 numeric digits 3000                              /*bump # of dec. digs for calculation. */
0005 numeric digits max(9, length(2**n) )             /*calculate # of decimal digits needed.*/
0006 call genP                                        /*build array of semaphores for primes.*/
0007 title= ' Wieferich primes that are  < '   commas(n)    /*title for the output.*/
0008 w= length(title) + 2                             /*width of field for the primes listed.*/
0009 say ' index │'center(title, w)                   /*display the title for the output.    */
0010 say '───────┼'center(""   , w, '─')              /*   "     a   sep   "   "     "       */
0011 found= 0                                         /*initialize number of Wieferich primes*/
0012 do j=1  to #;    p= @.j                 /*search for Wieferich primes in range.*/
0013 if (2**(p-1)-1)//p**2\==0  then iterate /*P**2 not evenly divide  2**(P-1) - 1?*/       /* ◄■■■■■■■ the filter.*/
0014 found= found + 1                        /*bump the counter of Wieferich primes.*/
0015 say center(found, 7)'│'  center(commas(p), w)    /*display the Wieferich prime.*/
0016 end   /*j*/
0017 
0018 say '───────┴'center(""   , w, '─');   say       /*display a  foot sep  for the output. */
0019 say 'Found '       commas(found)       title     /*   "    "  summary    "   "     "    */
0020 exit 0                                           /*stick a fork in it,  we're all done. */
0021 /*──────────────────────────────────────────────────────────────────────────────────────*/
0022 commas: parse arg ?;  do jc=length(?)-3  to 1  by -3; ?=insert(',', ?, jc); end;  return ?
0023 /*──────────────────────────────────────────────────────────────────────────────────────*/
0024 genP:        @.1=2; @.2=3; @.3=5; @.4=7; @.5=11  /*define some low primes  (index-1).   */
0025 !.=0;  !.2=1; !.3=1; !.5=1; !.7=1; !.11=1  /*   "     "   "    "     (semaphores).*/
0026 #= 5;  sq.#= @.# ** 2 /*number of primes so far;     prime². */
0027 do j=@.#+2  by 2  to n-1;  parse var j '' -1 _   /*get right decimal digit of J.*/
0028 if    _==5  then iterate                               /*J ÷ by 5?    Yes, skip.*/
0029 if j//3==0  then iterate;  if j//7==0  then iterate    /*" "  " 3?    J ÷ by 7? */
0030 do k=5  while sq.k<=j             /* [↓]  divide by the known odd primes.*/
0031 if j//@.k==0  then iterate j      /*Is J ÷ a P?   Then not prime.   ___  */
0032 end   /*k*/                       /* [↑]  only process numbers  ≤  √ J   */
0033 #= #+1;    @.#= j;   sq.#= j*j;   !.j= 1 /*bump # Ps; assign next P; P sqare; P.*/
0034 end          /*j*/;               return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j                27
002 k                30
003 sq.              33
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           24 24 24 24 33
002 !.               -> newV2.           25 25 25 25 25 25 33
003 ?                -> newV3            22 22
004 #                -> newV4            26 33
005 _                -> newV5            27
