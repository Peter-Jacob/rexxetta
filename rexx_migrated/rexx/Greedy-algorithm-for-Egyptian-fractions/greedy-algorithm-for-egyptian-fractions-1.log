-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:15
-------------------------------------------------------------------------
0001 /*REXX program converts a fraction (can be improper) to an Egyptian fraction. */
0002 parse arg fract '' -1 t;  z=$egyptF(fract)  /*compute the Egyptian fraction.  */
0003 if t\==.  then say  fract   ' ───► '   z    /*show Egyptian fraction from C.L.*/
0004 return z                                    /*stick a fork in it,  we're done.*/
0005 /*────────────────────────────────$EGYPTF subroutine──────────────────────────*/
0006 $egyptF: parse arg z 1 zn '/' zd,,$;   if zd==''  then zd=1   /*whole number ?*/
0007 if z=''               then call erx  "no fraction was specified."
0008 if zd==0              then call erx  "denominator can't be zero:"       zd
0009 if zn==0              then call erx  "numerator can't be zero:"         zn
0010 if zd<0 | zn<0        then call erx  "fraction can't be negative"       z
0011 if \datatype(zn,'W')  then call erx  "numerator must be an integer:"    zn
0012 if \datatype(zd,'W')  then call erx  "denominator must be an integer:"  zd
0013 _=zn%zd                                /*check if it's an improper fraction.  */
0014 if _>=1  then do                       /*if improper fraction, then append it.*/
0015 $='['_"]"                /*append the whole # part of fraction. */
0016 zn=zn-_*zd               /*now, just use the proper fraction.   */
0017 if zn==0  then return $  /*Is there no fraction? Then we're done*/
0018 end
0019 if zd//zn==0  then do;  zd=zd%zn;  zn=1;  end
0020 do  forever
0021 if zn==1 & datatype(zd,'W')  then return $ "1/"zd   /*append Egyptian fract.*/
0022 nd=zd%zn+1;      $=$ '1/'nd          /*add unity to integer fraction, append*/
0023 z=$fractSub(zn'/'zd,  "-",  1'/'nd)  /*go and subtract the two fractions.   */
0024 parse var z zn '/' zd                /*extract the numerator and denominator*/
0025 L=2*max(length(zn),length(zd))       /*calculate if need more decimal digits*/
0026 if L>=digits()  then numeric digits L+L  /*yes, then bump the decimal digits*/
0027 end   /*forever*/                    /* [↑]  the DO forever ends when zn==1.*/
0028 /*────────────────────────────────$FRACTSUB subroutine────────────────────────*/
0029 $fractSub: procedure;  parse arg z.1,,z.2 1 zz.2;  arg ,op
0030 do j=1  for 2;    z.j=translate(z.j,'/',"_");   end
0031 if z.1==''  then z.1=(op\=="+" & op\=='-')     /*unary +,-     first fraction.*/
0032 if z.2==''  then z.2=(op\=="+" & op\=='-')     /*unary +.-    second fraction.*/
0033 do j=1  for 2                                /*process both of the fractions*/
0034 if pos('/',z.j)==0     then z.j=z.j"/1";     parse var  z.j  n.j  '/'  d.j
0035 if \datatype(n.j,'N')  then call erx  "numerator isn't an integer:"    n.j
0036 if \datatype(d.j,'N')  then call erx  "denominator isn't an integer:"  d.j
0037 n.j=n.j/1;   d.j=d.j/1                    /*normalize numerator/denominator.*/
0038 
0039 do  while \datatype(n.j,'W');  n.j=n.j*10/1;  d.j=d.j*10/1;  end /*while*/
0040 /* [↑]  normalize both numbers.   */
0041 if d.j=0  then call erx  "denominator can't be zero:"   z.j
0042 g=gcd(n.j,d.j);   if g=0  then iterate;     n.j=n.j/g;         d.j=d.j/g
0043 end    /*j*/
0044 l=lcm(d.1 d.2);             do j=1  for 2;  n.j=l*n.j/d.j;  d.j=l;  end  /*j*/
0045 if op=='-'  then n.2=-n.2
0046 t=n.1+n.2;       u=l;                  if t==0  then return 0
0047 g=gcd(t,u);      t=t/g;     u=u/g;     if u==1  then return t
0048 return t'/'u
0049 /*─────────────────────────────general 1─line subs────────────────────────────*/
0050 erx:  say;  say '***error!***' arg(1);       say;          exit 13
0051 gcd:procedure;$=;do i=1 for arg();$=$ arg(i);end;parse var $ x z .;if x=0 then x=z;x=abs(x);do j=2 to words($);y=abs(word($,j));if y=0 then iterate;do until _==0;_=x//y;x=y;y=_;end;end;return x
0052 lcm:procedure;y=;do j=1 for arg();y=y arg(j);end;x=word(y,1);do k=2 to words(y);!=abs(word(y,k));if !=0 then return 0;x=x*!/gcd(x,!);end;return x
0053 p:  return word(arg(1),1)
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                51 51 51 51 52 52
002 z                51
003 j                51 52
004 y                51 51 52 52
005 until            51
006 k                52
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $                -> newV1            6 15 22 51 51 51
002 _                -> newV2            13 51
003 !                -> newV3            52
