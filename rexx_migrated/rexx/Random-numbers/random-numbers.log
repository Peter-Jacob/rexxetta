-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:26
-------------------------------------------------------------------------
0001 /*REXX pgm generates 1,000 normally distributed numbers:  mean=1,  standard deviation=Β½.*/
0002 numeric digits 20                                /*the default decimal digit precision=9*/
0003 parse arg n seed .                               /*allow specification of N and the seed*/
0004 if n==''  |  n==","    then n=1000               /*N:    is the size of the array.      */
0005 if datatype(seed,'W')  then call random ,,seed   /*SEED: for repeatable random numbers. */
0006 newMean=1                                        /*the desired new mean (arithmetic avg)*/
0007 sd=1/2                                           /*the desired new standard deviation.  */
0008 do g=1  for n                             /*generate  N uniform random #'s (0,1].*/
0009 #.g = random(1, 1e5)  /  1e5              /*REXX's RANDOM BIF generates integers.*/
0010 end   /*g*/                               /* [β†‘]  random integers β”€β”€β–Ί fractions. */
0011 say '              old mean='   mean()
0012 say 'old standard deviation='   stdDev()
0013 call pi;       pi2=pi * 2                        /*define   pi    and also    2 * pi.   */
0014 say
0015 do j=1  to n-1  by 2;    m=j+1            /*step through the iterations by two.  */
0016 _=sd *  sqrt(ln(#.j) * -2)            /*calculate the  used-twice expression.*/
0017 #.j=_ * cos(pi2 * #.m)  +  newMean        /*utilize the  Boxβ”€Muller method.      */
0018 #.m=_ * sin(pi2 * #.m)  +  newMean        /*random number must be:      (0,1]    */
0019 end   /*j*/
0020 say '              new mean='     mean()
0021 say 'new standard deviation='     stdDev()
0022 exit                                             /*stick a fork in it,  we're all done. */
0023 /*β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€*/
0024 mean:   _=0;                   do k=1  for n;  _=_ + #.k;              end;                return      _/n
0025 stdDev: _avg=mean();  _=0;     do k=1  for n;  _=_ + (#.k - _avg)**2;  end;                return sqrt(_/n)
0026 e:      e =2.7182818284590452353602874713526624977572470936999595749669676277240766303535; return e   /*digs overkill*/
0027 pi:     pi=3.1415926535897932384626433832795028841971693993751058209749445923078164062862; return pi  /*  "      "   */
0028 r2r:    return arg(1)  //  (pi() * 2)                                                                 /*normalize ang*/
0029 sin:    procedure; parse arg x;x=r2r(x);numeric fuzz min(5,digits()-3);if abs(x)=pi then return 0;return .sincos(x,x,1)
0030 .sincos:parse arg z,_,i; x=x*x; p=z;    do k=2 by 2; _=-_*x/(k*(k+i)); z=z+_; if z=p then leave; p=z; end;     return z
0031 /*β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€*/
0032 ln:     procedure; parse arg x,f;   call e;   ig= x>1.5;     is=1 - 2 * (ig\==1);           ii=0;             xx=x
0033 do while ig&xx>1.5|\ig&xx<.5;_=e;do k=-1;iz=xx*_**-is;if k>=0&(ig&iz<1|\ig&iz>.5) then leave;_=_*_;izz=iz;end
0034 xx=izz;ii=ii+is*2**k;end;x=x*e**-ii-1;z=0;_=-1;p=z;do k=1;_=-_*x;z=z+_/k;if z=p then leave;p=z;end; return z+ii
0035 /*β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€*/
0036 cos:    procedure; parse arg x;       x=r2r(x);        a=abs(x);               hpi=pi * .5
0037 numeric fuzz min(6, digits() - 3);      if a=pi    then return -1
0038 if a=hpi | a=hpi*3  then return 0;      if a=pi/3  then return .5
0039 if a=pi * 2/3       then return -.5;                    return .sinCos(1,1,-1)
0040 /*β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€*/
0041 sqrt:   procedure; parse arg x; if x=0  then return 0;  d=digits();  numeric digits; h=d+6
0042 numeric form; parse value format(x,2,1,,0) 'E0'  with  g 'E' _ .;  g=g * .5'e'_ %2
0043 m.=9;     do j=0  while h>9;       m.j=h;                h=h%2 + 1;      end /*j*/
0044 do k=j+5  to 0  by -1;   numeric digits m.k;   g=(g+x/g)*.5;   end /*k*/
0045 numeric digits d;     return g/1
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                41
002 d                41
003 h                41 43
004 is               32
005 ii               32 34
006 xx               32 34
007 k                33 34 44
008 iz               33
009 izz              33
010 z                34 34
011 p                34 34
012 NORMAL.12        
013 NORMAL.13        
014 NORMAL.14        
015 NORMAL.15        
016 NORMAL.16        
017 NORMAL.17        
018 NORMAL.18        
019 NORMAL.19        
020 NORMAL.20        
021 NORMAL.21        
022 NORMAL.22        
023 g                42 42 44
024 m.               43 43
025 j                43
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 /*ΕΨΨ πην ηεξε -> newV1            1
002 #.               -> newV2.           9 17 18
003 _                -> newV3            16 24 25 25 30 30 33 33 34 34 42
