-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:24
-------------------------------------------------------------------------
0001 /*REXX program  implements a   Perlin noise algorithm   of a  point  in  3D─space.      */
0002 _= 97a0895b5a0f830dc95f6035c2e907e18c24671e458e086325f0150a17be0694f778ea4b001ac53e5efcdbcb75230b2039b12158ed953857ae147d88aba844af,
0003 ||4aa547868b301ba64d929ee7536fe57a3cd385e6dc695c29372ef528f4668f3641193fa101d85049d14c84bbd05912a9c8c4878274bc9f56a4646dc6adba0340,
0004 ||34d9e2fa7c7b05ca2693767eff5255d4cfce3be32f103a11b6bd1c2adfb7aad577f898022c9aa346dd99659ba72bac09811627fd13626c6e4f71e0e8b2b97068,
0005 ||daf661e4fb22f2c1eed2900cbfb3a2f1513391ebf90eef6b31c0d61fb5c76a9db854ccb07379322d7f0496fe8aeccd5dde72431d1848f38d80c34e42d73d9cb4
0006 do j=0  for length(_)%2;   @.j= x2d( substr(_,  2 * j  + 1,  2) )
0007 end   /*j*/                                 /* [↑]  assign an indexed array.       */
0008 parse arg x y z d .                              /*obtain optional arguments from the CL*/
0009 if x=='' | x==","  then x=   3.14                /*Not specified?  Then use the default.*/
0010 if y=='' | y==","  then y=  42                   /* "      "         "   "   "     "    */
0011 if z=='' | z==","  then z=   7                   /* "      "         "   "   "     "    */
0012 if d=='' | d==","  then d= 100                   /* "      "         "   "   "     "    */
0013 numeric digits d                                 /*use  D  decimal digits for precision.*/
0014 say 'Perlin noise for the 3D point  ['space(x y z, 3)"]  ───► "       PerlinNoise(x, y, z)
0015 exit                                             /*stick a fork in it,  we're all done. */
0016 /*──────────────────────────────────────────────────────────────────────────────────────*/
0017 fade:  procedure; parse arg t;                    return  t**3 * (t * (t * 6 - 15)  +  10)
0018 floor: procedure; parse arg x;       _= x % 1;    return  _  -   (x < 0)   *   (x \= _)
0019 lerp:  procedure; parse arg t,a,b;                return  a  +    t * (b - a)
0020 pick:  _= abs( arg(1) ) // 256;                   return  @._
0021 /*──────────────────────────────────────────────────────────────────────────────────────*/
0022 grad:  procedure; parse arg hash,x,y,z;  _= abs(hash) // 16   /*force positive remainder*/
0023 select
0024 when _== 0 | _==12  then return  x+y;       when _== 1 | _==14  then return  y-x
0025 when _== 2          then return  x-y;       when _== 3          then return -x-y
0026 when _== 4          then return  x+z;       when _== 5          then return  z-x
0027 when _== 6          then return  x-z;       when _== 7          then return -x-z
0028 when _== 8          then return  y+z;       when _== 9 | _==13  then return  z-y
0029 when _==10          then return  y-z
0030 otherwise                return -y-z             /*for cases   11  or  15. */
0031 end   /*select*/
0032 /*──────────────────────────────────────────────────────────────────────────────────────*/
0033 PerlinNoise: procedure expose @.;     parse arg x,y,z
0034 x$= floor(x) // 256;     x = x - floor(x);    xm= x-1;     u= fade(x)
0035 y$= floor(y) // 256;     y = y - floor(y);    ym= y-1;     v= fade(y)
0036 z$= floor(z) // 256;     z = z - floor(z);    zm= z-1;     w= fade(z)
0037 a = pick(x$   ) + y$;    aa= pick(a) + z$;                ab= pick(a +1) + z$
0038 b = pick(x$ +1) + y$;    ba= pick(b) + z$;                bb= pick(b +1) + z$
0039 return lerp(w, lerp(v, lerp(u,  grad(  pick(aa  ),   x ,    y ,   z   ),    ,
0040 grad(  pick(ba  ),   xm,    y ,   z   )),   ,
0041 lerp(u,  grad(  pick(ab  ),   x ,    ym,   z   ),    ,
0042 grad(  pick(bb  ),   xm,    ym,   z   ))),  ,
0043 lerp(v, lerp(u,  grad(  pick(aa+1),   x ,    y ,   zm  ),    ,
0044 grad(  pick(ba+1),   xm,    y ,   zm  )),   ,
0045 lerp(u,  grad(  pick(ab+1),   x ,    ym,   zm  ),    ,
0046 grad(  pick(bb+1),   xm,    ym,   zm  )))) /1
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                33 34
002 y                33 35
003 z                33 36
004 x$               34
005 xm               34
006 u                34
007 y$               35
008 ym               35
009 v                35
010 z$               36
011 zm               36
012 w                36
013 a                37
014 aa               37
015 ab               37
016 b                38
017 ba               38
018 bb               38
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           6
002 _                -> newV2            2 18 22
