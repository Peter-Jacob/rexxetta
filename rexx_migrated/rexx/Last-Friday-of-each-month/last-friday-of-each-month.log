-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:18
-------------------------------------------------------------------------
0001 /*REXX program displays the dates of the  last Fridays of each month for any given year.*/
0002 parse arg yyyy                                   /*obtain optional argument from the CL.*/
0003 do j=1  for 12                  /*traipse through all the year's months*/
0004 say lastDOW('Friday', j, yyyy)  /*find last Friday for the  Jth  month.*/
0005 end  /*j*/
0006 exit                                             /*stick a fork in it,  we're all done. */
0007 /*──────────────────────────────────────────────────────────────────────────────────────*/
0008 lastDOW: procedure;  arg dow .,mm .,yy .;      parse arg a.1,a.2,a.3 /*DOW = day of week*/
0009 if mm=='' | mm=='*'  then mm= left( date('U'), 2)                    /*use default month*/
0010 if yy=='' | yy=='*'  then yy= left( date('S'), 4)                    /*use default year */
0011 if length(yy)==2     then yy= left( date('S'), 2)yy                  /*append century.  */
0012 /*Note mandatory leading blank in strings below*/
0013 $=" Monday TUesday Wednesday THursday Friday SAturday SUnday"
0014 !=" JAnuary February MARch APril MAY JUNe JULy AUgust September October November December"
0015 upper $ !                                                            /*uppercase strings*/
0016 if dow==''                 then call .er "wasn't specified",     1   /*no month given ? */
0017 if arg()>3                 then call .er 'arguments specified',  4   /*too many args  ? */
0018 
0019 do j=1  for 3                                                      /*any plural args ?*/
0020 if words( arg(j) ) > 1   then call .er 'is illegal:',   j          /*check if plural. */
0021 end
0022 /*find DOW in list.*/
0023 dw= pos(' 'dow, $)                                                   /*find  day-of-week*/
0024 if dw==0                   then call .er 'is invalid:'  , 1          /*no DOW was found?*/
0025 if dw\==lastpos(' 'dow,$)  then call .er 'is ambiguous:', 1          /*check min length.*/
0026 
0027 if datatype(mm, 'M')  then do                                        /*is MM alphabetic?*/
0028 m= pos(' 'mm, !)                          /*maybe its good...*/
0029 if m==0                   then call .er 'is invalid:'  ,   1
0030 if m\==lastpos(' 'mm,!)   then call .er 'is ambiguous:',   2
0031 mm= wordpos( word( substr(!,m), 1), !)-1  /*now, use true Mon*/
0032 end
0033 
0034 if \datatype(mm, 'W')   then call .er "isn't an integer:",       2   /*MM (mon) ¬integer*/
0035 if \datatype(yy, 'W')   then call .er "isn't an integer:",       3   /*YY (yr)  ¬integer*/
0036 if mm<1 | mm>12         then call .er "isn't in range 1──►12:",  2   /*MM out─of─range. */
0037 if yy=0                 then call .er "can't be 0 (zero):",      3   /*YY can't be zero.*/
0038 if yy<0                 then call .er "can't be negative:",      3   /* "   "    " neg. */
0039 if yy>9999              then call .er "can't be > 9999:",        3   /* "   "    " huge.*/
0040 
0041 tdow= wordpos( word( substr($, dw), 1), $) - 1                       /*target DOW, 0──►6*/
0042 /*day# of last dom.*/
0043 _= date('B', right(yy + (mm=12), 4)right(mm // 12 + 1,  2, 0)"01", 'S') - 1
0044 ?= _ // 7                                                            /*calc. DOW,  0──►6*/
0045 if ?\==tdow  then _= _  -  ?  -  7  +  tdow  +  7 * (?>tdow)         /*not DOW?  Adjust.*/
0046 return date('weekday', _, "B")    date(, _, 'B')                     /*return the answer*/
0047 /*──────────────────────────────────────────────────────────────────────────────────────*/
0048 .er: arg ,_;   say;    say '***error*** (in LASTDOW)';        say    /*tell error,  and */
0049 say word('day-of-week month year excess', arg(2))  arg(1)  a._  /*plug in a choice.*/
0050 say;      exit 13                                               /*··· then exit.   */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 a.               8 8 8
002 mm               9 31
003 yy               10 11
004 j                19
005 dw               23
006 m                28
007 tdow             41
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $                -> newV1            13
002 !                -> newV2            14
003 _                -> newV3            43 45
004 ?                -> newV4            44
