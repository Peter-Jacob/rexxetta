-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:06
-------------------------------------------------------------------------
0001 /*REXX pgm demonstrates Benford's law applied to 2 common functions (30 dec. digs used).*/
0002 numeric digits length( e() )  -  length(.)       /*width of (e)  for LN & LOG precision.*/
0003 parse arg N .;  if N=='' | N==","  then N= 1000  /*allow sample size to be specified.   */
0004 pad= "   "                                       /*W1, W2: # digs past the decimal point*/
0005 w1= max(2 + length('observed'), length(N-2) )    /*for aligning output for a number.    */
0006 w2= max(2 + length('expected'), length(N  ) )    /* "      "    frequency distributions.*/
0007 LN10= ln(10)                                     /*calculate the  ln(10)   {used by LOG}*/
0008 call coef                                        /*generate nine frequency coefficients.*/
0009 call fib                                         /*generate   N   Fibonacci numbers.    */
0010 call show "Benford's law applied to"      N      'Fibonacci numbers'
0011 call fact                                        /*generate   N   factorials.           */
0012 call show "Benford's law applied to"      N      'factorial products'
0013 exit                                             /*stick a fork in it,  we're all done. */
0014 /*──────────────────────────────────────────────────────────────────────────────────────*/
0015 coef:       do j=1  for 9; #.j=pad center(format(log(1+1/j),,length(N)+2),w2); end; return
0016 fact: @.=1; do j=2  for N-1;       a= j-1;                   @.j= @.a * j;     end; return
0017 fib:  @.=1; do j=3  for N-2;       a= j-1;       b= a-1;     @.j= @.a + @.b;   end; return
0018 e:    return 2.71828182845904523536028747135266249775724709369995957496696762772407663035
0019 log:  return   ln( arg(1) )    /   LN10
0020 /*──────────────────────────────────────────────────────────────────────────────────────*/
0021 ln: procedure; parse arg x; e= e();  _= e;  ig= (x>1.5);  is= 1 - 2 * (ig\=1); i= 0;  s= x
0022 do while ig&s>1.5  |  \ig&s<.5             /*nitty─gritty part of  LN  calculation*/
0023 do k=-1; iz=s*_**-is; if k>=0&(ig&iz<1|\ig&iz>.5)  then leave; _=_*_; izz=iz;  end
0024 s=izz;  i= i + is* 2**k; end  /*while*/;    x= x * e** - i - 1;  z= 0;  _= -1;  p= z
0025 do k=1;  _= -_ * x; z= z + _/k; if z=p  then leave;  p= z;  end /*k*/;  return z+i
0026 /*──────────────────────────────────────────────────────────────────────────────────────*/
0027 show: say;  say pad   ' digit '    pad   center("observed",w1)  pad  center('expected',w2)
0028 say pad  '───────'   pad   center("", w1, '─')  pad  center("",w2,'─')   pad  arg(1)
0029 !.=0;     do j=1  for N;   _= left(@.j, 1);     !._= !._ + 1  /*get the 1st digit.*/
0030 end   /*j*/
0031 do f=1  for 9;  say pad center(f,7) pad center(format(!.f/N,,length(N-2)),w1)  #.f
0032 end   /*k*/
0033 return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                21 24
002 e                21
003 ig               21
004 is               21
005 i                21 24
006 s                21 24
007 k                23 25
008 iz               23
009 izz              23
010 z                24 25
011 p                24 25
012 j                29
013 f                31
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #.               -> newV1.           15
002 @.               -> newV2.           16 17
003 !.               -> newV3.           29 29
004 _                -> newV4            21 23 24 25 29
