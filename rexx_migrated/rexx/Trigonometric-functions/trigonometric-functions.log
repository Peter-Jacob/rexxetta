-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:33
-------------------------------------------------------------------------
0001 /*REXX program demonstrates some  common trig  functions  (30 decimal digits are shown).*/
0002 showdigs= 25                                           /*show only 25 digits of number. */
0003 numeric digits showdigs + 10                           /*DIGITS default is  9,  but use */
0004 /*extra digs to prevent rounding.*/
0005 say 'Using'    showdigs    'decimal digits precision.' /*show # decimal digs being used.*/
0006 say
0007 do j=-180  to +180  by 15                         /*let's just do a  half─Monty.   */
0008 stuff = right(j, 4)         'degrees, rads='   show(  d2r(j) ) ,
0009 '   sin='   show( sinD(j) ) ,
0010 '   cos='   show( cosD(J) )
0011 /*don't let  TANGENT  go postal. */
0012 if abs(j)\==90  then stuff=stuff   '   tan='   show( tanD(j) )
0013 say stuff
0014 end   /*j*/
0015 say
0016 do k=-1  to +1  by 1/2                            /*keep the  Arc─functions happy. */
0017 say right(k, 4)             'radians, degs='   show(  r2d(k) )        ,
0018 '  Acos='   show( Acos(k) ) ,
0019 '  Asin='   show( Asin(k) ) ,
0020 '  Atan='   show( Atan(k) )
0021 end   /*k*/
0022 exit                                                   /*stick a fork in it, we're done.*/
0023 /*──────────────────────────────────────────────────────────────────────────────────────*/
0024 Asin:   procedure;  parse arg x 1 z 1 o 1 p;      a=abs(x);       aa=a*a
0025 if a>1  then call AsinErr x                  /*X argument is out of range.    */
0026 if a >= sqrt(2) * .5  then  return sign(x) * acos( sqrt(1 - aa),  '-ASIN')
0027 do j=2  by 2  until p=z;  p=z;   o= o * aa * (j-1) / j;   z= z +o / (j+1);   end
0028 return  z                                    /* [↑]  compute until no noise.  */
0029 /*──────────────────────────────────────────────────────────────────────────────────────*/
0030 Acos:  procedure; parse arg x; if x<-1 | x>1  then call AcosErr;  return pi()*.5 - Asin(x)
0031 AcosD: return r2d( Acos( arg(1)      ) )
0032 AsinD: return r2d( Asin( arg(1)      ) )
0033 cosD:  return cos( d2r(  arg(1)      ) )
0034 sinD:  return sin( d2r(  d2d( arg(1) ) ) )
0035 tan:   procedure; parse arg x;  _= cos(x);    if _=0  then call tanErr;  return sin(x) / _
0036 tanD:  return tan( d2r( arg(1) ) )
0037 d2d:   return arg(1)                  //  360      /*normalize degrees ──► a unit circle*/
0038 d2r:   return r2r( d2d( arg(1) )*pi()  /  180)     /*convert   degrees ──► radians.     */
0039 r2d:   return d2d( ( arg(1) * 180      /  pi() ) ) /*convert   radians ──► degrees.     */
0040 r2r:   return arg(1)                  // (pi() *2) /*normalize radians ──► a unit circle*/
0041 show:  return left( left('', arg(1) >= 0)format( arg(1), , showdigs) / 1, showdigs)
0042 tellErr: say; say '*** error! ***';   say;   say arg(1);   say;           exit 13
0043 tanErr:  call tellErr 'tan(' || x") causes division by zero, X=" || x
0044 AsinErr: call tellErr 'Asin(x),  X  must be in the range of  -1 ──► +1,  X=' || x
0045 AcosErr: call tellErr 'Acos(x),  X  must be in the range of  -1 ──► +1,  X=' || x
0046 /*──────────────────────────────────────────────────────────────────────────────────────*/
0047 Atan: procedure; parse arg x;    if abs(x)=1  then return pi() * .25 * sign(x)
0048 return Asin(x / sqrt(1 + x*x) )
0049 /*──────────────────────────────────────────────────────────────────────────────────────*/
0050 cos:  procedure; parse arg x; x= r2r(x);     if x=0   then return 1;        a= abs(x)
0051 numeric fuzz min(6, digits() - 3);     if a=pi  then return -1;       pih= pi * .5
0052 if a=pih | a=pih*3  then return 0;     pit= pi/3;    if a=pit  then return .5
0053 if a=pit + pit      then return -.5;                           return .sinCos(1, -1)
0054 /*──────────────────────────────────────────────────────────────────────────────────────*/
0055 sin:  procedure; arg x;x=r2r(x);if x=0 then return 0;numeric fuzz min(5,max(1,digits()-3))
0056 if x=pi*.5    then return 1;                if x==pi * 1.5  then return -1
0057 if abs(x)=pi  then return 0;                                     return .sinCos(x,1)
0058 /*──────────────────────────────────────────────────────────────────────────────────────*/
0059 .sinCos: parse arg z 1 _,i;        q= x*x
0060 do k=2  by 2  until p=z;  p= z;     _= - _ * q / (k * (k+i) );   z= z + _;   end
0061 return z
0062 /*──────────────────────────────────────────────────────────────────────────────────────*/
0063 sqrt: procedure; parse arg x;   if x=0  then return 0;  d=digits();  i=;    m.=9;   h= d+6
0064 numeric digits; numeric form;     if x<0  then  do;   x= -x;   i= 'i';   end
0065 parse value format(x, 2, 1, , 0)  'E0'   with   g  'E'  _ .;       g= g *.5'e'_ % 2
0066 do j=0  while h>9;        m.j=h;                   h= h % 2  +  1;    end  /*j*/
0067 do k=j+5  to 0  by -1;    numeric digits m.k;      g= (g+x/g) * .5;   end  /*k*/
0068 numeric digits d;            return (g/1)i               /*make complex if  X < 0.*/
0069 /*──────────────────────────────────────────────────────────────────────────────────────*/
0070 e:   e = 2.7182818284590452353602874713526624977572470936999595749669676277240766303535
0071 return e              /*Note:  the actual E subroutine returns  E's  accuracy that */
0072 /*matches the current NUMERIC DIGITS, up to 1 million digits.*/
0073 /*──────────────────────────────────────────────────────────────────────────────────────*/
0074 exp: procedure; parse arg x;  ix=x%1;    if abs(x-ix)>.5  then ix= ix + sign(x);  x=x - ix
0075 z=1; _=1; w=z;  do j=1;  _= _*x/j;  z= (z+_) / 1;    if z==w  then leave;  w=z;  end
0076 if z\==0  then z= e()**ix * z;                       return z
0077 /*──────────────────────────────────────────────────────────────────────────────────────*/
0078 pi:  pi= 3.1415926535897932384626433832795028841971693993751058209749445923078164062862
0079 return pi             /*Note:  the actual PI subroutine returns PI's accuracy that */
0080 /*matches the current NUMERIC DIGITS, up to 1 million digits.*/
0081 /*John Machin's formula is used for calculating more digits. */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                74 74
002 ix               74 74
003 z                75 75 76
004 w                75 75
005 j                75
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 _                -> newV1            35 59 60 65 75 75
