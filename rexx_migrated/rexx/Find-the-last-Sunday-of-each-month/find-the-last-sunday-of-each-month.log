-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:13
-------------------------------------------------------------------------
0001 /*REXX program displays dates of last Sundays of each month for any year*/
0002 parse arg yyyy
0003 do j=1 for  12
0004 _ = lastDOW('Sunday', j, yyyy)
0005 say right(_,4)'-'right(j,2,0)"-"left(word(_,2),2)
0006 end  /*j*/
0007 exit                                   /*stick a fork in it, we're done.*/
0008 /*┌────────────────────────────────────────────────────────────────────┐
0009 │ lastDOW:  procedure to return the date of the  last day-of-week of │
0010 │           any particular month  of any particular year.            │
0011 │                                                                    │
0012 │ The  day-of-week  must be specified (it can be in any case,        │
0013 │ (lower-/mixed-/upper-case)  as an English name of the spelled day  │
0014 │ of the week,   with a minimum length that causes no ambiguity.     │
0015 │ I.E.:   W  for Wednesday,   Sa  for Saturday,   Su  for Sunday ... │
0016 │                                                                    │
0017 │ The month can be specified as an integer   1 ──► 12                │
0018 │    1=January     2=February     3=March     ...     12=December    │
0019 │ or the English  name  of the month,  with a minimum length that    │
0020 │ causes no ambiguity.    I.E.:  Jun  for June,   D  for December.   │
0021 │ If omitted  [or an asterisk(*)],  the current month is used.       │
0022 │                                                                    │
0023 │ The year is specified as an integer or just the last two digits    │
0024 │ (two digit years are assumed to be in the current century,  and    │
0025 │ there is no windowing for a two-digit year).                       │
0026 │ If omitted  [or an asterisk(*)],  the current year is used.        │
0027 │ Years < 100   must be specified with  (at least 2)  leading zeroes.│
0028 │                                                                    │
0029 │ Method used: find the "day number" of the 1st of the next month,   │
0030 │ then subtract one  (this gives the "day number" of the last day of │
0031 │ the month,  bypassing the leapday mess).   The last day-of-week is │
0032 │ then obtained straightforwardly,   or  via subtraction.            │
0033 └────────────────────────────────────────────────────────────────────┘*/
0034 lastdow: procedure; arg dow .,mm .,yy .              /*DOW = day of week*/
0035 parse arg a.1,a.2,a.3                                /*orig args, errmsg*/
0036 if mm=='' | mm=='*' then mm=left(date('U'),2)        /*use default month*/
0037 if yy=='' | yy=='*' then yy=left(date('S'),4)        /*use default year */
0038 if length(yy)==2 then yy=left(date('S'),2)yy         /*append century.  */
0039 /*Note mandatory leading blank in strings below.*/
0040 $=" Monday TUesday Wednesday THursday Friday SAturday SUnday"
0041 !=" JAnuary February MARch APril MAY JUNe JULy AUgust September",
0042 " October November December"
0043 upper $ !                                            /*uppercase strings*/
0044 if dow==''                 then call .er "wasn't specified",1
0045 if arg()>3                 then call .er 'arguments specified',4
0046 
0047 do j=1 for 3                                       /*any plural args ?*/
0048 if words(arg(j))>1       then call .er 'is illegal:',j
0049 end
0050 
0051 dw=pos(' 'dow,$)                                     /*find  day-of-week*/
0052 if dw==0                   then call .er 'is invalid:',1
0053 if dw\==lastpos(' 'dow,$)  then call .er 'is ambigious:',1
0054 
0055 if datatype(mm,'month') then                         /*if MM is alpha...*/
0056 do
0057 m=pos(' 'mm,!)                                     /*maybe its good...*/
0058 if m==0                  then call .er 'is invalid:',1
0059 if m\==lastpos(' 'mm,!)  then call .er 'is ambigious:',2
0060 mm=wordpos(word(substr(!,m),1),!)-1                /*now, use true Mon*/
0061 end
0062 
0063 if \datatype(mm,'W')       then call .er "isn't an integer:",2
0064 if \datatype(yy,'W')       then call .er "isn't an integer:",3
0065 if mm<1 | mm>12            then call .er "isn't in range 1──►12:",2
0066 if yy=0                    then call .er "can't be 0 (zero):",3
0067 if yy<0                    then call .er "can't be negative:",3
0068 if yy>9999                 then call .er "can't be > 9999:",3
0069 
0070 tdow=wordpos(word(substr($,dw),1),$)-1               /*target DOW, 0──►6*/
0071 /*day# of last dom.*/
0072 _=date('B',right(yy+(mm=12),4)right(mm//12+1,2,0)"01",'S')-1
0073 ?=_//7                                               /*calc. DOW,  0──►6*/
0074 if ?\==tdow then _=_-?-7+tdow+7*(?>tdow)             /*not DOW?  Adjust.*/
0075 return date('weekday',_,"B") date(,_,'B')            /*return the answer*/
0076 
0077 .er: arg ,_;say; say '***error!*** (in LASTDOW)';say /*tell error,  and */
0078 say word('day-of-week month year excess',arg(2)) arg(1) a._
0079 say; exit 13                                       /*... then exit.   */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 a.               35 35 35
002 mm               36 60
003 yy               37 38
004 j                47
005 dw               51
006 m                57
007 tdow             70
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 _                -> newV1            4 72 74
002 $                -> newV2            40
003 !                -> newV3            41
004 ?                -> newV4            73
