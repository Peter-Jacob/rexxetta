-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:14
-------------------------------------------------------------------------
0001 /*REXX program finds/displays fortunate numbers  N,  where  N  is specified (default=8).*/
0002 numeric digits 12
0003 parse arg n cols .                               /*obtain optional argument from the CL.*/
0004 if    n=='' |    n==","  then    n=  8           /*Not specified?  Then use the default.*/
0005 if cols=='' | cols==","  then cols= 10           /* "      "         "   "   "     "    */
0006 call genP n**2                                   /*build array of semaphores for primes.*/
0007 pp.= 1
0008 do i=1  for n+1;   im= i - 1;    pp.i= pp.im * @.i   /*calculate primorial numbers*/
0009 end   /*i*/
0010 i=i-1;  call genp pp.i + 1000
0011 title= ' fortunate numbers'
0012 w= 10                                            /*maximum width of a number in any col.*/
0013 say ' index │'center(title, 1 + cols*(w+1)     )
0014 say '───────┼'center(""   , 1 + cols*(w+1), '─')
0015 found= 0;                           idx= 1       /*number of fortunate (so far) & index.*/
0016 !!.= 0;                             maxFN= 0     /*(stemmed)  array of fortunate numbers*/
0017 do j=1  until found==n;     pt= pp.j     /*search for fortunate numbers in range*/
0018 pt= pp.j                                 /*get the precalculated primorial prime*/
0019 do m=3  by 2;  t= pt + m    /*find  M  that satisfies requirement. */
0020 if !.t==''  then leave      /*Is !.t prime?  Then we found a good M*/
0021 end   /*m*/
0022 if !!.m  then iterate                    /*Fortunate # already found?  Then skip*/
0023 !!.m= 1;      found= found + 1           /*assign fortunate number;  bump count.*/
0024 maxFN= max(maxFN, t)                     /*obtain max fortunate # for displaying*/
0025 end   /*j*/
0026 $=;                                 finds= 0     /*$:  line of output;    FINDS:  count.*/
0027 do k=1  for maxFN;  if \!!.k  then iterate /*show the fortunate numbers we found. */
0028 finds= finds + 1                           /*bump the  count of numbers (for $).  */
0029 c= commas(k)                               /*maybe add commas to the number.      */
0030 $= $  right(c, max(w, length(c) ) )        /*add a nice prime ──► list, allow big#*/
0031 if found//cols\==0  then iterate           /*have we populated a line of output?  */
0032 say center(idx, 7)'│'  substr($, 2);   $=  /*display what we have so far  (cols). */
0033 idx= idx + cols                            /*bump the  index  count for the output*/
0034 end   /*k*/
0035 
0036 if $\==''  then say center(idx, 7)"│"  substr($, 2)  /*possible display residual output.*/
0037 say '───────┴'center(""   , 1 + cols*(w+1), '─')     /*display the foot separator.      */
0038 say
0039 say 'Found '       commas(found)      title
0040 exit 0                                           /*stick a fork in it,  we're all done. */
0041 /*──────────────────────────────────────────────────────────────────────────────────────*/
0042 commas: parse arg ?;  do jc=length(?)-3  to 1  by -3; ?=insert(',', ?, jc); end;  return ?
0043 /*──────────────────────────────────────────────────────────────────────────────────────*/
0044 genP:        @.1=2; @.2=3; @.3=5; @.4=7;  @.5=11 /*define some low primes.              */
0045 !.=0;  !.2=;  !.3=;  !.5=;  !.7=;   !.11=  /*   "     "   "    "     semaphores.  */
0046 #= 5;  sq.#= @.#**2   /*squares of low primes.*/
0047 do j=@.#+2  by 2  to arg(1)              /*find odd primes from here on.        */
0048 parse var j '' -1 _;     if _==5  then iterate       /*J ÷ by 5 ?               */
0049 if j//3==0  then iterate;  if j//7==0  then iterate  /*" "  " 3?;    J ÷ by 7 ? */
0050 do k=5  while sq.k<=j             /* [↓]  divide by the known odd primes.*/
0051 if j // @.k == 0  then iterate j  /*Is  J ÷ X?  Then not prime.     ___  */
0052 end   /*k*/                       /* [↑]  only process numbers  ≤  √ J   */
0053 #= #+1;    @.#= j;    sq.#= j*j;  !.j=   /*bump # of Ps; assign next P;  P²; P# */
0054 end          /*j*/;               return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j                48
002 k                50
003 sq.              53
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 !!.              -> newV1.           16 23
002 @.               -> newV2.           44 44 44 44 53
003 !.               -> newV3.           45 45 45 45 45 45 53
004 $                -> newV4            26 30 32
005 ?                -> newV5            42 42
006 #                -> newV6            46 53
007 _                -> newV7            48
