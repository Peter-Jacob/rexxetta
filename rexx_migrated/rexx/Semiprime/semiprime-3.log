-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:28
-------------------------------------------------------------------------
0001 /*REXX program determines if any integer  (or a range of integers)  is/are  semiprime.  */
0002 parse arg bot top .                              /*obtain optional arguments from the CL*/
0003 if bot=='' | bot==","  then bot=random()         /*None given?   User wants us to guess.*/
0004 if top=='' | top==","  then top=bot              /*maybe define a range of numbers.     */
0005 tell= bot=>0  &  top=>0                          /*should results be shown to the term? */
0006 w=max(length(bot), length(top))                  /*obtain the maximum width of numbers. */
0007 !.=;  !.2=1; !.3=1; !.5=1; !.7=1; !.11=1; !.13=1; !.17=1; !.19=1; !.23=1; !.29=1;  !.31=1
0008 numeric digits max(9, w)                         /*ensure there're enough decimal digits*/
0009 #=0                                              /*initialize number of semiprimes found*/
0010 do n=abs(bot)  to abs(top)          /*show results for a range of numbers. */
0011 ?=isSemiPrime(n);      #=#+?        /*Is N a semiprime?; Maybe bump counter*/
0012 if tell  then say right(n,w)  right(word("isn't" 'is', ?+1), 6)  'semiprime.'
0013 end   /*n*/
0014 say
0015 if bot\==top  then say 'found '   #   " semiprimes."
0016 exit                                             /*stick a fork in it,  we're all done. */
0017 /*──────────────────────────────────────────────────────────────────────────────────────*/
0018 isPrime: procedure expose !.;  parse arg x;     if x<2  then return 0  /*number too low?*/
0019 if !.x==1                                      then return 1  /*a known prime. */
0020 if x// 2==0  then return 0;    if x//3==0      then return 0  /*÷ by  2;÷by  3?*/
0021 parse var x '' -1 _;           if _==5         then return 0  /*last digit a 5?*/
0022 if x// 7==0  then return 0;    if x//11==0     then return 0  /*÷ by  7;÷by 11?*/
0023 if x//13==0  then return 0;    if x//17==0     then return 0  /*÷ by 13;÷by 17?*/
0024 if x//19==0  then return 0;    if x//23==0     then return 0  /*÷ by 19;÷by 23?*/
0025 do j=29  by 6  until j*j>x;  if x//j==0      then return 0  /*not a prime.   */
0026 if x//(j+2)==0  then return 0  /* "  "   "      */
0027 end   /*j*/
0028 !.x=1;                return 1          /*indicate that  X  is a prime number. */
0029 /*──────────────────────────────────────────────────────────────────────────────────────*/
0030 isSemiPrime: procedure expose !.;  parse arg x;          if x<4  then return 0
0031 
0032 do i=2  for 2;  if x//i==0  then if isPrime(x%i)  then return 1
0033 else return 0
0034 end   /*i*/
0035 /*    ___  */
0036 do   j=5  by 6  until j*j>x                                   /* > √ x  ?*/
0037 do k=j  by 2  for 2;  if x//k==0  then  if isPrime(x%k)  then return 1
0038 else return 0
0039 end   /*k*/                     /* [↑]  see if 2nd factor is prime or ¬*/
0040 end     /*j*/                     /* [↑]  J is never a multiple of three.*/
0041 return 0
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                30
002 i                32
003 j                36
004 k                37
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 !.               -> newV1.           7 7 7 7 7 7 7 7 7 7 7 7 28
002 #                -> newV2            9 11
003 ?                -> newV3            11
004 _                -> newV4            21
