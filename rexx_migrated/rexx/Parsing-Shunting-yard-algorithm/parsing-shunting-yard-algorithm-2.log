-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:23
-------------------------------------------------------------------------
0001 /*REXX pgm converts infix arith. expressions to Reverse Polish notation (shunting─yard).*/
0002 parse arg x                                      /*obtain optional argument from the CL.*/
0003 if x=''  then x= '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3' /*Not specified?  Then use the default.*/
0004 g=0                                              /* G   is a counter of   (  and  )     */
0005 do p=1 for words(x);       _=word(x,p)    /*catches unbalanced   ( )  and  ) (   */
0006 if _=='('  then g=g+1
0007 else if _==')'  then do;    g=g-1;    if g<0  then g=-1e8;     end
0008 end   /*p*/
0009 ox=x
0010 x='(' space(x) ") "                              /*force stacking for the expression.   */
0011 #=words(x)                                       /*get number of tokens in expression.  */
0012 good= (g==0)                                     /*indicate expression is  good  or bad.*/
0013 do i=1  for #;   @.i=word(x, i)    /*assign the input tokens to an array. */
0014 end   /*i*/
0015 tell=1                                           /*set to 0 if working steps not wanted.*/
0016 L=max( 20, length(x) )                           /*use twenty for the minimum show width*/
0017 if good  then say  'token'  center("input" , L, '─')     center("stack" , L%2, '─'),
0018 center("output", L, '─')     center("action", L,   '─')
0019 op= ")(-+/*^";   Rop=substr(op,3);   p.=;  n=length(op);  RPN=  /*some handy-dandy vars.*/
0020 s.=
0021 do i=1  for n;  _=substr(op,i,1);   s._=(i+1)%2;   p._=s._+(i==n);  end  /*i*/
0022 $=                                               /* [↑]  assign the operator priorities.*/
0023 do k=1  for #*good;         ?=@.k             /*process each token from the  @. list.*/
0024 select                                      /*@.k is:   (   operator   )   operand.*/
0025 when ?=='('   then do; $="(" $;    call show 'moving'   ?   "──► stack";    end
0026 when isOp(?)  then do;              !=word($, 1)             /*get token from stack*/
0027 do  while ! \==')'  &  s.!>=p.?
0028 RPN=RPN !                          /*add token  to   RPN.*/
0029 $=subword($, 2)                    /*del token from stack*/
0030 call show 'unstacking:'  !
0031 !=word($, 1)                       /*get token from stack*/
0032 end   /*while*/
0033 $=? $                                     /*add token  to  stack*/
0034 call show 'moving'   ?   "──► stack"
0035 end
0036 when ?==')'   then do;             !=word($, 1)              /*get token from stack*/
0037 do  while  !\=='(';     RPN=RPN !    /*add token   to  RPN.*/
0038 $=subword($, 2)                      /*del token from stack*/
0039 !=   word($, 1)                      /*get token from stack*/
0040 call show 'moving stack' ! "──► RPN"
0041 end   /*while*/
0042 $=subword($, 2)                           /*del token from stack*/
0043 call show 'deleting ( from the stack'
0044 end
0045 otherwise  RPN=RPN ?                                         /*add operand to  RPN.*/
0046 call show 'moving'    ?    "──► RPN"
0047 end   /*select*/
0048 end     /*k*/
0049 say
0050 RPN=space(RPN $);  if \good  then RPN= '─────── error in expression ───────'   /*error? */
0051 say ' input:'  ox;     say " RPN──►"    RPN      /*display the input  and  the RPN.     */
0052 parse source upper . y .                         /*invoked via the  C.L.  or  REXX pgm? */
0053 if y=='COMMAND'  then  exit                      /*stick a fork in it,  we're all done. */
0054 else  return RPN                /*return RPN to invoker  (the RESULT). */
0055 /*──────────────────────────────────────────────────────────────────────────────────────────*/
0056 isOp: return pos(arg(1), Rop) \== 0              /*is the first argument a "real" operator? */
0057 show: if tell then say center(?,5) left(subword(x,k),L) left($,L%2) left(RPN,L) arg(1); return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                2 3 10
002 g                4 6 7 7
003 p                5
004 ox               9
005 good             12
006 i                13
007 tell             15
008 L                16
009 op               19
010 Rop              19
011 p.               19
012 n                19
013 RPN              19
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           13
002 _                -> newV2            5
003 #                -> newV3            11
