-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:34
-------------------------------------------------------------------------
0001 /*REXX pgm finds N untouchable numbers (numbers that can't be equal to any aliquot sum).*/
0002 parse arg n cols tens over .                     /*obtain optional arguments from the CL*/
0003 if    n='' |    n==","            then    n=2000 /*Not specified?  Then use the default.*/
0004 if cols='' | cols=="," | cols==0  then cols=  10 /* "       "        "   "   "      "   */
0005 if tens='' | tens==","            then tens=   0 /* "       "        "   "   "      "   */
0006 if over='' | over==","            then over=  20 /* "       "        "   "   "      "   */
0007 tell= n>0;                             n= abs(n) /*N>0?  Then display the untouchable #s*/
0008 call genP  n * over                              /*call routine to generate some primes.*/
0009 u.= 0                                            /*define all possible aliquot sums ≡ 0.*/
0010 do p=1  for #;   _= @.p + 1;   u._= 1  /*any prime+1  is  not  an untouchable.*/
0011 _= @.p + 3;   u._= 1  /* "  prime+3   "   "    "      "      */
0012 end   /*p*/                            /* [↑]  this will also rule out  5.    */
0013 u.5= 0                                           /*special case as prime 2 + 3 sum to 5.*/
0014 do j=2  for lim;  if !.j  then iterate /*Is  J  a prime?   Yes, then skip it. */
0015 y= sigmaP()                            /*compute:  aliquot sum (sigma P) of J.*/
0016 if y<=n  then u.y= 1                   /*mark  Y  as a touchable if in range. */
0017 end  /*j*/
0018 call show                                        /*maybe show untouchable #s and a count*/
0019 if tens>0  then call powers                      /*Any "tens" specified?  Calculate 'em.*/
0020 exit cnt                                         /*stick a fork in it,  we're all done. */
0021 /*──────────────────────────────────────────────────────────────────────────────────────*/
0022 commas: parse arg ?;  do jc=length(?)-3  to 1  by -3; ?=insert(',', ?, jc); end;  return ?
0023 genSq:    do _=1  until _*_>lim;  q._= _*_;  end;  q._= _*_;  _= _+1;  q._= _*_;  return
0024 grid:   $= $ right( commas(t), w);  if cnt//cols==0  then do;  say $;  $=;  end;  return
0025 powers:   do pr=1  for tens;   call 'UNTOUCHA' -(10**pr);   end  /*recurse*/;     return
0026 /*──────────────────────────────────────────────────────────────────────────────────────*/
0027 genP: #= 9;  @.1=2; @.2=3; @.3=5; @.4=7; @.5=11; @.6=13; @.7=17; @.8=19; @.9=23 /*a list*/
0028 !.=0;  !.2=1; !.3=1; !.5=1; !.7=1; !.11=1; !.13=1; !.17=1; !.19=1  !.23=1 /*primes*/
0029 parse arg lim;   call genSq                /*define the (high) limit for searching*/
0030 qq.10= 100  /*define square of the 10th prime index*/
0031 do j=@.#+6  by 2  to lim                 /*find odd primes from here on forward.*/
0032 parse var  j    ''  -1  _;   if     _==5  then iterate;  if j// 3==0  then iterate
0033 if j// 7==0  then iterate;   if j//11==0  then iterate;  if j//13==0  then iterate
0034 if j//17==0  then iterate;   if j//19==0  then iterate;  if j//23==0  then iterate
0035 /*start dividing by the tenth prime: 29*/
0036 do k=10  while qq.k <= j       /* [↓]  divide  J  by known odd primes.*/
0037 if j//@.k==0  then iterate j   /*J ÷ by a prime?  Then ¬prime.   ___  */
0038 end   /*k*/                    /* [↑]  only process numbers  ≤  √ J   */
0039 #= #+1;                     @.#= j       /*bump prime count; assign a new prime.*/
0040 !.j= 1;                    qq.#= j*j     /*mark prime;  compute square of prime.*/
0041 end             /*j*/;        return     /*#:  is the number of primes generated*/
0042 /*──────────────────────────────────────────────────────────────────────────────────────*/
0043 show: w=7; $= right(2, w+1)  right(5, w)         /*start the list of an even prime and 5*/
0044 cnt= 2              /*count of the only two primes in list.*/
0045 do t=6  by 2  to n;  if u.t then iterate /*Is  T  touchable?    Then skip it.   */
0046 cnt= cnt + 1;     if tell then call grid /*bump count;  maybe show a grid line. */
0047 end   /*t*/
0048 if tell & $\==''  then say $ /*display a residual grid line, if any.*/
0049 if tell           then say   /*show a spacing blank line for output.*/
0050 if n>0  then say right( commas(cnt), 20)  ,             /*indent the output a bit.*/
0051 ' untouchable numbers were found  ≤ '    commas(n);            return
0052 /*──────────────────────────────────────────────────────────────────────────────────────*/
0053 sigmaP: s= 1                                     /*set initial sigma sum (S) to 1.   ___*/
0054 if j//2  then do m=3  by 2  while q.m<j  /*divide by odd integers up to the √ J */
0055 if j//m==0  then s=s+m+j%m /*add the two divisors to the sum.     */
0056 end   /*m*/                /* [↑]  process an odd integer.     ___*/
0057 else do m=2        while q.m<j  /*divide by all integers up to the √ J */
0058 if j//m==0  then s=s+m+j%m /*add the two divisors to the sum.     */
0059 end   /*m*/                /* [↑]  process an even integer.    ___*/
0060 if q.m==j  then return s + m             /*Was  J  a square?   If so, add   √ J */
0061 return s                 /*                    No, just return. */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j                32
002 k                36
003 qq.              40
004 cnt              44 46
005 t                45
006 m                54
007 s                55 58
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           27 27 27 27 27 27 27 27 27 39
002 !.               -> newV2.           28 28 28 28 28 28 28 28 28 40
003 _                -> newV3            10 11 23 32
004 ?                -> newV4            22 22
005 $                -> newV5            24 43
006 #                -> newV6            39
