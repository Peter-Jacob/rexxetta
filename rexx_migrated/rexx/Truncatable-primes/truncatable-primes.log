-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:33
-------------------------------------------------------------------------
0001 /*REXX program finds largest  left─ and right─truncatable  primes ≤ 1m  (or argument 1).*/
0002 parse arg hi .;      if hi==''  then hi= 1000000 /*Not specified? Then use default of 1m*/
0003 call genP                                        /*generate some primes,  about  hi ÷ 2 */
0004 /* [↓]  find largest left truncatable P*/
0005 do L=#  by -1  for #                           /*search from top end;  get the length.*/
0006 do k=1  for length(@.L); _= right(@.L, k) /*validate all left truncatable primes.*/
0007 if \!._  then iterate L                   /*Truncated number not prime?  Skip it.*/
0008 end   /*k*/
0009 leave                                          /*egress, found left truncatable prime.*/
0010 end        /*L*/
0011 /* [↓]  find largest right truncated P.*/
0012 do R=#  by -1  for #                           /*search from top end;  get the length.*/
0013 do k=1  for length(@.R);  _= left(@.R, k) /*validate all right truncatable primes*/
0014 if \!._  then iterate R                   /*Truncated number not prime?  Skip it.*/
0015 end   /*k*/
0016 leave                                          /*egress, found right truncatable prime*/
0017 end        /*R*/
0018 
0019 say 'The largest  left─truncatable prime ≤'        hi        " is "       right(@.L, w)
0020 say 'The largest right─truncatable prime ≤'        hi        " is "       right(@.R, w)
0021 exit                                             /*stick a fork in it,  we're all done. */
0022 /*──────────────────────────────────────────────────────────────────────────────────────*/
0023 genP: !.= 0;                     w= length(hi)   /*placeholders for primes;  max width. */
0024 @.1=2;  @.2=3;  @.3=5;  @.4=7;  @.5=11     /*define some low primes.              */
0025 !.2=1;  !.3=1;  !.5=1;  !.7=1;  !.11=1     /*   "     "   "    "     flags.       */
0026 #=5;     s.#= @.# **2    /*number of primes so far;     prime². */
0027 /* [↓]  generate more  primes  ≤  high.*/
0028 do j=@.#+2  by 2  for max(0, hi%2-@.#%2-1)      /*find odd primes from here on. */
0029 parse var j '' -1 _; if     _==5  then iterate  /*J divisible by 5?  (right dig)*/
0030 if j// 3==0  then iterate  /*"     "      " 3?             */
0031 if j// 7==0  then iterate  /*"     "      " 7?             */
0032 /* [↑]  the above five lines saves time*/
0033 do k=5  while s.k<=j              /* [↓]  divide by the known odd primes.*/
0034 if j // @.k == 0  then iterate j  /*Is  J ÷ X?  Then not prime.     ___  */
0035 end   /*k*/                       /* [↑]  only process numbers  ≤  √ J   */
0036 #= #+1;    @.#= j;    s.#= j*j;   !.j= 1 /*bump # of Ps; assign next P;  P²; P# */
0037 end          /*j*/
0038 return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j                29
002 k                33
003 s.               36
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           24 24 24 24 24 36
002 !.               -> newV2.           25 25 25 25 25 36
003 _                -> newV3            6 13 29
004 #                -> newV4            26 36
