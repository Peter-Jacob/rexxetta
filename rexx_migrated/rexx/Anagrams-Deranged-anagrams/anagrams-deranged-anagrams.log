-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:05
-------------------------------------------------------------------------
0001 /*REXX program finds the  largest  deranged word  (within an identified dictionary).    */
0002 iFID= 'unixdict.txt';     words=0                /*input file ID; number of words so far*/
0003 wL.=0                                            /*number of words of length  L.  so far*/
0004 do while lines(iFID)\==0                   /*read each word in the file  (word=X).*/
0005 x= strip( linein( iFID) )                  /*pick off a word from the input line. */
0006 L= length(x);       if L<3 then iterate    /*onesies & twosies can't possible win.*/
0007 words= words + 1                           /*bump the count of  (usable)  words.  */
0008 #.words= L                                 /*the length of the word found.        */
0009 @.words= x                                 /*save the word in an array.           */
0010 wL.L= wL.L+1;       _= wL.L                /*bump counter of words of length  L.  */
0011 @@.L._= x                                  /*array   of words of length  L.       */
0012 do i=1  while x\=='';  parse var x !.i +1 x;  end  /*i*/
0013 call eSort L;       z=;     do j=1  for L;         z= z || !.j;           end  /*j*/
0014 @@s.L._= z                                 /*store the sorted word (letters).     */
0015 @s.words= @@s.L._                          /*store the sorted length  L  version. */
0016 end   /*while*/
0017 a.=                                              /*all the  anagrams  for word  X.      */
0018 say copies('─', 30)   words   'usable words in the dictionary file: '     iFID
0019 m= 0;              n.= 0                         /*# anagrams for word  X;   m=max L.   */
0020 do j=1  for words                         /*process usable words that were found.*/
0021 Lx= #.j;   if Lx<m  then iterate          /*get length of word; skip if too short*/
0022 x= @.j;    xs= @s.j                       /*get some vital statistics for  X     */
0023 do k=1  for wL.Lx                     /*process all the words of length  L.  */
0024 if xs\== @@s.Lx.k  then iterate       /*is this not a true anagram of  X ?   */
0025 if x  ==  @@.Lx.k  then iterate       /*skip of processing anagram on itself.*/
0026 do c=1  for Lx                   /*ensure no character position shared. */
0027 if substr(@.j, c, 1) == substr(@@.Lx.k, c, 1)  then iterate k
0028 end   /*c*/                      /* [+]  now compare the rest of chars. */
0029 n.j= n.j + 1;     a.j= a.j   @@.Lx.k  /*bump counter;  then add ──► anagrams.*/
0030 m= max(m, Lx)                         /*M  is the maximum length of a word.  */
0031 end        /*k*/
0032 end            /*j*/
0033 
0034 do k=1  for words                             /*now, search all words for the maximum*/
0035 if #.k==m   then if n.k\==0   then if word(a.k, 1) > @.k  then say  @.k  a.k
0036 end   /*k*/                                   /* [↑]  REXX has no short-circuits.    */
0037 exit                                             /*stick a fork in it,  we're all done. */
0038 /*──────────────────────────────────────────────────────────────────────────────────────*/
0039 eSort: procedure expose !.;  parse arg ho 1 h    /*obtain number of elements; also copy.*/
0040 do while h>1;      h=h % 2;                    do i=1  for ho-h;   j= i;   k= h+i
0041 do while !.k<!.j;  t=!.j;  !.j=!.k;  !.k=t;   if h>=j  then leave;  j=j-h;  k=k-h
0042 end   /*while !.k···*/;         end  /*i*/;         end  /*while h>1*/;    return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 ho               39
002 h                39 40
003 i                40
004 j                40 41
005 k                40 41
006 t                41
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @@s.             -> newV1.           14
002 @@.              -> newV2.           11
003 @s.              -> newV3.           15
004 #.               -> newV4.           8
005 @.               -> newV5.           9
006 !.               -> newV6.           12 41 41
007 _                -> newV7            10
