-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:28
-------------------------------------------------------------------------
0001 /*REXX program  demonstrates  a way to  represent any set of real numbers  and  usage.  */
0002 call quertySet 1, 3,  '[1,2)'
0003 call quertySet ,   ,  '[0,2)   union   (1,3)'
0004 call quertySet ,   ,  '[0,1)   union   (2,3]'
0005 call quertySet ,   ,  '[0,2]   inter   (1,3)'
0006 call quertySet ,   ,  '(1,2)     ∩     (2,3]'
0007 call quertySet ,   ,  '[0,2)     \     (1,3)'
0008 say;                                      say center(' start of required tasks ', 40, "═")
0009 call quertySet ,   ,  '(0,1]   union   [0,2)'
0010 call quertySet ,   ,  '[0,2)     ∩     (1,3)'
0011 call quertySet ,   ,  '[0,3]     -     (0,1)'
0012 call quertySet ,   ,  '[0,3]     -     [0,1]'
0013 exit                                             /*stick a fork in it,  we're all done. */
0014 /*──────────────────────────────────────────────────────────────────────────────────────*/
0015 badSet:    say;    say  '***error*** bad format of SET_def:  ('arg(1)")";         exit
0016 /*──────────────────────────────────────────────────────────────────────────────────────*/
0017 emptySet:  parse arg _;               nam= valSet(_, 00);                   return @.3>@.4
0018 /*──────────────────────────────────────────────────────────────────────────────────────*/
0019 isInSet:   parse arg #,x;             call valSet x
0020 if \datatype(#, 'N')       then call set_bad "number isn't not numeric:" #
0021 if (@.1=='(' &  #<=@.2) |,
0022 (@.1=='[' &  #< @.2) |,
0023 (@.4==')' &  #>=@.3) |,
0024 (@.4==']' &  #> @.3)    then return 0
0025 return 1
0026 /*──────────────────────────────────────────────────────────────────────────────────────*/
0027 quertySet: parse arg lv,hv,s1 oop s2 .;  op=oop;   upper op;      cop=
0028 if lv==''  then lv=0;      if hv==""  then hv= 2;      if op==''  then cop=  0
0029 if wordpos(op, '| or UNION')                 \==0                 then cop= "|"
0030 if wordpos(op, '& ∩ AND INTER INTERSECTION') \==0                 then cop= "&"
0031 if wordpos(op, '\ - DIF DIFF DIFFERENCE')    \==0                 then cop= "\"
0032 say
0033 do i=lv  to hv;  b = isInSet(i, s1)
0034 if cop\==0  then do
0035 b2= isInSet(i, s2)
0036 if cop=='&'  then b= b & b2
0037 if cop=='|'  then b= b | b2
0038 if cop=='\'  then b= b & \b2
0039 end
0040 express = s1 center(oop, max(5, length(oop) ) )    s2
0041 say right(i, 5)    ' is in set'     express": "   word('no yes', b+1)
0042 end   /*i*/
0043 return
0044 /*──────────────────────────────────────────────────────────────────────────────────────*/
0045 valSet:    parse arg q;              q=space(q, 0);    L= length(q);       @.0= ','
0046 infinity = copies(9, digits() - 1)'e'copies(9, digits() - 1)0
0047 if L<2                    then call set_bad  'invalid expression'
0048 @.4= right(q, 1)
0049 parse var q  @.1  2  @.2  ','  @.3  (@.4)
0050 if @.1\=='(' & @.1\=="["  then call set_bad  'left boundry'
0051 if @.4\==')' & @.4\=="]"  then call set_bad  'right boundry'
0052 do j=2  to 3;    u=@.j;               upper u
0053 if right(@.j, 1)=='∞' | u="INFINITY"  then @.j= '-'infinity
0054 if \datatype(@.j, 'N')  then call set_bad  "value not numeric:"    @.j
0055 end  /*j*/
0056 if @.2>@.3  then parse var   L  .  @.0  @.2  @.3
0057 return space(@.1 @.2 @.0 @.3 @.4,  0)
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 L                56
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 (@.              -> newV1.           22 23 24 49
002 @.               -> newV2.           45 48 49 49 49 53 56 56 56
003 _                -> newV3            17
004 #                -> newV4            19
