-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:07
-------------------------------------------------------------------------
0001 /*REXX program animates and displays Brownian motion of dust in a field (with one seed).*/
0002 mote     = '·'                                   /*character for a loose mote (of dust).*/
0003 hole     = ' '                                   /*    "      "  an empty spot in field.*/
0004 seedPos  = 0                                     /*if =0,  then use middle of the field.*/
0005 /* " -1,    "   "   a random placement.*/
0006 /*otherwise, place the seed at seedPos.*/
0007 /*use RANDSEED for RANDOM repeatability*/
0008 parse arg sd sw motes tree randSeed .            /*obtain optional arguments from the CL*/
0009 if    sd=='' | sd==","     then sd= 0            /*Not specified?  Then use the default.*/
0010 if    sw=='' | sw==","     then sw= 0            /* "      "         "   "   "      "   */
0011 if motes=='' | motes==","  then  motes= '18%'    /*The  %  dust motes in the field,     */
0012 /* [↑]  either a #  ─or─  a # with a %.*/
0013 if  tree=='' | tree==mote  then tree= "*"        /*the character used to show the tree. */
0014 if length(tree)==2         then tree=x2c(tree)   /*tree character was specified in hex. */
0015 if datatype(randSeed,'W')  then call random ,,randSeed    /*if an integer, use the seed.*/
0016 /* [↑]  set the first  random  number. */
0017 if sd==0 | sw==0 then _= scrsize()               /*Note: not all REXXes have SCRSIZE BIF*/
0018 if sd==0         then sd= word(_, 1)  -  2       /*adjust usable  depth  for the border.*/
0019 if sw==0         then sw= word(_, 2)  -  1       /*   "      "    width   "   "     "   */
0020 seedAt= seedPos             /*assume a seed position (initial pos).*/
0021 if seedPos== 0  then seedAt= (sw % 2)   (sd % 2) /*if it's a zero,  start in the middle.*/
0022 if seedPos==-1  then seedAt= random(1, sw)       random(1,sd) /*if negative, use random.*/
0023 parse  var  seedAt    xs  ys  .                  /*obtain the  X and Y  seed coördinates*/
0024 /* [↓]  if right─most ≡ '%', then use %*/
0025 if right(motes, 1)=='%'  then motes= sd * sw * strip(motes, , '%')    %  100
0026 @.= hole                                         /*create the Brownian field, all empty.*/
0027 do j=1  for motes                       /*sprinkle a  # of dust motes randomly.*/
0028 rx= random(1, sw);   ry= random(1, sd);     @.rx.ry= mote
0029 end   /*j*/                             /* [↑]  place a mote at random in field*/
0030 /*plant a seed from which the tree will grow from*/
0031 @.xs.ys= tree                          /*dust motes that affix themselves to the tree.  */
0032 call show;  loX= 1;  hiX= sw                     /*show field before we mess it up again*/
0033 loY= 1;  hiY= sd                     /*used to optimize the  mote searching.*/
0034 /*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ soooo, this is Brownian motion.*/
0035 do Brownian=1  until \motion;  call show       /*show Brownion motion until no motion.*/
0036 minx= loX;  maxX= hiX;    loX= sw;  hiX= 1     /*as the tree grows, the search for the*/
0037 minY= loY;  maxY= hiY;    loY= sd;  hiy= 1     /*dust motes gets faster due to croping*/
0038 call BM                                        /*invoke the Brownian movement routine.*/
0039 if loX>1 & hiX<sw & loY>1 & hiY<sd  then iterate /*Need cropping? No, then keep moving*/
0040 call crop                                      /*delete motes (moved off petri field).*/
0041 end   /*Brownian*/      /*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒*/
0042 exit 0                                           /*stick a fork in it,  we're all done. */
0043 /*──────────────────────────────────────────────────────────────────────────────────────*/
0044 crop:       do yc=-1  to sd+1  by sd+2;    do xc=-1  to sw+1;  @.xc.yc= hole;  end  /*xc*/
0045 end     /*yc*/
0046 do xc=-1  to sw+1  by sw+2;         do yc=-1  to sd+1;  @.xc.yc= hole;  end  /*yc*/
0047 end      /*xc*/;                                     return
0048 /*──────────────────────────────────────────────────────────────────────────────────────*/
0049 show: 'CLS';    motion= 0;   do     ys=sd  for sd  by -1;   aRow=
0050 do xs=1   for sw;          aRow= aRow  ||  @.xs.ys
0051 end   /*xs*/
0052 say aRow
0053 end       /*ys*/;              return
0054 /*──────────────────────────────────────────────────────────────────────────────────────*/
0055 BM: do x  =minX  to maxX;    xm= x - 1;       xp= x + 1     /*two handy─dandy values.   */
0056 do y=minY  to maxY;    if @.x.y\==mote  then iterate  /*Not a mote:  keep looking.*/
0057 if x<loX  then loX=x;  if x>hiX  then hiX= x          /*faster than hiX=max(X,hiX)*/
0058 if y<loY  then loY=y;  if y>hiY  then hiY= y          /*   "     "  hiY=max(y,hiY)*/
0059 if @.xm.y ==tree  then do; @.x.y= tree; iterate; end  /*there a neighbor of tree? */
0060 if @.xp.y ==tree  then do; @.x.y= tree; iterate; end  /*  "   "     "     "   "   */
0061 ym= y - 1
0062 if @.x.ym ==tree  then do; @.x.y= tree; iterate; end  /*  "   "     "     "   "   */
0063 if @.xm.ym==tree  then do; @.x.y= tree; iterate; end  /*  "   "     "     "   "   */
0064 if @.xp.ym==tree  then do; @.x.y= tree; iterate; end  /*  "   "     "     "   "   */
0065 yp = y + 1
0066 if @.x.yp ==tree  then do; @.x.y= tree; iterate; end  /*  "   "     "     "   "   */
0067 if @.xm.yp==tree  then do; @.x.y= tree; iterate; end  /*  "   "     "     "   "   */
0068 if @.xp.yp==tree  then do; @.x.y= tree; iterate; end  /*  "   "     "     "   "   */
0069 motion= 1                                  /* [↓]  Brownian motion is coming.     */
0070 xb= x + random(1, 3)  - 2                  /*     apply Brownian motion for  X.   */
0071 yb= y + random(1, 3)  - 2                  /*       "       "       "    "   Y.   */
0072 if @.xb.yb\==hole  then iterate            /*can the mote actually move to there ?*/
0073 @.x.y= hole                                /*"empty out"  the old mote position.  */
0074 @.xb.yb= mote                              /*move the mote  (or possibly not).    */
0075 if xb<loX  then loX= max(1, xb);   if xb>hiX  then hiX= min(sw, xb)
0076 if yb<loY  then loY= max(1, yb);   if yb>hiY  then hiY= min(sd, yb)
0077 end   /*y*/                                /* [↑]  limit mote's movement to field.*/
0078 end     /*x*/;            return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 seedAt           23
002 xs               23 50
003 ys               23 49
004 motes            25
005 j                27
006 rx               28
007 ry               28
008 loX              32 36 57 75
009 hiX              32 36 57 75
010 loY              33 37 58 76
011 hiY              33 58 76
012 Brownian         35
013 minx             36
014 maxX             36
015 minY             37
016 maxY             37
017 hiy              37
018 xc               44 46
019 yc               46
020 motion           49 69
021 aRow             49 50
022 xm               55
023 xp               55
024 y                56
025 ym               61
026 yp               65
027 xb               70
028 yb               71
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           26 28 31 44 46 59 60 62 63 64 66 67 68 73 74
002 _                -> newV2            17
