-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:14
-------------------------------------------------------------------------
0001 /*REXX program runs  FRACTRAN  for a given set of  fractions  and  from a specified  N. */
0002 numeric digits 2000                              /*be able to handle larger numbers.    */
0003 parse arg N terms fracs                          /*obtain optional arguments from the CL*/
0004 if     N=='' |     N==","  then     N=   2       /*Not specified?  Then use the default.*/
0005 if terms=='' | terms==","  then terms= 100       /* "      "         "   "   "      "   */
0006 if fracs=''                then fracs= "17/91, 78/85, 19/51, 23/38, 29/33, 77/29, 95/23,",
0007 '77/19, 1/17, 11/13, 13/11, 15/14, 15/2, 55/1'
0008 /* [↑]  The default for the fractions. */
0009 f= space(fracs, 0)                               /*remove all blanks from the FRACS list*/
0010 do #=1  while f\=='';    parse var  f   n.#   "/"   d.#   ','   f
0011 end   /*#*/                  /* [↑]  parse all the fractions in list*/
0012 #= # - 1                                         /*the number of fractions just found.  */
0013 say #   'fractions:'   fracs                     /*display number and actual fractions. */
0014 say 'N  is starting at '   N                     /*display the starting number  N.      */
0015 say terms   ' terms are being shown:'            /*display a kind of header/title.      */
0016 
0017 do    j=1  for  terms                        /*perform the DO loop for each   term. */
0018 do k=1  for  #                            /*   "     "   "   "   "    "  fraction*/
0019 if N // d.k \== 0  then iterate           /*Not an integer?  Then ignore it.     */
0020 cN= commas(N);     L= length(cN)          /*maybe insert commas into N;  get len.*/
0021 say right('term' commas(j), 44) "──► " right(cN, max(15, L))  /*show Nth term & N*/
0022 N= N  %  d.k  *  n.k                      /*calculate next term (use %≡integer ÷)*/
0023 leave                                     /*go start calculating the next term.  */
0024 end   /*k*/                               /* [↑]  if an integer, we found a new N*/
0025 end      /*j*/
0026 exit 0                                           /*stick a fork in it,  we're all done. */
0027 /*──────────────────────────────────────────────────────────────────────────────────────*/
0028 commas: parse arg ?;  do jc=length(?)-3  to 1  by -3; ?=insert(',', ?, jc); end;  return ?
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 jc               28
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #                -> newV1            10 12
002 ?                -> newV2            28 28
