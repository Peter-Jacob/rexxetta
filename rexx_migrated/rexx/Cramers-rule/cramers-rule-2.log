-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:09
-------------------------------------------------------------------------
0001 /*REXX program uses Cramer's rule to find and display solution of given linear equations*/
0002 values=     '-3 -32 -47 49'                      /*values of each matrix row of numbers.*/
0003 variables= substr('abcdefghijklmnopqrstuvwxyz', 27 - words(values) )   /*variable names.*/
0004 call makeM  ' 2  -1   5  1        3   2   2  -6        1   3   3  -1        5  -2  -3   3'
0005 do   y=1  for sz;  $=              /*display the matrix (linear equations)*/
0006 do x=1  for sz;  $= $ right(psign(@.x.y), w)'*'substr(variables, x, 1)
0007 end   /*y*/                      /* [↑]   right─justify matrix elements.*/
0008 pad= left('', length($) - 2);    say $   ' = '   right( word(values, y), wv)
0009 end     /*x*/                      /* [↑]   obtain value of the equation. */
0010 say; say
0011 do     k=1  for sz                 /*construct the nominator matrix.      */
0012 do   j=1  for sz
0013 do i=1  for sz;  if i==k  then !.i.j= word(values, j)
0014 else !.i.j= @.i.j
0015 end   /*i*/
0016 end     /*j*/
0017 say pad substr(variables,k,1) ' = ' right(det(makeL())/det(mat), digits()+2)
0018 end       /*k*/
0019 exit 0                                           /*stick a fork in it,  we're all done. */
0020 /*──────────────────────────────────────────────────────────────────────────────────────*/
0021 makeL: $=; do x=1  for sz; do y=1  for sz; $= $ !.x.y; end; end; return $ /*matrix─►list*/
0022 mSize: arg _; do sz=0 for 1e3; if sz*sz==_ then return; end; say 'error,bad matrix';exit 9
0023 psign: parse arg num;  if left(num, 1)\=='-'  &  x>1  then return "+"num;   return num
0024 /*──────────────────────────────────────────────────────────────────────────────────────*/
0025 det: procedure;  parse arg a b c d 1 nums;        call mSize words(nums);    _= 0
0026 if sz==2  then return a*d  -  b*c
0027 do   j=1  for sz
0028 do i=1  for sz;    _= _ + 1;      @.i.j= word(nums, _)
0029 end   /*i*/
0030 end
0031 aa= 0
0032 do     i=1  for sz;  odd= i//2;     $=
0033 do   j=2  for sz-1
0034 do k=1  for sz;  if k\==i  then $= $  @.k.j
0035 end   /*k*/
0036 end     /*j*/
0037 aa= aa   -   (-1 ** odd)  *  @.i.1  *  det($)
0038 end;      /*i*/;                                               return aa
0039 /*──────────────────────────────────────────────────────────────────────────────────────*/
0040 makeM: procedure expose @. values mat sz w wv;  parse arg mat;    call mSize words(mat)
0041 #= 0;                     wv= 0;                           w= 0
0042 do   j=1  for sz;  wv= max(wv, length( word( values, j) ) )
0043 do k=1  for sz;  #= #+1;  @.k.j= word(mat, #);    w= max(w, length(@.k.j))
0044 end   /*k*/
0045 end;    /*j*/;     w= w + 1;                                   return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 mat              40
002 wv               41 42
003 w                41 43 45
004 j                42
005 k                43
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 !.               -> newV1.           13
002 @.               -> newV2.           28 43
003 $                -> newV3            5 6 21 32 34
004 _                -> newV4            25 28
005 #                -> newV5            41 43
