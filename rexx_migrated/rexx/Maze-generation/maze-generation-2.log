-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:20
-------------------------------------------------------------------------
0001 /*REXX program  generates and displays  a  rectangular  solvable maze  (of any size).   */
0002 parse arg rows cols seed .                       /*allow user to specify the maze size. */
0003 if rows='' | rows==","  then rows= 19            /*No rows given?  Then use the default.*/
0004 if cols='' | cols==","  then cols= 19            /* " cols   "  ?    "   "   "     "    */
0005 if datatype(seed, 'W')  then call random ,,seed  /*use a random  seed for repeatability.*/
0006 ht=0;                        @.=0                /*HT= # rows in grid;  @.: default cell*/
0007 call makeRow '┌'copies("─┬", cols-1)'─┐'         /*construct the  top edge  of the maze.*/
0008 
0009 do    r=1  for rows;   _=;     __=;      hp= "|";              hj= '├'
0010 do c=1  for cols;   _= _ || hp'1';    __= __ || hj"─";      hj= '┼';      hp= "│"
0011 end   /*c*/
0012 call makeRow  _'│'       /*construct the right edge of the cells*/
0013 if r\==rows  then call makeRow __'┤'       /*    "      "    "     "   "  "  maze.*/
0014 end      /*r*/                             /* [↑]  construct the maze's grid.     */
0015 
0016 call makeRow '└'copies("─┴", cols-1)'─┘'         /*construct the bottom edge of the maze*/
0017 r!= random(1, rows)*2;    c!= random(1, cols)*2;     @.r!.c!= 0   /*choose the 1st cell.*/
0018 /* [↓]  traipse through the maze.      */
0019 do forever;        n= hood(r!, c!)             /*number of free maze cells.           */
0020 if n==0  then if \fCell()  then leave          /*if no free maze cells left, then done*/
0021 call ?;            @._r._c= 0                  /*get the (next) maze direction to go. */
0022 ro= r!;            co= c!;    r!= _r;   c!= _c /*save the original cell coordinates.  */
0023 ?.zr= ?.zr % 2;    ?.zc= ?.zc % 2              /*get the maze row and cell directions.*/
0024 rw= ro + ?.zr;     cw= co + ?.zc               /*calculate the next maze row and col. */
0025 @.rw.cw=.                                      /*mark the maze cell as being visited. */
0026 end   /*forever*/
0027 /* [↓]  display maze to the terminal.  */
0028 do     r=1  for ht;           _=
0029 do c=1  for cols*2 + 1;   _= _ || @.r.c;   end  /*c*/
0030 if \(r//2)  then _= translate(_, '\',.) /*translate a  period  to a  backslash.*/
0031 _=  changestr( 1 ,  _  , 111   )        /*──────these four ────────────────────*/
0032 _=  changestr( 0 ,  _  , 000   )        /*───────── statements are ────────────*/
0033 _=  changestr( . ,  _  , "   " )        /*────────────── used for preserving ──*/
0034 _=  changestr('─',  _  , "───" )        /*────────────────── the aspect ratio. */
0035 say translate( _ , '│' , "|\10")        /*make it presentable for the screen.  */
0036 end   /*r*/
0037 exit                                             /*stick a fork in it,  we're all done. */
0038 /*──────────────────────────────────────────────────────────────────────────────────────*/
0039 @:       parse arg _r,_c;     return  @._r._c    /*a fast way to reference a maze cell. */
0040 makeRow: parse arg z; ht= ht+1;  do c=1  for length(z); @.ht.c=substr(z,c,1);  end; return
0041 hood:    parse arg rh,ch;     return  @(rh+2,ch)  + @(rh-2,ch)  + @(rh,ch-2)  + @(rh,ch+2)
0042 /*──────────────────────────────────────────────────────────────────────────────────────*/
0043 ?:         do forever;  ?.= 0;   ?= random(1, 4);     if ?==1  then ?.zc= -2     /*north*/
0044 if ?==2  then ?.zr=  2     /* east*/
0045 if ?==3  then ?.zc=  2     /*south*/
0046 if ?==4  then ?.zr= -2     /* west*/
0047 _r= r! + ?.zr;       _c= c! + ?.zc;        if @._r._c == 1    then return
0048 end   /*forever*/
0049 /*──────────────────────────────────────────────────────────────────────────────────────*/
0050 fCell:     do     r=1  for rows;                rr= r + r
0051 do c=1  for cols;                         cc= c + c
0052 if hood(rr,cc)==1  then do;  r!= rr;  c!= cc;   @.r!.c!= 0;  return 1;  end
0053 end   /*c*/                       /* [↑]  r! and c!  are used by invoker.*/
0054 end       /*r*/;       return 0
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 rh               41
002 ch               41
003 rr               50
004 c                51
005 cc               51
006 r!               52
007 c!               52
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           6 17 21 25 40 52
002 __               -> newV2            9 10
003 ?.               -> newV3.           23 23 43 43 44 45 46
004 _r               -> newV4            39 47
005 _c               -> newV5            39 47
006 _                -> newV6            9 10 28 29 30 31 32 33 34
007 ?                -> newV7            43
