-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:19
-------------------------------------------------------------------------
0001 /*REXX program  performs  long multiplication  on  two numbers  (without the "E").      */
0002 numeric digits 300                               /*be able to handle gihugeic input #s. */
0003 parse arg x y .                                  /*obtain optional arguments from the CL*/
0004 if x=='' | x==","  then x= 2**64                 /*Not specified?  Then use the default.*/
0005 if y=='' | y==","  then y= x                     /* "      "         "   "   "     "    */
0006 if x<0  &&  y<0    then sign= '-'                /*there only a single negative number? */
0007 else sign=                    /*no, then result sign must be positive*/
0008 xx=x;    x=strip(x, 'T', .);      x1= left(x, 1) /*remove any trailing decimal points.  */
0009 yy=y;    y=strip(y, 'T', .);      y1= left(y, 1) /*   "    "     "        "       "     */
0010 if x1=='-' | x1=="+"  then x= substr(x, 2)       /*remove a leading  ±  sign.           */
0011 if y1=='-' | y1=="+"  then y= substr(y, 2)       /*   "   "    "     "    "             */
0012 parse var x  '.' xf;  parse var y  "." yf        /*obtain the fractional part of X and Y*/
0013 #= length(xf || yf)                              /*#: digits past the decimal points (.)*/
0014 x= space( translate( x, , .),  0)                /*remove decimal point if there is any.*/
0015 y= space( translate( y, , .),  0)                /*   "       "     "    "    "   "  "  */
0016 Lx= length(x);  Ly=length(y)                     /*get the lengths of the new  X and Y. */
0017 numeric digits max(digits(), Lx + Ly)            /*use a new  decimal digits  precision.*/
0018 $= 0                                             /*$:  is the product  (so far).        */
0019 do j=Ly  by -1  for Ly         /*almost like REXX does it, ··· but no.*/
0020 $= $  +  ((x*substr(y, j, 1))copies(0, Ly-j) )
0021 end   /*j*/
0022 f= length($) - #                                 /*does product has enough decimal digs?*/
0023 if f<0  then $=copies(0, abs(f) + 1)$            /*Negative?  Add leading 0s for INSERT.*/
0024 say 'long mult:'  xx  "*"  yy  '──►'   sign || strip( insert(., $, length($) - #), 'T', .)
0025 say ' built─in:'  xx  "*"  yy  '──►'   xx*yy     /*stick a fork in it,  we're all done. */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 y                12 15
002 yf               12
003 x                14
004 Lx               16
005 Ly               16
006 j                19
007 f                22
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #                -> newV1            13
002 $                -> newV2            18 20 23
