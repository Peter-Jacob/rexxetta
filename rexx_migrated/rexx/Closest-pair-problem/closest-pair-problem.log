-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:08
-------------------------------------------------------------------------
0001 /*REXX program  solves the   closest pair   of  points  problem  (in two dimensions).   */
0002 parse arg N LO HI seed .                         /*obtain optional arguments from the CL*/
0003 if  N=='' |  N==","  then  N=   100              /*Not specified?  Then use the default.*/
0004 if LO=='' | LO==","  then LO=     0              /* "      "         "   "   "     "    */
0005 if HI=='' | HI==","  then HI= 20000              /* "      "         "   "   "     "    */
0006 if datatype(seed, 'W')   then call random ,,seed /*seed for RANDOM (BIF)  repeatability.*/
0007 w= length(HI);     w= w + (w//2==0)              /*W:   for aligning the output columns.*/
0008 
0009 /*╔══════════════════════╗*/      do j=1  for N            /*generate N random points*/
0010 /*║ generate  N  points. ║*/      @x.j= random(LO, HI)     /*    "    a    "     X   */
0011 /*╚══════════════════════╝*/      @y.j= random(LO, HI)     /*    "    a    "     Y   */
0012 end   /*j*/              /*X  &  Y  make the point.*/
0013 A= 1;  B= 2                            /* [↓]  MIND  is actually the squared  */
0014 minD= (@x.A - @x.B)**2   +   (@y.A - @y.B)**2    /* distance between the 1st two points.*/
0015 /* [↓]  use of XJ & YJ speed things up.*/
0016 do   j=1    for N-1;  xj= @x.j;   yj= @y.j   /*find min distance between a point ···*/
0017 do k=j+1  for N-j-1                        /*  ··· and all other (higher) points. */
0018 sd= (xj - @x.k)**2   +   (yj - @y.k)**2    /*compute squared distance from points.*/
0019 if sd<minD  then parse  value     sd  j  k      with      minD  A  B
0020 end   /*k*/                                /* [↑]  needn't take SQRT of SD  (yet).*/
0021 end     /*j*/                                /* [↑]  when done, A & B are the points*/
0022 $= 'For '   N   " points, the minimum distance between the two points:  "
0023 say $ center("x", w, '═')" "     center('y', w, "═")     '  is: '     sqrt( abs(minD)) / 1
0024 say left('', length($) - 1)      "["right(@x.A, w)','           right(@y.A, w)"]"
0025 say left('', length($) - 1)      "["right(@x.B, w)','           right(@y.B, w)"]"
0026 exit 0                                           /*stick a fork in it,  we're all done. */
0027 /*──────────────────────────────────────────────────────────────────────────────────────*/
0028 sqrt: procedure; parse arg x; if x=0  then return 0; d=digits(); m.=9; numeric form; h=d+6
0029 numeric digits;  parse value format(x,2,1,,0) 'E0' with g 'E' _ .;  g= g *.5'e'_ % 2
0030 do j=0  while h>9;      m.j= h;              h= h % 2  +  1;  end  /*j*/
0031 do k=j+5  to 0  by -1;  numeric digits m.k;  g= (g+x/g)*.5;   end  /*k*/; return g
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                28
002 d                28
003 m.               28 30
004 h                28 30
005 w                7 7
006 j                9 16 30
007 A                13 19
008 B                13 19
009 minD             14 19
010 xj               16
011 yj               16
012 k                17 31
013 sd               18
014 NORMAL.14        
015 NORMAL.15        
016 NORMAL.16        
017 NORMAL.17        
018 NORMAL.18        
019 NORMAL.19        
020 NORMAL.20        
021 NORMAL.21        
022 NORMAL.22        
023 g                29 29 31
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @x.              -> newV1.           10
002 @y.              -> newV2.           11
003 $                -> newV3            22
004 _                -> newV4            29
