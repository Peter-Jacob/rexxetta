-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:24
-------------------------------------------------------------------------
0001 /*REXX pgm calculates pisano period for a range of N, and pisanoPrime(N,m)  [for primes]*/
0002 numeric digits 500                               /*ensure enough decimal digits for Fib.*/
0003 parse arg lim.1 lim.2 lim.3 .                    /*obtain optional arguments from the CL*/
0004 if lim.1=='' | lim.1==","  then lim.1=  15 - 1   /*Not specified?  Then use the default.*/
0005 if lim.2=='' | lim.2==","  then lim.2= 180 - 1   /* "      "         "   "   "     "    */
0006 if lim.3=='' | lim.3==","  then lim.3= 180       /* "      "         "   "   "     "    */
0007 call Fib                                         /*    "      "   Fibonacci numbers.    */
0008 do i=1  for max(lim.1, lim.2, lim.3);  call pisano(i)    /*find pisano periods.*/
0009 end   /*i*/;    w= length(i)
0010 
0011 do j=1  for 2;  #= word(2 1, j)
0012 do p=1  for lim.j;  if \isPrime(p)  then iterate  /*Not prime?  Skip this number.*/
0013 say '   pisanoPrime('right(p, w)", "#') = 'right( pisanoPrime(p, #), 5)
0014 end   /*p*/;        say
0015 end      /*j*/
0016 
0017 say center(' pisano numbers for 1──►'lim.3" ",  20*4 - 1,  "═")       /*display a title.*/
0018 $=
0019 do j=1  for lim.3;     $= $  right(@.j, w)   /*append pisano number to the  $  list.*/
0020 if j//20==0  then do;  say substr($, 2);  $=;  end    /*display 20 numbers to a line*/
0021 end   /*j*/
0022 say substr($, 2)      /*possible display any residuals──►term*/
0023 exit 0                                           /*stick a fork in it,  we're all done. */
0024 /*──────────────────────────────────────────────────────────────────────────────────────*/
0025 fib: procedure expose fib.; parse arg x; fib.=.;     if x==''      then x= 1000
0026 fib.0= 0;  fib.1= 1;                            if fib.x\==.  then return fib.x
0027 do k=2  for x-1;    a= k-1;        b= k-2;       fib.k=  fib.a + fib.b
0028 end   /*k*/;    return fib.k
0029 /*──────────────────────────────────────────────────────────────────────────────────────*/
0030 isPrime: parse arg n; if n<11  then return pos(n, '2 3 5 7')>0;  if n//2==0  then return 0
0031 do k=3  by 2  while k*k<=n; if n//k==0  then return 0; end /*k*/;     return 1
0032 /*──────────────────────────────────────────────────────────────────────────────────────*/
0033 pisano: procedure expose @. fib.; parse arg m;   if m==1  then do;  @.m=1;  return 1;  end
0034 do k=1;  _= k+1;                 if fib.k//m==0 & fib._//m==1  then leave
0035 end   /*k*/;      @.m= k;                 return k
0036 /*──────────────────────────────────────────────────────────────────────────────────────*/
0037 pisanoPrime: procedure expose @. fib.; parse arg m,n;     return m**(n-1)  *  pisano(m)
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 m                37
002 n                37
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           33 35
002 #                -> newV2            11
003 $                -> newV3            18 19 20
004 _                -> newV4            34
