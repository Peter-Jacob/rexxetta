-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:31
-------------------------------------------------------------------------
0001 /*REXX program finds and displays  primes  with successive differences  (up to a limit).*/
0002 parse arg H . 1 . difs                           /*allow the highest number be specified*/
0003 if H=='' | H==","  then  H= 1000000              /*Not specified?  Then use the default.*/
0004 if difs=''   then  difs= 2 1 2.2 2.4 4.2 6.4.2   /* "      "         "   "   "     "    */
0005 call genP H
0006 
0007 do j=1  for words(difs)                             /*traipse through the lists.*/
0008 dif= translate( word(difs, j),,.);  dw= words(dif)  /*obtain true differences.  */
0009 do i=1  for dw;  dif.i= word(dif, i)            /*build an array of diffs.  */
0010 end   /*i*/                                     /* [↑]  for optimization.   */
0011 say center('primes with differences of:'  dif,  50, '─')        /*display title.*/
0012 p= 1;                        c= 0;        grp=      /*init. prime#,  count, grp.*/
0013 do a=1;  p= nextP(p+1);  if p==0  then leave   /*find the next  DIF  primes*/
0014 aa= p;   !.=                                   /*AA: nextP;  the group #'s.*/
0015 !.1= p                                         /*assign 1st prime in group.*/
0016 do g=2  for dw                          /*get the rest of the group.*/
0017 aa= nextP(aa+1); if aa==0  then leave a /*obtain the next prime.    */
0018 !.g= aa;         _= g-1                 /*prepare to add difference.*/
0019 if !._ + dif._\==!.g  then iterate a    /*determine if fits criteria*/
0020 end   /*g*/
0021 c= c+1                                         /*bump count of # of groups.*/
0022 grp= !.1;       do b=2  for dw;  grp= grp !.b  /*build a list of primes.   */
0023 end   /*b*/
0024 if c==1  then say '     first group: '   grp   /*display the first group.  */
0025 end   /*a*/
0026 /* [↓]  test if group found.*/
0027 if grp==''   then say "         (none)"             /*display the  last group.  */
0028 else say '      last group: '   grp    /*   "     "     "    "     */
0029 say '           count: '   c      /*   "     "  group count.  */
0030 say
0031 end   /*j*/
0032 exit                                             /*stick a fork in it,  we're all done. */
0033 /*──────────────────────────────────────────────────────────────────────────────────────*/
0034 nextP:    do nxt=arg(1)  to H;  if @.nxt==.  then return nxt;  end /*nxt*/;     return 0
0035 /*──────────────────────────────────────────────────────────────────────────────────────*/
0036 genP: procedure expose @.; parse arg N;  != 0;  @.=.;  @.1=      /*initialize the array.*/
0037 do e=4  by 2  for (N-1)%2;  @.e=;  end /*treat the even integers > 2  special.*/
0038 /*all primes are indicated with a  "." */
0039 do j=1  by 2  for (N-1)%2                /*use odd integers up to  N  inclusive.*/
0040 if @.j==.  then do;  if !  then iterate  /*Prime?   Should skip the top part ?  */
0041 jj= j * j           /*compute the square of  J.        ___ */
0042 if jj>N  then != 1  /*indicate skip top part  if  j > √ N  */
0043 do m=jj  to N  by j+j;  @.m=;  end       /*odd multiples.*/
0044 end                      /* [↑]  strike odd multiples  ¬ prime. */
0045 end   /*j*/;               return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 N                36
002 e                37
003 j                39
004 jj               41
005 m                43
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 !.               -> newV1.           14 15 18
002 @.               -> newV2.           36 36 37 43
003 _                -> newV3            18
004 !                -> newV4            36 42
