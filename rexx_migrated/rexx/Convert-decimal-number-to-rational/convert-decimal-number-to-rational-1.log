-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:09
-------------------------------------------------------------------------
0001 /*REXX program converts a rational fraction  [n/m]  (or  nnn.ddd)  to it's lowest terms.*/
0002 numeric digits 10                                /*use ten decimal digits of precision. */
0003 parse arg  orig 1 n.1  "/"  n.2;       if n.2=''  then n.2=1         /*get the fraction.*/
0004 if n.1=''  then call er 'no argument specified.'
0005 
0006 do j=1  for 2;     if \datatype(n.j, 'N')  then call er  "argument isn't numeric:"   n.j
0007 end   /*j*/                                    /* [↑]  validate arguments:  n.1  n.2  */
0008 
0009 if n.2=0  then call er "divisor can't be zero."  /*Whoa!   We're dividing by zero !     */
0010 say 'old ='    space(orig)                       /*display the original fraction.       */
0011 say 'new ='    rat(n.1/n.2)                      /*display the result ──► terminal.     */
0012 exit                                             /*stick a fork in it,  we're all done. */
0013 /*──────────────────────────────────────────────────────────────────────────────────────*/
0014 er:  say;      say '***error***';     say;    say arg(1);    say;       exit 13
0015 /*──────────────────────────────────────────────────────────────────────────────────────*/
0016 rat: procedure;  parse arg x 1 _x,y;          if y==''  then y = 10**(digits()-1)
0017 b=0;  g=0;  a=1;  h=1                               /* [↑]    Y   is the tolerance.*/
0018 do  while  a<=y & g<=y;   n=trunc(_x)
0019 _=a;   a=n*a+b;   b=_
0020 _=g;   g=n*g+h;   h=_
0021 if n=_x | a/g=x then do;  if a>y | g>y  then iterate
0022 b=a;     h=g;      leave
0023 end
0024 _x=1/(_x-n)
0025 end   /*while*/
0026 if h==1  then return b                              /*don't return number  ÷  by 1.*/
0027 return b'/'h                          /*proper or improper fraction. */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                16
002 y                16 16
003 b                17 19 22
004 g                17 20
005 a                17 19
006 h                17 20 22
007 while            18
008 n                18
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 _x               -> newV1            16 24
002 _                -> newV2            19 20
