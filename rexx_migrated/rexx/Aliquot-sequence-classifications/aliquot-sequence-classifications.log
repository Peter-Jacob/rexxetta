-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:04
-------------------------------------------------------------------------
0001 /*REXX program classifies various  positive integers  for  types of  aliquot sequences. */
0002 parse arg low high $L                            /*obtain optional arguments from the CL*/
0003 high= word(high low 10,1);   low= word(low 1,1)  /*obtain the  LOW  and  HIGH  (range). */
0004 if $L=''  then $L=11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080
0005 numeric digits 100                               /*be able to compute the number:  BIG  */
0006 big= 2**47;                  NTlimit= 16 + 1     /*limits for a non─terminating sequence*/
0007 numeric digits max(9, length(big) )              /*be able to handle big numbers for // */
0008 digs= digits()                                   /*used for align numbers for the output*/
0009 #.= .;        #.0= 0;        #.1= 0              /*#.   are the proper divisor sums.    */
0010 say center('numbers from '      low      " ───► "      high      ' (inclusive)', 153, "═")
0011 do n=low  to high;    call classify  n /*call a subroutine to classify number.*/
0012 end   /*n*/                            /* [↑]   process a range of integers.  */
0013 say
0014 say center('first numbers for each classification', 153, "═")
0015 class.= 0                                        /* [↓]  ensure one number of each class*/
0016 do q=1  until class.sociable\==0       /*the only one that has to be counted. */
0017 call classify  -q                      /*minus (-) sign indicates don't tell. */
0018 _= what;  upper _                      /*obtain the class and uppercase it.   */
0019 class._= class._ + 1                   /*bump counter for this class sequence.*/
0020 if class._==1  then say right(q, digs)':'      center(what, digs)      $
0021 end   /*q*/                            /* [↑]  only display the 1st occurrence*/
0022 say                                              /* [↑]  process until all classes found*/
0023 say center('classifications for specific numbers', 153, "═")
0024 do i=1  for words($L)                  /*$L:  is a list of  "special numbers".*/
0025 call classify   word($L, i)            /*call a subroutine to classify number.*/
0026 end   /*i*/                            /* [↑]  process a list of integers.    */
0027 exit                                             /*stick a fork in it,  we're all done. */
0028 /*──────────────────────────────────────────────────────────────────────────────────────*/
0029 classify: parse arg a 1 aa;         a= abs(a)    /*obtain number that's to be classified*/
0030 if #.a\==.    then s= #.a                 /*Was this number been  summed  before?*/
0031 else s= sigma(a)            /*No, then classify number the hard way*/
0032 #.a= s                                    /*define sum of the  proper divisors.  */
0033 $= s                                      /*define the start of integer sequence.*/
0034 what= 'terminating'         /*assume this kind of classification.  */
0035 c.=  0                                    /*clear all cyclic sequences (to zero).*/
0036 c.s= 1                                    /*set the first cyclic sequence.       */
0037 if $==a  then what= 'perfect'             /*check for a  "perfect"  number.      */
0038 else do t=1  while s>0           /*loop until sum isn't  0   or   > big.*/
0039 m= s                        /*obtain the last number in sequence.  */
0040 if #.m==.  then s= sigma(m) /*Not defined? Then sum proper divisors*/
0041 else s= #.m      /*use the previously found integer.    */
0042 if m==s  then if m>=0   then do;  what= 'aspiring';  leave;   end
0043 parse var  $   .  word2  .  /*obtain the 2nd  number in sequence.  */
0044 if word2==a             then do;  what= 'amicable';  leave;   end
0045 $= $ s                      /*append a sum to the integer sequence.*/
0046 if s==a  then if t>3    then do;  what= 'sociable';  leave;   end
0047 if c.s   then if m>0    then do;  what= 'cyclic'  ;  leave;   end
0048 c.s= 1                      /*assign another possible cyclic number*/
0049 /* [↓]  Rosetta Code task's limit: >16 */
0050 if t>NTlimit     then do;  what= 'non─terminating';  leave;   end
0051 if s>big         then do;  what= 'NON─TERMINATING';  leave;   end
0052 end   /*t*/                 /* [↑]  only permit within reason.     */
0053 if aa>0  then say right(a, digs)':'     center(what, digs)     $
0054 return                                    /* [↑] only display if  AA  is positive*/
0055 /*──────────────────────────────────────────────────────────────────────────────────────*/
0056 sigma: procedure expose #. !.;  parse arg x;   if 11<2  then return 0;        odd= x // 2
0057 s= 1                                      /* [↓]  use EVEN or ODD integers.   ___*/
0058 do j=2+odd  by 1+odd  while j*j<x    /*divide by all the integers up to √ X */
0059 if x//j==0  then  s= s + j +   x % j /*add the two divisors to the sum.     */
0060 end   /*j*/                          /* [↓]  adjust for square.          ___*/
0061 if j*j==x  then  s= s + j                 /*Was  X  a square?    If so, add  √ X */
0062 #.x= s                                    /*memoize division sum for argument  X.*/
0063 return s                                  /*return      "     "   "      "     " */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                56
002 odd              56
003 s                57 59 61
004 j                58
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $L               -> newV1            2 4
002 #.               -> newV2.           9 9 9 32 62
003 _                -> newV3            18
004 $                -> newV4            33 43 45
