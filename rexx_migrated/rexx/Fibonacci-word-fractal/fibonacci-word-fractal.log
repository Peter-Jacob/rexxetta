-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:13
-------------------------------------------------------------------------
0001 /*REXX program generates a Fibonacci word,  then (normally) displays the  fractal curve.*/
0002 parse arg order .                                /*obtain optional arguments from the CL*/
0003 if order=='' | order==","  then order= 23        /*Not specified?   Then use the default*/
0004 tell=  order>=0                                  /*Negative order?  Then don't display. */
0005 s= FibWord( abs(order) )                         /*obtain the  order  of Fibonacci word.*/
0006 x= 0;       maxX= 0;    dx= 0;    b= ' ';     @.   = b;    xp= 0
0007 y= 0;       maxY= 0;    dy= 1;                @.0.0= .;    yp= 0
0008 do n=1  for length(s);  x= x + dx;  y= y + dy  /*advance the plot for the next point. */
0009 maxX= max(maxX, x);     maxY= max(maxY, y)     /*set the maximums for displaying plot.*/
0010 c= '│'                         /*glyph (character) used for the plot. */
0011 if dx\==0  then c= "─"                         /*if  x+dx   isn't zero, use this char.*/
0012 if n==1    then c= '┌'                         /*is this the first part to be graphed?*/
0013 @.x.y= c                                       /*assign a plotting character for curve*/
0014 if @(xp-1, yp)\==b  then if  @(xp, yp-1)\==b  then call @ xp,yp,'┐'  /*fix─up a corner*/
0015 if @(xp-1, yp)\==b  then if  @(xp, yp+1)\==b  then call @ xp,yp,'┘'  /*   "   "    "  */
0016 if @(xp+1, yp)\==b  then if  @(xp, yp-1)\==b  then call @ xp,yp,'┌'  /*   "   "    "  */
0017 if @(xp+1, yp)\==b  then if  @(xp, yp+1)\==b  then call @ xp,yp,'└'  /*   "   "    "  */
0018 xp= x;     yp= y                               /*save the old   x  &  y   coördinates.*/
0019 z= substr(s, n, 1)                             /*assign a plot character for the graph*/
0020 if z==1    then iterate                        /*Is Z equal to unity?  Then ignore it.*/
0021 ox= dx;    oy= dy                              /*save    DX,DY   as the old versions. */
0022 dx= 0;     dy= 0                               /*define  DX,DY    "  "  new     "     */
0023 d= -n//2;         if d==0  then d= 1           /*determine the sign for the chirality.*/
0024 if oy\==0  then dx= -sign(oy) * d              /*Going  north│south?   Go  east|west  */
0025 if ox\==0  then dy=  sign(ox) * d              /*  "     east│west?     " south|north */
0026 end   /*n*/
0027 
0028 call @  x, y, '∙'                                /*set the last point that was plotted. */
0029 
0030 do r=maxY   to 0  by -1;  _=              /*show single row at a time, top first.*/
0031 do c=0  for maxX+1;    _= _  ||  @.c.r /*add a plot character (glyph) to line.*/
0032 end   /*c*/                            /* [↑]  construct a line char by char. */
0033 _= strip(_, 'T')                          /*construct a line of the graph.       */
0034 if _==''  then iterate                    /*Is the line blank?   Then ignore it. */
0035 if tell  then say _                       /*Display the line to the terminal ?   */
0036 call lineout "FIBFRACT.OUT", _            /*write graph to disk  (FIBFRACT.OUT). */
0037 end      /*r*/                            /* [↑]  only display the non-blank rows*/
0038 exit 0                                           /*stick a fork in it,  we're all done. */
0039 /*──────────────────────────────────────────────────────────────────────────────────────*/
0040 @: parse arg xx,yy,p;     if arg(3)==''  then return @.xx.yy;     @.xx.yy= p;       return
0041 /*──────────────────────────────────────────────────────────────────────────────────────*/
0042 FibWord: procedure; parse arg x; !.= 0;   !.1= 1 /*obtain the order of  Fibonacci word. */
0043 do k=3  to x                 /*generate the   Kth       "       "   */
0044 k1= k-1;    k2= k - 2 /*calculate the  K-1  &  K-2  shortcut.*/
0045 !.k= !.k1    ||  !.k2        /*construct the next   Fibonacci word. */
0046 end   /*k*/                  /* [↑]  generate a         "       "   */
0047 return !.x                              /*return the    Xth        "       "   */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                42
002 k                43
003 k1               44
004 k2               44
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           6 7 13 40
002 !.               -> newV2.           42 42 45
003 _                -> newV3            30 31 33
