-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:31
-------------------------------------------------------------------------
0001 /*REXX program generates & displays a Stern─Brocot sequence; finds 1─based indices; GCDs*/
0002 parse arg N idx fix chk .                        /*get optional arguments from the C.L. */
0003 if   N=='' |   N==","  then   N=   15            /*Not specified?  Then use the default.*/
0004 if idx=='' | idx==","  then idx=   10            /* "      "         "   "   "     "    */
0005 if fix=='' | fix==","  then fix=  100            /* "      "         "   "   "     "    */
0006 if chk=='' | chk==","  then chk= 1000            /* "      "         "   "   "     "    */
0007 
0008 if N>0  then say center('the first'   N   "numbers in the Stern─Brocot sequence", 70, '═')
0009 a= Stern_Brocot(N)                               /*invoke function to generate sequence.*/
0010 say a                                            /*display the sequence to the terminal.*/
0011 say
0012 say center('the 1─based index for the first'       idx        "integers",   70, '═')
0013 a= Stern_Brocot(-idx)                            /*invoke function to generate sequence.*/
0014 w= length(idx);        do i=1  for idx
0015 say 'for '   right(i, w)",  the index is: "          wordpos(i, a)
0016 end   /*i*/
0017 say
0018 say center('the 1─based index for'  fix, 70, "═")
0019 a= Stern_Brocot(-fix)                            /*invoke function to generate sequence.*/
0020 say 'for '       fix",  the index is: "      wordpos(fix, a)
0021 say
0022 if chk<2  then exit 0
0023 say center('checking if all two consecutive members have a GCD=1', 70, '═')
0024 a= Stern_Brocot(chk)                             /*invoke function to generate sequence.*/
0025 do c=1  for chk-1;    if gcd(subword(a, c, 2))==1  then iterate
0026 say 'GCD check failed at index'         c;         exit 13
0027 end   /*c*/
0028 say
0029 say '───── All '     chk     " two consecutive members have a GCD of unity."
0030 exit 0                                           /*stick a fork in it,  we're all done. */
0031 /*──────────────────────────────────────────────────────────────────────────────────────*/
0032 gcd: procedure; $=;     do i=1  for arg();     $= $ arg(i)              /*get arg list. */
0033 end   /*i*/
0034 parse var $ x z .;                if x=0  then x= z                /*is zero case? */
0035 x=abs(x)                                                           /*use absolute x*/
0036 do j=2  to words($);    y=abs( word($, j) )
0037 if y=0  then iterate                                     /*ignore zeros. */
0038 do  until y==0;      parse value x//y y  with  y x    /* ◄──heavy work*/
0039 end   /*until*/
0040 end      /*j*/
0041 return x                                                           /*return the GCD*/
0042 /*──────────────────────────────────────────────────────────────────────────────────────*/
0043 Stern_Brocot:  parse arg h 1 f;                $= 1 1;           if h<0  then h= 1e9
0044 else f= 0
0045 f= abs(f)
0046 do k=2  until words($)>=h  |  wordpos(f, $)\==0
0047 _= word($, k);      $= $   (_ + word($, k-1) )   _
0048 end   /*k*/
0049 if f==0  then return subword($, 1, h)
0050 return $
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 h                43 43
002 f                43 45
003 k                46
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $                -> newV1            32 32 34 43 47
002 _                -> newV2            47
