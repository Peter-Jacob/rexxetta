-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:14
-------------------------------------------------------------------------
0001 /*REXX program  computes the   forward difference   of a  list of numbers.              */
0002 numeric digits 100                               /*ensure enough accuracy (decimal digs)*/
0003 parse arg e ',' N                                /*get a list:  ε1 ε2 ε3 ε4 ··· , order */
0004 if e==''  then e=90 47 58 29 22 32 55 5 55 73    /*Not specified?  Then use the default.*/
0005 #=words(e)                                       /*#  is the number of elements in list.*/
0006 /* [↓]  verify list items are numeric. */
0007 do i=1  for #;        _=word(e, i)            /*process each number one at a time.   */
0008 if \datatype(_, 'N')  then call ser    _    "isn't a valid number";    @.i=_/1
0009 end   /*i*/                                   /* [↑]  removes superfluous stuff.     */
0010 /* [↓]  process the optional order.    */
0011 if N==''  then parse value 0 # # with bot top N  /*define the default  order  range.    */
0012 else parse var N bot 1 top             /*Not specified?  Then use only 1 order*/
0013 if #==0   then call ser     "no numbers were specified."
0014 if N<0    then call ser  N  "(order) can't be negative."
0015 if N>#    then call ser  N  "(order) can't be greater than"  #
0016 say right(#  'numbers:', 44)  e                  /*display the header (title)  and ···  */
0017 say left('', 44)copies('─', length(e)+2)         /*display the header fence.            */
0018 /* [↓]  where da rubber meets da road. */
0019 do o=bot  to top;        do r=1  for #;  !.r=@.r;     end /*r*/;        $=
0020 do j=1  for o; d=!.j;  do k=j+1  to #; parse value !.k !.k-d with d !.k; end /*k*/
0021 end   /*j*/
0022 do i=o+1  to #; $=$ !.i/1;   end /*i*/
0023 if $==''  then $=' [null]'
0024 say right(o, 7)th(o)'─order forward difference vector ='     $
0025 end     /*o*/
0026 exit                                             /*stick a fork in it,  we're all done. */
0027 /*──────────────────────────────────────────────────────────────────────────────────────*/
0028 ser:           say;           say '***error***';      say arg(1);     say;         exit 13
0029 th: procedure; x=abs(arg(1)); return word('th st nd rd',1+x//10*(x//100%10\==1)*(x//10<4))
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 N                12
002 bot              12
003 top              12
004 o                19
005 r                19
006 j                20
007 d                20 20
008 k                20
009 NORMAL.9         
010 NORMAL.10        
011 NORMAL.11        
012 NORMAL.12        
013 bot              11
014 top              11
015 NORMAL.15        
016 NORMAL.16        
017 i                22
018 x                29
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           8
002 !.               -> newV2.           19 20
003 #                -> newV3            5
004 _                -> newV4            7
005 $                -> newV5            19 22 23
