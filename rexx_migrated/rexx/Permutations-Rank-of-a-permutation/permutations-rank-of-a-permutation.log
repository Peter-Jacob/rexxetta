-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:24
-------------------------------------------------------------------------
0001 /*REXX program displays permutations of   N   number of  objects  (1, 2, 3,  ···).      */
0002 parse arg N y seed .                             /*obtain optional arguments from the CL*/
0003 if N=='' | N==","  then N=  4                    /*Not specified?  Then use the default.*/
0004 if y=='' | y==","  then y= 17                    /* "      "         "   "   "     "    */
0005 if datatype(seed,'W')  then call random ,,seed   /*can make RANDOM numbers repeatable.  */
0006 permutes= permSets(N)                            /*returns  N! (number of permutations).*/
0007 w= length(permutes)                              /*used for aligning the  SAY  output.  */
0008 @.=
0009 do p=0  for permutes                       /*traipse through each of the permutes.*/
0010 z= permSets(N, p)                          /*get which of the  permutation  it is.*/
0011 say 'for'     N     "items, permute rank"      right(p,w)        'is: '        z
0012 @.p= z                                     /*define a rank permutation in @ array.*/
0013 end   /*p*/
0014 say                                              /* [↓]  displays a particular perm rank*/
0015 say '  the permutation rank of'  y  "is: "   @.y /*display a particular permutation rank*/
0016 exit                                             /*stick a fork in it,  we're all done. */
0017 /*──────────────────────────────────────────────────────────────────────────────────────*/
0018 permSets:   procedure expose @. #;     #= 0;   parse arg x,r,c;   c= space(c);    xm= x -1
0019 do j=1  for x;     @.j= j-1;   end  /*j*/
0020 _=0;    do u=2  for xm;    _= _ @.u;   end  /*u*/
0021 if r==#  then return _;            if c==_  then return #
0022 do  while .permSets(x,0);  #= #+1;            _= @.1
0023 do v=2  for xm;    _= _  @.v;    end  /*v*/
0024 if r==#  then return  _;   if c==_  then return #
0025 end   /*while···*/
0026 return #+1
0027 /*──────────────────────────────────────────────────────────────────────────────────────*/
0028 .permSets:  procedure expose @.;       parse arg p,q;                  pm= p-1
0029 do k=pm  by -1  for pm;   kp= k+1;  if @.k<@.kp  then do; q=k; leave; end
0030 end   /*k*/
0031 
0032 do j=q+1  while j<p;  parse  value  @.j  @.p   with   @.p  @.j;    p= p-1
0033 end   /*j*/
0034 if q==0  then return 0
0035 do p=q+1  while @.p<@.q
0036 end   /*p*/
0037 parse  value   @.p  @.q   with   @.q  @.p
0038 return 1
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 p                28 32 35
002 q                28 29
003 pm               28
004 k                29
005 kp               29
006 j                32
007 v                23
008 NORMAL.8         
009 NORMAL.9         
010 NORMAL.10        
011 NORMAL.11        
012 NORMAL.12        
013 NORMAL.13        
014 NORMAL.14        
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           8 12 19 32 32 37 37
002 #                -> newV2            18 22
003 _                -> newV3            20 20 22 23
