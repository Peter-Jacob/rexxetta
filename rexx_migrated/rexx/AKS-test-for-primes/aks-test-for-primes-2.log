-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:04
-------------------------------------------------------------------------
0001 /*REXX program calculates  primes  via the  Agrawal─Kayal─Saxena  (AKS)  primality test.*/
0002 parse arg Z .                                    /*obtain optional argument from the CL.*/
0003 if Z=='' | Z=="," then Z= 200                    /*Not specified?  Then use the default.*/
0004 OZ=Z;               tell= Z<0;       Z= abs(Z)   /*Is Z negative?  Then show expression.*/
0005 numeric digits  max(9,  Z % 3)                   /*define a dynamic # of decimal digits.*/
0006 call AKS                                         /*invoke the AKS funtion for coef. bld.*/
0007 if left(OZ,1)=='+' then do; say Z isAksp(); exit /*display if  Z  is  or isn't  a prime.*/
0008 end                      /* [↑]  call isAKSp if Z has leading +.*/
0009 say;    say "primes found:"   #                  /*display the  prime number  list.     */
0010 say;    if \datatype(#, 'W')  then exit          /* [↓]  the digit length of a big coef.*/
0011 say 'Found '   words(#)   " primes and the largest coefficient has "   length(@.pm.h)  @dd
0012 exit                                             /*stick a fork in it,  we're all done. */
0013 /*──────────────────────────────────────────────────────────────────────────────────────*/
0014 AKS: $.0= '-';      $.1= "+";           @. = 1   /*$.x: sign char; default coefficients.*/
0015 q.= 1;         q.1= 0;             q.4= 0   /*sparse array for faster comparisons. */
0016 #=;            L= length(Z)                 /*define list of prime numbers (so far)*/
0017 do p=3  for Z;      pm=p - 1;   pp=p + 1 /*PM & PP: used as a coding convenience*/
0018 do m=2  for pp % 2   - 1;   mm=m - 1 /*calculate coefficients for a power.  */
0019 @.p.m= @.pm.mm + @.pm.m;    h=pp - m /*calculate left  side of  coefficients*/
0020 @.p.h= @.p.m                         /*    "     right   "   "       "      */
0021 end   /*m*/                          /* [↑]  The  M   DO  loop creates both */
0022 end       /*p*/                          /*      sides in the same loop.        */
0023 if tell  then say '(x-1)^'right(0, L)":  1" /*possibly display the first expression*/
0024 @dd= 'decimal digits.'                      /* [↓]  test for primality by division.*/
0025 do n=2  for Z;     nh=n % 2;    d= n - 1 /*create expressions;  find the primes.*/
0026 do k=3  to nh  while @.n.k//d == 0   /*are coefficients divisible by  N-1 ? */
0027 end   /*k*/                          /* [↑]  skip the 1st & 2nd coefficients*/
0028 if k>nh   then if q.d  then #= # d       /*add a number to the prime list.      */
0029 if \tell  then iterate                   /*Don't tell?   Don't show expressions.*/
0030 y= '(x-1)^'right(d, L)":"                /*define the 1st part of the expression*/
0031 s=1                                      /*S:     is the sign indicator (-1│+1).*/
0032 do j=n  for n-1  by -1               /*create the higher powers first.      */
0033 if j==2  then xp= 'x'                /*if power=1, then don't show the power*/
0034 else xp= 'x^' ||   j-1      /*        ··· else show power with  ^  */
0035 if j==n  then y=y  xp                /*no sign (+│-) for the 1st expression.*/
0036 else y=y  $.s || @.n.j'∙'xp /*build the expression with sign (+|-).*/
0037 s= \s                                /*flip the sign for the next expression*/
0038 end   /*j*/                          /* [↑]  the sign (now) is either 0 │ 1,*/
0039 say  y  $.s'1'                           /*just show the first  N  expressions, */
0040 end       /*n*/                          /* [↑]  ··· but only for  negative  Z. */
0041 if #==''  then #= "none";        return #   /*if null, return "none"; else return #*/
0042 /*──────────────────────────────────────────────────────────────────────────────────────*/
0043 isAKSp: if z==word(#,words(#))  then return ' is a prime.';  else return " isn't a prime."
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 Z                2 3 4
002 OZ               4
003 tell             4
004 q.               15 15 15
005 L                16
006 p                17
007 pm               17
008 pp               17
009 m                18
010 mm               18
011 h                19
012 n                25
013 nh               25
014 d                25
015 k                26
016 y                30 35
017 s                31 37
018 j                32
019 xp               33
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @dd              -> newV1            24
002 $.               -> newV2.           14
003 @.               -> newV3.           14 19 20
004 #                -> newV4            16 28 41
