-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:16
-------------------------------------------------------------------------
0001 /*REXX program  calculates  the  distance between  Nashville  and  Los Angles  airports.*/
0002 call pi;    numeric digits length(pi) % 2        /*use half of PI dec. digits for output*/
0003 say "       Nashville:  north 36º  7.2', west  86º 40.2'   =   36.12º,  -86.67º"
0004 say "      Los Angles:  north 33º 56.4', west 118º 24.0'   =   33.94º, -118.40º"
0005 @using_radius= 'using the mean radius of the earth as '            /*a literal for  SAY.*/
0006 radii.=.;    radii.1=6372.8;     radii.2=6371    /*mean radii of the earth in kilometers*/
0007 say;                         m=1/0.621371192237  /*M:   one statute mile  in      "     */
0008 do radius=1  while radii.radius\==.          /*calc. distance using specific radii. */
0009 d= surfaceDist( 36.12,    -86.67,    33.94,   -118.4,    radii.radius);         say
0010 say center(@using_radius     radii.radius         ' kilometers', 75, '─')
0011 say ' Distance between:  '   format(d/1            ,,2)    " kilometers,"
0012 say '               or   '   format(d/m            ,,2)    " statute miles,"
0013 say '               or   '   format(d/m*5280/6076.1,,2)    " nautical (or air miles)."
0014 end   /*radius*/                             /*show──┘   2 dec. digs past dec. point*/
0015 exit                                             /*stick a fork in it,  we're all done. */
0016 /*──────────────────────────────────────────────────────────────────────────────────────*/
0017 surfaceDist: parse arg th1,ph1,th2,ph2,r         /*use  haversine  formula for distance.*/
0018 numeric digits digits() * 2                /*double number of decimal digits used.*/
0019 ph1 = d2r(ph1 - ph2)               /*convert degrees ──► radians & reduce.*/
0020 th1 = d2r(th1)                     /*   "       "           "    "    "   */
0021 th2 = d2r(th2)                     /*   "       "           "    "    "   */
0022 cosTH1= cos(th1)                           /*compute a shortcut (it's used twice).*/
0023 x = cos(ph1) * cosTH1 - cos(th2) /*   "    X   coordinate.              */
0024 y = sin(ph1) * cosTH1            /*   "    Y       "                    */
0025 z = sin(th1)          - sin(th2) /*   "    Z       "                    */
0026 return Asin(sqrt(x*x + y*y + z*z)*.5) *r*2 /*compute the arcsin and return value. */
0027 /*──────────────────────────────────────────────────────────────────────────────────────*/
0028 Acos: return pi() * .5   -   aSin( arg(1) )      /*calculate the ArcCos of an argument. */
0029 d2d:  return arg(1)               //  360        /*normalize degrees to a  unit circle. */
0030 d2r:  return r2r(  arg(1) * pi()  /   180)       /*normalize and convert deg ──► radians*/
0031 r2d:  return d2d( (arg(1) * 180   /   pi()))     /*normalize and convert rad ──► degrees*/
0032 r2r:  return arg(1)               // (pi() * 2)  /*normalize radians to a  unit circle. */
0033 pi:   pi= 3.141592653589793238462643383279502884197169399375105820975;           return pi
0034 /*──────────────────────────────────────────────────────────────────────────────────────*/
0035 Asin: procedure; parse arg x 1 z 1 o 1 p;     a= abs(x);               aa= a * a
0036 if a >= sqrt(2) * .5  then return sign(x) * Acos( sqrt(1 - aa) )
0037 do j=2  by 2  until p=z;    p= z;     o= o * aa * (j-1) / j;   z= z  +  o / (j+1)
0038 end   /*j*/;                return z      /* [↑]  compute until no more noise.  */
0039 /*──────────────────────────────────────────────────────────────────────────────────────*/
0040 cos:  procedure; parse arg x;       x= r2r(x);       a= abs(x);              Hpi= pi * .5
0041 numeric fuzz min(6, digits() - 3)  ;     if a=pi    then return -1
0042 if a=Hpi | a=Hpi*3  then return 0  ;     if a=pi/3  then return .5
0043 if a=pi* 2/3        then return -.5;     q= x*x;    p= 1;     z= 1;     _= 1
0044 do k=2  by 2;  _= -_*q / (k*(k-1)); z= z+_; if z=p  then leave; p=z; end; return z
0045 /*──────────────────────────────────────────────────────────────────────────────────────*/
0046 sin:  procedure; parse arg x;  x= r2r(x);                numeric fuzz min(5, digits() - 3)
0047 if abs(x)=pi  then  return 0;            q= x*x;    p= x;     z= x;      _= x
0048 do k=2  by 2; _= -_*q / (k*(k+1));  z= z+_; if z=p  then leave; p=z; end; return z
0049 /*──────────────────────────────────────────────────────────────────────────────────────*/
0050 sqrt: procedure; parse arg x; if x=0  then return 0; d=digits(); m.=9; numeric form; h=d+6
0051 numeric digits;  parse value format(x,2,1,,0) 'E0' with g "E" _ .;  g=g * .5'e'_ % 2
0052 do j=0  while h>9;      m.j= h;              h= h%2 + 1;    end  /*j*/
0053 do k=j+5  to 0  by -1;  numeric digits m.k;  g= (g+x/g)*.5; end  /*k*/;   return g
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                50
002 d                50
003 m.               50 52
004 h                50 52
005 k                48 53
006 z                43 44
007 k                44
008 y                24
009 z                25
010 NORMAL.10        
011 NORMAL.11        
012 NORMAL.12        
013 NORMAL.13        
014 NORMAL.14        
015 NORMAL.15        
016 NORMAL.16        
017 NORMAL.17        
018 NORMAL.18        
019 NORMAL.19        
020 NORMAL.20        
021 NORMAL.21        
022 NORMAL.22        
023 g                51 51 53
024 j                52
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @using_radius    -> newV1            5
002 _                -> newV2            43 44 47 48 51
