-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:08
-------------------------------------------------------------------------
0001 /*REXX program demonstrates a  method  for  catamorphism  for some simple functions.    */
0002 @list= 1 2 3 4 5 6 7 8 9 10
0003 say 'list:'     fold(@list,  "list")
0004 say ' sum:'     fold(@list,  "+"   )
0005 say 'prod:'     fold(@list,  "*"   )
0006 say ' cat:'     fold(@list,  "||"  )
0007 say ' min:'     fold(@list,  "min" )
0008 say ' max:'     fold(@list,  "max" )
0009 say ' avg:'     fold(@list,  "avg" )
0010 say ' GCD:'     fold(@list,  "GCD" )
0011 say ' LCM:'     fold(@list,  "LCM" )
0012 exit                                             /*stick a fork in it,  we're all done. */
0013 /*──────────────────────────────────────────────────────────────────────────────────────*/
0014 fold: procedure;  parse arg z;  arg ,f;         z = space(z);      BIFs= 'MIN MAX LCM GCD'
0015 za= translate(z, f, ' ');                 zf= f"("translate(z, ',' , " ")')'
0016 if f== '+' | f=="*"       then interpret  "return"  za
0017 if f== '||'               then return  space(z, 0)
0018 if f== 'AVG'              then interpret  "return"  fold(z, '+')    "/"    words(z)
0019 if wordpos(f, BIFs)\==0   then interpret  "return"  zf
0020 if f=='LIST' | f=="SHOW"  then return z
0021 return 'illegal function:'     arg(2)
0022 /*──────────────────────────────────────────────────────────────────────────────────────*/
0023 GCD:  procedure;  $=;                          do j=1  for arg();    $= $ arg(j)
0024 end   /*j*/
0025 parse var $ x z .;    if x=0  then x= z                  /* [↑] build an arg list.*/
0026 x= abs(x)
0027 do k=2  to words($);  y= abs( word($, k));   if y=0  then iterate
0028 do until _=0;       _= x // y;      x= y;     y= _
0029 end   /*until*/
0030 end   /*k*/
0031 return x
0032 /*──────────────────────────────────────────────────────────────────────────────────────*/
0033 LCM:  procedure;  $=;    do j=1  for arg();     $= $ arg(j)
0034 end   /*j*/
0035 x= abs(word($, 1))                                       /* [↑] build an arg list.*/
0036 do k=2  to words($);   != abs(word($, k));  if !=0  then return 0
0037 x= x*!  /  GCD(x, !)                  /*GCD does the heavy work*/
0038 end   /*k*/
0039 return x
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                25 25 26 28 35 37
002 z                25
003 k                27 36
004 y                27 28
005 until            28
006 j                33
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @list            -> newV1            2
002 $                -> newV2            23 23 25 33 33
003 _                -> newV3            28
004 !                -> newV4            36
