-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:22
-------------------------------------------------------------------------
0001 /*REXX program does numerical integration using an N─point Gauss─Legendre quadrature rule.   */
0002 pi= pi();     digs= length(pi) - length(.);          numeric digits digs;       reps= digs % 2
0003 !.= .;        b= 3;        a= -b;       bma= b - a;          bmaH= bma / 2;     tiny= '1e-'digs
0004 trueV= exp(b)-exp(a);                   bpa= b + a;          bpaH= bpa / 2
0005 hdr= 'iterate value       (with '   digs   " decimal digits being used)"
0006 say ' step '  center(hdr, digs+3)    '  difference'                  /*show hdr*/
0007 sep='──────'  copies("─", digs+3)    '─────────────';      say sep   /*  "  sep*/
0008 
0009 do #=1  until dif>0;  p0z= 1;  p0.1= 1;  p1z= 2;  p1.1= 1;  p1.2= 0;  ##= # + .5;  r.= 0
0010 /*█*/   do k=2  to #;  km= k - 1
0011 /*█*/                     do y=1  for p1z;   T.y= p1.y;                           end  /*y*/
0012 /*█*/   T.y= 0;  TT.= 0;          do L=1  for p0z;   _= L + 2;   TT._= p0.L;      end  /*L*/
0013 /*█*/   kkm= k + km;      do j=1  for p1z  +1;       T.j= (kkm*T.j - km*TT.j)/k;  end  /*j*/
0014 /*█*/   p0z= p1z;         do n=1  for p0z;           p0.n= p1.n                ;  end  /*n*/
0015 /*█*/   p1z= p1z + 1;     do p=1  for p1z;           p1.p= T.p                 ;  end  /*p*/
0016 /*█*/   end   /*k*/
0017 /*▓*/       do !=1  for #;             x= cos( pi * (! - .25)  /  ## )
0018 /*▓*/           /*░*/   do reps  until abs(dx) <= tiny
0019 /*▓*/           /*░*/   f= p1.1;  df= 0;   do u=2  to p1z; df= f +  x*df
0020 /*▓*/           /*░*/                                       f= p1.u +x*f
0021 /*▓*/           /*░*/                      end   /*u*/
0022 /*▓*/           /*░*/   dx= f / df;   x= x - dx
0023 /*▓*/           /*░*/   end             /*reps ···*/
0024 /*▓*/       r.1.!= x
0025 /*▓*/       r.2.!= 2 / ( (1 - x*x) * df*df)
0026 /*▓*/       end   /*!*/
0027 $= 0
0028 /*▒*/ do m=1  for #;   $=$ + r.2.m * exp(bpaH + r.1.m*bmaH);    end  /*m*/
0029 z= bmaH * $                                                    /*calculate target value (Z)*/
0030 dif= z - trueV;            z= format(z, 3, digs - 2)           /*    "     difference.     */
0031 Ndif= translate( format(dif, 3, 4, 3, 0),  'e',  "E")
0032 if #\==1  then  say center(#, 6)      z' '      Ndif           /*no display if not computed*/
0033 end   /*#*/
0034 
0035 say sep;  xdif= compare( strip(z), trueV);                       say right("↑", 6 + 1 + xdif)
0036 say  left('', 6 + 1)      trueV         " {exact value}";        say
0037 say 'Using '      digs      " digit precision, the" ,
0038 'N-point Gauss─Legendre quadrature (GLQ) had an accuracy of '      xdif-2       " digits."
0039 exit 0                                                /*stick a fork in it,  we're all done. */
0040 /*───────────────────────────────────────────────────────────────────────────────────────────*/
0041 e:   return 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759,
0042 ||457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794
0043 /*───────────────────────────────────────────────────────────────────────────────────────────*/
0044 pi:  return 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899,
0045 ||862803482534211706798214808651328230664709384460955058223172535940812848111745028410270194
0046 /*───────────────────────────────────────────────────────────────────────────────────────────*/
0047 cos: procedure  expose !.; parse arg x;   if !.x\==.  then return !.x;   _= 1;   z=1;  y= x*x
0048 do k=2  by 2  until p==z; p=z; _= -_*y/(k*(k-1)); z=z+_; end;  !.x=z;  return z
0049 /*───────────────────────────────────────────────────────────────────────────────────────────*/
0050 exp: procedure; parse arg x; ix= x % 1;  if abs(x-ix)>.5  then ix= ix + sign(x); x= x-ix;  z= 1
0051 _=1;  do j=1  until p==z; p=z;  _= _*x/j;  z= z+_;   end;    return z * e()**ix
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                50 50
002 ix               50 50
003 z                50 51
004 j                51
005 p                51
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 !.               -> newV1.           3 48
002 ##               -> newV2            9
003 #                -> newV3            9
004 _                -> newV4            12 47 48 51 51
005 !                -> newV5            17
006 $                -> newV6            27 28
