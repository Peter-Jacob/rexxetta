-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:09
-------------------------------------------------------------------------
0001 /*REXX program  calculates and displays  values of  various  continued fractions.       */
0002 parse arg terms digs .
0003 if terms=='' | terms==","  then terms=500
0004 if  digs=='' |  digs==","  then  digs=100
0005 numeric digits digs                              /*use  100  decimal digits for display.*/
0006 b.=1                                             /*omitted ß terms are assumed to be  1.*/
0007 /*══════════════════════════════════════════════════════════════════════════════════════*/
0008 a.=2;                                                           call tell '√2',      cf(1)
0009 /*══════════════════════════════════════════════════════════════════════════════════════*/
0010 a.=1;  do N=2  by  2  to terms; a.N=2; end;                     call tell '√3',      cf(1)     /*also:  2∙sin(π/3) */
0011 /*══════════════════════════════════════════════════════════════════════════════════════*/
0012 a.=2                  /*              ___ */
0013 do N=2  to 17   /*generalized  √ N  */
0014 b.=N-1;                          NN=right(N, 2);          call tell 'gen √'NN, cf(1)
0015 end   /*N*/
0016 /*══════════════════════════════════════════════════════════════════════════════════════*/
0017 a.=2;   b.=-1/2;                                                call tell 'gen √ ½', cf(1)
0018 /*══════════════════════════════════════════════════════════════════════════════════════*/
0019 do j=1 for terms; a.j=j;  if j>1   then b.j=a.p; p=j; end;    call tell 'e',       cf(2)
0020 /*══════════════════════════════════════════════════════════════════════════════════════*/
0021 a.=1;                                                           call tell 'φ, phi',  cf(1)
0022 /*══════════════════════════════════════════════════════════════════════════════════════*/
0023 a.=1;    do j=1 for terms;  if j//2  then a.j=j;        end;    call tell 'tan(1)',  cf(1)
0024 /*══════════════════════════════════════════════════════════════════════════════════════*/
0025 do j=1 for terms;                a.j=2*j+1;    end;    call tell 'coth(1)', cf(1)
0026 /*══════════════════════════════════════════════════════════════════════════════════════*/
0027 do j=1 for terms;                a.j=4*j+2;    end;    call tell 'coth(½)', cf(2)    /*also:  [e+1]÷[e-1] */
0028 /*══════════════════════════════════════════════════════════════════════════════════════*/
0029 terms=100000
0030 a.=6;    do j=1  for terms;  b.j=(2*j-1)**2;            end;    call tell 'π, pi',   cf(3)
0031 exit                                             /*stick a fork in it,  we're all done. */
0032 /*──────────────────────────────────────────────────────────────────────────────────────*/
0033 cf:      procedure expose a. b. terms;  parse arg C;     !=0;    numeric digits 9+digits()
0034 do k=terms  by -1  for terms;  d=a.k+!;  !=b.k/d
0035 end   /*k*/
0036 return !+C
0037 /*──────────────────────────────────────────────────────────────────────────────────────*/
0038 tell:    parse arg ?,v;   $=left(format(v)/1,1+digits());    w=50    /*50 bytes of terms*/
0039 aT=;     do k=1;  _=space(aT a.k);  if length(_)>w  then leave;  aT=_;  end /*k*/
0040 bT=;     do k=1;  _=space(bT b.k);  if length(_)>w  then leave;  bT=_;  end /*k*/
0041 say right(?,8)   "="    $     '  α terms='aT  ...
0042 if b.1\==1  then say right("",12+digits())     '  ß terms='bT  ...
0043 a=;   b.=1;  return       /*only 50 bytes of  α & ß terms  ↑   are displayed.  */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 v                38
002 w                38
003 aT               39 39
004 k                39 40
005 bT               40 40
006 a                43
007 b.               43
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 !                -> newV1            33 34
002 ?                -> newV2            38
003 $                -> newV3            38
004 _                -> newV4            39 40
