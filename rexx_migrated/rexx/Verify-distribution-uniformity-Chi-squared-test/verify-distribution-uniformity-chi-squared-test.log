-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:35
-------------------------------------------------------------------------
0001 /*REXX program performs a chi─squared test to verify a given distribution is uniform.   */
0002 numeric digits length( pi() )  - length(.)       /*enough decimal digs for calculations.*/
0003 @.=;                                        @.1= 199809 200665 199607 200270 199649
0004 @.2= 522573 244456 139979  71531  21461
0005 do s=1  while @.s\=='';  call uTest @.s  /*invoke  uTest with a data set of #'s.*/
0006 end   /*s*/
0007 exit                                             /*stick a fork in it,  we're all done. */
0008 /*──────────────────────────────────────────────────────────────────────────────────────*/
0009 !:      procedure; parse arg x;  p=1;    do j=2  to x;   p= p*j;   end  /*j*/;    return p
0010 chi2p:  procedure;  parse arg dof, distance;       return gammaI( dof/2,  distance/2 )
0011 f:      parse arg t;   if t=0  then return 0;      return t ** (a-1)    *    exp(-t)
0012 e:      e =2.718281828459045235360287471352662497757247093699959574966967627724; return e
0013 pi:     pi=3.141592653589793238462643383279502884197169399375105820974944592308; return pi
0014 /*──────────────────────────────────────────────────────────────────────────────────────*/
0015 !!:     procedure; parse arg x;                   if x<2  then return 1;    p= x
0016 do k=2+x//2  to x-1  by 2;   p= p*k;   end  /*k*/;          return p
0017 /*──────────────────────────────────────────────────────────────────────────────────────*/
0018 chi2ud: procedure: parse arg ds; sum=0;                       expect= 0
0019 do j=1  for words(ds); expect= expect + word(ds, j)
0020 end   /*j*/
0021 expect = expect / words(ds)
0022 do k=1  for words(ds)
0023 sum= sum   +   (word(ds, k) - expect) **2
0024 end   /*k*/
0025 return sum / expect
0026 /*──────────────────────────────────────────────────────────────────────────────────────*/
0027 exp:    procedure; parse arg x; ix= x%1;  if abs(x-ix)>.5  then ix= ix + sign(x);  x= x-ix
0028 z=1; _=1; w=z;    do j=1;  _= _*x/j;  z= (z + _)/1;  if z==w  then leave;      w=z
0029 end  /*j*/;         if z\==0  then z= z * e()**ix;      return z
0030 /*──────────────────────────────────────────────────────────────────────────────────────*/
0031 gamma:  procedure; parse arg x; if datatype(x, 'W')  then return !(x-1) /*Int?  Use fact*/
0032 n= trunc(x)                     /*at this point, X is pos and a multiple of 1/2.*/
0033 d= !!(n+n - 1)                  /*compute the double factorial of:    2*n - 1.  */
0034 if n//2  then p= -1             /*if  N  is  odd,   then use a negative unity.  */
0035 else p=  1             /*if  N  is even,   then use a positive unity.  */
0036 if x>0   then return p * d * sqrt(pi()) / (2**n)
0037 return p * (2**n) * sqrt(pi()) / d
0038 /*──────────────────────────────────────────────────────────────────────────────────────*/
0039 gammaI: procedure; parse arg a,x;  y= a-1;   do  while f(y)*(x-y) > 2e-8 & y<x;  y= y + .4
0040 end  /*while*/
0041 y= min(x, y)
0042 return 1   -   simp38(0, y,   y / 0.015 / gamma(a-1) % 1)
0043 /*──────────────────────────────────────────────────────────────────────────────────────*/
0044 simp38: procedure; parse arg a, b, n;                h= (b-a) / n;        h1= h / 3
0045 sum= f(a) + f(b)
0046 do j=3*n-1   by -1   while j>0
0047 if j//3 == 0  then sum= sum   +   2 * f(a + h1*j)
0048 else sum= sum   +   3 * f(a + h1*j)
0049 end   /*j*/
0050 return h * sum / 8
0051 /*──────────────────────────────────────────────────────────────────────────────────────*/
0052 sqrt:   procedure; parse arg x;  if x=0  then return 0; d=digits(); numeric digits; h= d+6
0053 numeric form; m.=9; parse value format(x,2,1,,0) 'E0' with g "E" _ .;g=g *.5'e'_%2
0054 do j=0  while h>9;      m.j=h;               h=h%2+1;       end  /*j*/
0055 do k=j+5  to 0  by -1;  numeric digits m.k;  g=(g+x/g)*.5;  end  /*k*/; return g
0056 /*──────────────────────────────────────────────────────────────────────────────────────*/
0057 uTest:  procedure; parse arg dset;  sum= 0;   pad= left('', 11);      sigLev= 1/20  /*5%*/
0058 say;   say '     '   center(" Uniform distribution test ", 75, '═')
0059 #= words(dset);                                              sigPC= sigLev*100/1
0060 do j=1  for #;      sum= sum  +  word(dset, j)
0061 end   /*j*/
0062 say pad "                  dataset: "  dset
0063 say pad "                  samples: "  sum
0064 say pad "               categories: "  #
0065 say pad "       degrees of freedom: "  # - 1
0066 dist= chi2ud(dset)
0067 P= chi2p(# - 1,  dist)
0068 sig = (abs(P) < dist * sigLev)
0069 say pad "significant at " sigPC'%  level? '  word('no yes',    sig  + 1)
0070 say pad "   is the dataset uniform? "        word('no yes', (\(sig))+ 1)
0071 return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 dset             57
002 sum              57 60
003 pad              57
004 sigLev           57
005 sigPC            59
006 j                60
007 dist             66
008 P                67
009 sig              68
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           3 3 4
002 _                -> newV2            28 28 53
003 #                -> newV3            59
