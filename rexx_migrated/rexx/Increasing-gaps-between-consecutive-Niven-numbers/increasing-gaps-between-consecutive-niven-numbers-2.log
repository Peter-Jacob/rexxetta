-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:17
-------------------------------------------------------------------------
0001 /*REXX program finds and displays the largest gap between  Niven  numbers (up to LIMIT).*/
0002 parse arg lim .                                  /*obtain optional arguments from the CL*/
0003 if lim=='' | lim==','  then lim= 1000000000000   /*Not specified?  Then use the default.*/
0004 numeric digits 2 + max(8, length(lim) )          /*enable the use of any sized numbers. */
0005 gap= 0;                     old= 0               /*initialize (largest) gap; old Niven #*/
0006 @gsa= 'gap starts at Niven #'
0007 call tell center('gap size', 12)       center(@gsa "index", 29)          center(@gsa, 29)
0008 call tell copies('═'       , 12)       copies('═'         , 29)          copies('═' , 29)
0009 @.= 0                                            /*set all values to zero for chunk sums*/
0010 do j=1  for 99999                   /*pre─compute sums for #a up to 5 digs.*/
0011 parse var  j  1  sum  2  q          /*use the first decimal digit for  SUM.*/
0012 do  while  q\=='';    parse var  q    x  2  q;          sum= sum + x
0013 end   /*while*/            /*do sum of digits the hard way for now*/
0014 @.j= sum                            /*assume a sum for a particular number.*/
0015 if j>9999 then iterate              /*if  J  has five digits or more, skip.*/
0016 do zz= length(j)+1  to 4   /*handle all  J's  with leading zeros. */
0017 jz= right(j, zz, 0)        /*also add leading zeros from some J's.*/
0018 if @.jz==0  then @.jz= sum /*assign a sum to  000xx  for instance.*/
0019 end   /*zz*/
0020 end   /*j*/
0021 #= 0                                             /*#:  is the index of a Niven number.  */
0022 do n=1                                       /*◄───── let's go Niven number hunting.*/
0023 parse var n q1 +5 q2 +5 q3 +5 q4 +5 q4 +5 q6 /*break apart  N  into 5─digit chunks. */
0024 sum= @.q1 + @.q2 + @.q3 + @.q4 + @.q5 + @.q6 /*add the 5─digit chunks to compute sum*/
0025 if n//sum > 0  then iterate                  /*is N not divisible by its sum?  Skip.*/
0026 #= # + 1                                     /*bump the  index  of the Niven number.*/
0027 if n-old<=gap  then do; old= n; iterate; end /*Is gap not bigger?  Then keep looking*/
0028 gap= n - old;           old= n               /*We found a bigger gap; define new gap*/
0029 idx= max(1, #-1);       san= max(1, n-gap)   /*handle special case of the first gap.*/
0030 call tell right(commas(gap),  7)left('', 5), /*center right─justified Niven gap size*/
0031 right(commas(idx), 25)left('', 4), /*   "     "       "     Niven num idx.*/
0032 right(commas(san), 25)             /*   "     "       "       "   number. */
0033 if n >= lim  then leave                      /*have we exceeded the (huge)  LIMit ? */
0034 end   /*n*/
0035 exit                                             /*stick a fork in it,  we're all done. */
0036 /*──────────────────────────────────────────────────────────────────────────────────────*/
0037 commas:  parse arg _;  do c=length(_)-3  to 1  by -3; _=insert(',', _, c); end;   return _
0038 tell:    say arg(1);   return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 c                37
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @gsa             -> newV1            6
002 @.               -> newV2.           9 14 18
003 #                -> newV3            21 26
004 _                -> newV4            37 37
