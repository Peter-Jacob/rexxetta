-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:25
-------------------------------------------------------------------------
0001 /*REXX program solves the problem of Apollonius, named after the Greek Apollonius of    */
0002 /*────────────────────────────────────── Perga [Pergæus]   (circa 262 BCE ──► 190 BCE). */
0003 numeric digits 15;                x1= 0;        y1= 0;         r1= 1
0004 x2= 4;        y2= 0;         r2= 1
0005 x3= 2;        y3= 4;         r3= 2
0006 call tell  'external tangent:   ',       Apollonius( 1,  1,  1)
0007 call tell  'internal tangent:   ',       Apollonius(-1, -1, -1)
0008 exit                                             /*stick a fork in it,  we're all done. */
0009 /*──────────────────────────────────────────────────────────────────────────────────────*/
0010 Apollonius: parse arg s1,s2,s3                   /*could be internal or external tangent*/
0011 numeric digits digits() * 3                /*reduce rounding with thrice digits.  */
0012 va= x2*2     - x1*2;                        vb= y2*2 - y1*2
0013 vc= x1**2    - x2**2 + y1**2 - y2**2 - r1**2 + r2**2
0014 vd= s2*r2*2  - s1*r1*2;                     ve= x3*2 - x2*2;   vf= y3*2    - y2*2
0015 vg= x2**2    - x3**2 + y2**2 - y3**2 - r2**2 + r3**2;          vh= s3*r3*2 - s2*r2*2
0016 vj= vb/va;               vk= vc/va;         vm=  vd/va;        vn= vf/ve   - vj
0017 vp= vg/ve    - vk;       vr= vh/ve - vm;    p = -vp/vn;        q = vr/vn
0018 m =  -vj*p   - vk;       n = vm - vj*q
0019 a =  n**2 + q**2   - 1
0020 b =  (m*n    - n*x1    + p*q    - q*y1   + s1*r1)  * 2
0021 c =  x1**2   + y1**2   + m**2   - r1**2  + p**2    - (m*x1 + p*y1)  * 2
0022 $r= (-b - sqrt(b**2 - a*c*4) ) / (a+a)
0023 return  (m + n*$r)   (p + q*$r)   ($r)                       /*return 3 arguments.*/
0024 /*──────────────────────────────────────────────────────────────────────────────────────*/
0025 sqrt: procedure; parse arg x;  if x=0  then return 0;  d=digits();  h=d+6;  numeric digits
0026 m.=9; numeric form; parse value format(x,2,1,,0) 'E0'  with  g 'E' _ .; g=g*.5'e'_%2
0027 do j=0  while h>9;     m.j=h;              h= h % 2  +  1;  end  /*j*/
0028 do k=j+5  to 0  by -1; numeric digits m.k; g=(g+x/g) * .5;  end  /*k*/;  return g
0029 /*──────────────────────────────────────────────────────────────────────────────────────*/
0030 tell: parse arg _,a b c; w=digits()+4; say _ left(a/1,w%2) left(b/1,w) left(c/1,w); return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 a                30
002 b                30
003 c                30
004 w                30
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $r               -> newV1            22
002 _                -> newV2            26 30
