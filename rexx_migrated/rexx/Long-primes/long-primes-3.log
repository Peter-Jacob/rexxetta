-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:19
-------------------------------------------------------------------------
0001 /*REXX pgm calculates/displays base ten  long primes  (AKA golden primes, proper primes,*/
0002 /*───────────────────── maximal period primes, long period primes, full reptend primes).*/
0003 parse arg a                                      /*obtain optional argument from the CL.*/
0004 if a='' | a=","  then a= '500 -500 -1000 -2000 -4000 -8000 -16000' ,  /*Not specified?  */
0005 '-32000 -64000 -128000 -512000 -1024000'     /*Then use default*/
0006 m=0;            aa= words(a)                     /* [↑]  two list types of low primes.  */
0007 do j=1  for aa;   m= max(m, abs(word(a, j))) /*find the maximum argument in the list*/
0008 end   /*j*/
0009 call genP                                        /*go and generate some primes.         */
0010 do k=1  for aa;           H= word(a, k)      /*step through the list of high limits.*/
0011 neg= H<1                                     /*used as an indicator to display count*/
0012 H= abs(H)                                    /*obtain the absolute value of  H.     */
0013 $=                                           /*the list of  long primes   (so far). */
0014 do j=7  to H  by 2
0015 if \@.j               then iterate        /*Is  J  not a prime?    Then skip it. */
0016 if .len(j) + 1 \== j  then iterate        /*Period length wrong?     "    "   "  */
0017 $= $ j                                    /*add the   long prime   to the $ list.*/
0018 end   /*j*/                               /* [↑]  some pretty weak prime testing.*/
0019 say
0020 if neg  then      say 'number of long primes ≤ '    H     " is: "     words($)
0021 else do;  say   'list of long primes ≤ '    H":";         say strip($);    end
0022 end      /*k*/
0023 exit                                             /*stick a fork in it,  we're all done. */
0024 /*──────────────────────────────────────────────────────────────────────────────────────*/
0025 genP: @.=0; @.2=1; @.3=1; @.5=1; @.7=1; @.11=1;   !.=0; !.1=2; !.2=3; !.3=5; !.4=7; !.5=11
0026 #= 5                                       /*the number of primes  (so far).      */
0027 do g=!.#+2  by 2  until g>=m           /*gen enough primes to satisfy max  A. */
0028 if @.g\==0  then iterate               /*Is it not a prime?     Then skip it. */
0029 do d=2  until !.d**2>g          /*only divide up to square root of  X. */
0030 if g//!.d==0  then iterate g    /*Divisible?   Then skip this integer. */
0031 end   /*d*/                     /* [↓]  a spanking new prime was found.*/
0032 #= #+1               @.g= 1;  !.#= g   /*bump P counter; assign P, add to P's.*/
0033 end            /*g*/
0034 return
0035 /*──────────────────────────────────────────────────────────────────────────────────────*/
0036 .len: procedure; parse arg x;  r=1;   do x;                   r= 10*r // x;     end  /*x*/
0037 rr=r;   do p=1  until r==rr;    r= 10*r // x;     end  /*p*/
0038 return p
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                36
002 r                36 36 37
003 rr               37
004 p                37
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           25 25 25 25 25
002 !.               -> newV2.           25 25 25 25 25 25 32
003 $                -> newV3            13 17
004 #                -> newV4            26 32
