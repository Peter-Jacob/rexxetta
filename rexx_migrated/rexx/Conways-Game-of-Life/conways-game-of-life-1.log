-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:09
-------------------------------------------------------------------------
0001 /*REXX program runs and displays the Conway's game of life, it stops after  N  repeats. */
0002 signal on halt                                   /*handle a  cell growth  interruptus.  */
0003 parse arg peeps  '(' rows  cols  empty  life!  clearScreen  repeats  generations .
0004 rows =        p(rows               3)     /*the maximum number of cell  rows.    */
0005 cols =        p(cols               3)     /* "     "       "    "   "  columns.  */
0006 emp = pickChar(empty        'blank')     /*an empty cell character  (glyph).    */
0007 clearScr =        p(clearScreen        0)     /* "1"   indicates to clear the screen.*/
0008 life! = pickChar(life!            '☼')     /*the gylph kinda looks like an amoeba.*/
0009 reps =        p(repeats            2)     /*stop pgm  if there are  two  repeats.*/
0010 generations =        p(generations      100)     /*the number of  generations  allowed. */
0011 sw= max(linesize() - 1,  cols)                   /*usable screen width for the display. */
0012 #reps= 0;        $.= emp                         /*the universe is new,  ··· and barren.*/
0013 gens=abs(generations)                            /*used for a  programming  convenience.*/
0014 x= space(peeps); upper x                         /*elide superfluous spaces; uppercase. */
0015 if x==''         then x= "BLINKER"               /*if nothing specified,  use  BLINKER. */
0016 if x=='BLINKER'  then x= "2,1 2,2 2,3"
0017 if x=='OCTAGON'  then x= "1,5 1,6 2,4 2,7 3,3 3,8 4,2 4,9 5,2 5,9 6,3 6,8 7,4 7,7 8,5 8,6"
0018 call assign.                                     /*assign the initial state of all cells*/
0019 call showCells                                   /*show the  initial state of the cells.*/
0020 do life=1  for gens;      call assign@      /*construct  next  generation of cells.*/
0021 if generations>0 | life==gens  then call showCells    /*should cells be displayed? */
0022 end   /*life*/                              /* [↑]  cell colony grows, lives, dies.*/
0023 exit                                             /*stick a fork in it,  we're all done. */
0024 /*──────────────────────────────────────────────────────────────────────────────────────*/
0025 showCells: if clearScr  then 'CLS'               /*  ◄───  change 'command' for your OS.*/
0026 call showRows                         /*show the rows in the proper order.   */
0027 say right(copies('▒', sw)  life, sw)  /*show a fence between the generations.*/
0028 if _==''  then exit                   /*if there's no life, then stop the run*/
0029 if !._    then #reps= #reps + 1       /*we detected a repeated cell pattern. */
0030 !._= 1                                /*existence  state and compare  later. */
0031 if reps\==0 & #reps<=reps then return /*so far, so good,   regarding repeats.*/
0032 say
0033 say center('"Life" repeated itself' reps "times, simulation has ended.",sw,'▒')
0034 exit                                  /*stick a fork in it,  we're all done. */
0035 /*───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────*/
0036 $:         parse arg _row,_col;                    return $._row._col==life!
0037 assign$:   do r=1  for rows;   do c=1  for cols;   $.r.c= @.r.c;                                    end;    end;       return
0038 assign.:   do while x\==''; parse var x r "," c x; $.r.c=life!; rows=max(rows,r); cols=max(cols,c); end; life=0; !.=0; return
0039 assign?:   ?=$.r.c; n=neighbors(); if ?==emp then do;if n==3 then ?=life!; end; else if n<2 | n>3 then ?=emp; @.r.c=?; return
0040 assign@:   @.=emp;      do r=1  for rows;  do c=1  for cols;  call assign?;  end;  end;            call assign$;       return
0041 halt:      say;         say "REXX program  (Conway's Life)  halted.";    say;      exit 0
0042 neighbors: return $(r-1,c-1)  +  $(r-1,c)  +  $(r-1,c+1)  +  $(r,c-1)  +  $(r,c+1)  +  $(r+1,c-1)  +  $(r+1,c)  +  $(r+1,c+1)
0043 p:         return word(arg(1), 1)
0044 pickChar:  _=p(arg(1)); arg u .; if u=='BLANK' then _=" "; L=length(_); if L==3 then _=d2c(_); if L==2 then _=x2c(_);  return _
0045 showRows:  _=; do r=rows by -1 for rows; z=; do c=1 for cols; z=z||$.r.c; end; z=strip(z,'T',emp); say z; _=_||z; end; return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                38 38
002 r                38 40 45
003 c                38 40 45
004 rows             38
005 cols             38
006 life             38
007 n                39
008 L                44
009 z                45 45 45
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #reps            -> newV1            12 29
002 _row             -> newV2            36
003 _col             -> newV3            36
004 $.               -> newV4.           12 37 38
005 !.               -> newV5.           30 38
006 @.               -> newV6.           39
007 ?                -> newV7            39
008 _                -> newV8            44 44 44 45
