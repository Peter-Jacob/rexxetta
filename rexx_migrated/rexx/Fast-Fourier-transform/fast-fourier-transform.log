-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:13
-------------------------------------------------------------------------
0001 /*REXX program performs a  fast Fourier transform  (FFT)  on a set of  complex numbers. */
0002 numeric digits length( pi() )   -  length(.)     /*limited by the  PI  function result. */
0003 arg data                                         /*ARG verb uppercases the DATA from CL.*/
0004 if data=''  then data= 1 1 1 1 0                 /*Not specified?  Then use the default.*/
0005 size=words(data);       pad= left('', 5)         /*PAD:  for indenting and padding SAYs.*/
0006 do p=0  until  2**p>=size         ;   end      /*number of args exactly a power of 2? */
0007 do j=size+1 to 2**p;  data= data 0;   end      /*add zeroes to DATA 'til a power of 2.*/
0008 size= words(data);      ph= p % 2   ;   call hdr         /*╔═══════════════════════════╗*/
0009 /* [↓] TRANSLATE allows I & J*/  /*║ Numbers in data can be in ║*/
0010 do j=0  for size                                /*║ seven formats:  real      ║*/
0011 _= translate( word(data, j+1), 'J', "I")        /*║                 real,imag ║*/
0012 parse  var  _    #.1.j  ''  $  1     "," #.2.j  /*║                     ,imag ║*/
0013 if $=='J'  then parse var #.1.j #2.j "J" #.1.j  /*║                      nnnJ ║*/
0014 /*║                      nnnj ║*/
0015 do m=1  for  2;      #.m.j= word(#.m.j 0, 1)  /*║                      nnnI ║*/
0016 end   /*m*/          /*omitted part?  [↑] */  /*║                      nnni ║*/
0017 /*╚═══════════════════════════╝*/
0018 say pad ' FFT   in '     center(j+1, 7)     pad    fmt(#.1.j)     fmt(#.2.j, "i")
0019 end     /*j*/
0020 say
0021 tran= pi()*2 / 2**p;     !.=0;    hp= 2**p %2;       A= 2**(p-ph);      ptr= A;     dbl= 1
0022 say
0023 do p-ph;        halfPtr=ptr % 2
0024 do i=halfPtr  by ptr  to A-halfPtr;  _= i - halfPtr;   !.i= !._ + dbl
0025 end   /*i*/
0026 ptr= halfPtr;                     dbl= dbl + dbl
0027 end   /*p-ph*/
0028 
0029 do j=0  to 2**p%4;  cmp.j= cos(j*tran);      _= hp - j;            cmp._= -cmp.j
0030 _= hp + j;            cmp._= -cmp.j
0031 end  /*j*/
0032 B= 2**ph
0033 do i=0      for A;            q= i * B
0034 do j=0  for B;   h=q+j;   _= !.j*B+!.i;    if _<=h  then iterate
0035 parse value  #.1._  #.1.h  #.2._  #.2.h    with    #.1.h  #.1._  #.2.h  #.2._
0036 end   /*j*/                              /* [↑]  swap  two sets of values. */
0037 end       /*i*/
0038 dbl= 1
0039 do p                    ;       w= hp % dbl
0040 do k=0   for dbl      ;      Lb= w * k            ;          Lh= Lb + 2**p % 4
0041 do j=0 for w        ;       a= j * dbl * 2 + k  ;           b=  a + dbl
0042 r= #.1.a;  i= #.2.a ;      c1= cmp.Lb * #.1.b   ;          c4= cmp.Lb * #.2.b
0043 c2= cmp.Lh * #.2.b   ;          c3= cmp.Lh * #.1.b
0044 #.1.a= r + c1 - c2      ;       #.2.a= i + c3 + c4
0045 #.1.b= r - c1 + c2      ;       #.2.b= i - c3 - c4
0046 end     /*j*/
0047 end       /*k*/
0048 dbl= dbl + dbl
0049 end         /*p*/
0050 call hdr
0051 do z=0  for size
0052 say pad     " FFT  out "     center(z+1,7)    pad    fmt(#.1.z)    fmt(#.2.z,'j')
0053 end   /*z*/                             /*[↑] #s are shown with ≈20 dec. digits*/
0054 exit                                             /*stick a fork in it,  we're all done. */
0055 /*──────────────────────────────────────────────────────────────────────────────────────*/
0056 cos: procedure; parse arg x;  q= r2r(x)**2;      z=1;    _=1;   p=1   /*bare bones COS. */
0057 do k=2  by 2;  _=-_*q/(k*(k-1));  z=z+_;  if z=p  then return z;   p=z;  end  /*k*/
0058 /*──────────────────────────────────────────────────────────────────────────────────────*/
0059 fmt: procedure; parse arg y,j;          y= y/1   /*prettifies complex numbers for output*/
0060 if abs(y) < '1e-'digits() %4  then y= 0;    if y=0 & j\==''  then return ''
0061 dp= digits()%3;  y= format(y, dp%6+1, dp);  if pos(.,y)\==0  then y= strip(y, 'T', 0)
0062 y=  strip(y, 'T', .);                       return left(y || j, dp)
0063 /*──────────────────────────────────────────────────────────────────────────────────────*/
0064 hdr: _=pad '   data      num' pad "  real─part  " pad pad '         imaginary─part       '
0065 say _;   say translate(_,  " "copies('═', 256),  " "xrange());                 return
0066 /*──────────────────────────────────────────────────────────────────────────────────────*/
0067 pi:  return 3.1415926535897932384626433832795028841971693993751058209749445923078164062862
0068 r2r: return arg(1)  //  ( pi() * 2 )             /*reduce the radians to a unit circle. */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 y                59 59 60 61 61 62
002 j                59
003 dp               61
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #2.              -> newV1.           13
002 #.               -> newV2.           12 12 13 13 15 35 35 35 35 44 44 45 45
003 !.               -> newV3.           21 24
004 _                -> newV4            11 12 24 29 30 34 56 57
005 $                -> newV5            12
