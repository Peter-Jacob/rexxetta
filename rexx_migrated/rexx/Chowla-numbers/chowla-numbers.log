-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:08
-------------------------------------------------------------------------
0001 /*REXX program computes/displays chowla numbers (and may count primes & perfect numbers.*/
0002 parse arg LO HI .                                /*obtain optional arguments from the CL*/
0003 if LO=='' | LO==","  then LO=  1                 /*Not specified?  Then use the default.*/
0004 perf= LO<0;               LO= abs(LO)            /*Negative?  Then determine if perfect.*/
0005 if HI=='' | HI==","  then HI= LO                 /*Not specified?  Then use the default.*/
0006 prim= HI<0;               HI= abs(HI)            /*Negative?  Then determine if a prime.*/
0007 numeric digits max(9, length(HI) + 1 )           /*use enough decimal digits for   //   */
0008 w= length( commas(HI) )                          /*W:   used in aligning output numbers.*/
0009 tell= \(prim | perf)                             /*set boolean value for showing chowlas*/
0010 p= 0                                             /*the number of primes found  (so far).*/
0011 do j=LO  to HI;       #= chowla(j)          /*compute the  cholwa number  for  J.  */
0012 if tell  then say right('chowla('commas(j)")", w+9)    ' = '    right( commas(#), w)
0013 else if #==0  then if j>1  then p= p+1
0014 if perf  then if j-1==# & j>1  then say right(commas(j), w)   ' is a perfect number.'
0015 end   /*j*/
0016 
0017 if prim & \perf  then say 'number of primes found for the range '   commas(LO)    " to " ,
0018 commas(HI)        " (inclusive)  is: "   commas(p)
0019 exit                                             /*stick a fork in it,  we're all done. */
0020 /*──────────────────────────────────────────────────────────────────────────────────────*/
0021 chowla: procedure; parse arg x;         if x<2  then return 0;          odd= x // 2
0022 s=0                                      /* [↓]  use EVEN or ODD integers.   ___*/
0023 do k=2+odd  by 1+odd  while k*k<x    /*divide by all the integers up to √ X */
0024 if x//k==0  then  s=s + k + x%k      /*add the two divisors to the sum.     */
0025 end   /*k*/                          /* [↓]  adkust for square.          ___*/
0026 if k*k==x  then  s=s + k                 /*Was  X  a square?    If so, add  √ X */
0027 return s                                 /*return     "     "    "      "     " */
0028 /*──────────────────────────────────────────────────────────────────────────────────────*/
0029 commas: parse arg _;  do k=length(_)-3  to 1  by -3; _= insert(',', _, k); end;   return _
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 k                29
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #                -> newV1            11
002 _                -> newV2            29 29
