-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:18
-------------------------------------------------------------------------
0001 /*REXX pgm computes & display (unsigned) Stirling numbers of the 3rd kind (Lah numbers).*/
0002 parse arg lim .                                  /*obtain optional argument from the CL.*/
0003 if lim=='' | lim==","  then lim= 12              /*Not specified?  Then use the default.*/
0004 olim= lim                                        /*save     the original value of  LIM. */
0005 lim= abs(lim)                                    /*only use the absolute value of  LIM. */
0006 numeric digits max(9, 4*lim)                     /*(over) specify maximum number in grid*/
0007 max#.= 0
0008 !.=.
0009 @.=                                              /* [↓]  calculate values for the grid. */
0010 do   n=0  to  lim;   nm= n - 1
0011 do k=0  to  lim;   km= k - 1
0012 if k==1               then do;  @.n.k= !(n); call maxer; iterate;  end
0013 if k==n               then do;  @.n.k= 1   ;             iterate;  end
0014 if k>n | k==0 | n==0  then do;  @.n.k= 0   ;             iterate;  end
0015 @.n.k = (!(n) * !(nm)) % (!(k) * !(km)) % !(n-k)  /*calculate a # in the grid.*/
0016 call maxer                                        /*find    max #  "  "    "  */
0017 end   /*k*/
0018 end     /*n*/
0019 
0020 do k=0  for lim+1                        /*find max column width for each column*/
0021 max#.a= max#.a + length(max#.k)
0022 end   /*k*/
0023 /* [↓]  only show the maximum value ?  */
0024 w= length(max#.b)                                /*calculate max width of all numbers.  */
0025 if olim<0  then do;  say 'The maximum value  (which has '      w      " decimal digits):"
0026 say max#.b                  /*display maximum number in the grid.  */
0027 exit                        /*stick a fork in it,  we're all done. */
0028 end                              /* [↑]  the 100th row is when LIM is 99*/
0029 wi= max(3, length(lim+1) )                       /*the maximum width of the grid's index*/
0030 say 'row'  center('columns', max(9, max#.a + lim), '═')    /*display header of the grid.*/
0031 
0032 do r=0  for lim+1;   $=                  /* [↓]  display the grid to the term.  */
0033 do c=0  for lim+1  until c>=r          /*build a row of grid, 1 col at a time.*/
0034 $= $  right(@.r.c, length(max#.c) )    /*append a column to a row of the grid.*/
0035 end   /*c*/
0036 say right(r,wi)  strip(substr($,2), 'T') /*display a single row of the grid.    */
0037 end     /*r*/
0038 exit                                             /*stick a fork in it,  we're all done. */
0039 /*──────────────────────────────────────────────────────────────────────────────────────*/
0040 !: parse arg z; if !.z\==. then return !.z; !=1; do f=2  to z; !=!*f; end; !.z=!; return !
0041 maxer:   max#.k= max(max#.k, @.n.k);        max#.b= max(max#.b, @.n.k);           return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 z                40
002 f                40
003 max#.            41
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 !.               -> newV1.           8 40
002 @.               -> newV2.           9 12 13 14 15
003 $                -> newV3            32 34
004 !                -> newV4            40 40
