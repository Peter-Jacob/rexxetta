-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:12
-------------------------------------------------------------------------
0001 /*REXX program executes a  Markov  algorithm(s)  against  specified entries.            */
0002 parse arg low high .                             /*allows which  ruleset  to process.   */
0003 if  low=='' |  low==","  then  low=1             /*Not specified?  Then use the default.*/
0004 if high=='' | high==","  then high=6             /* "      "         "   "   "     "    */
0005 tellE= low<0;          tellR= high<0             /*flags: used to display file contents.*/
0006 call readEntry
0007 do j=abs(low)  to abs(high)       /*process each of these  rulesets.     */
0008 call readRules j                  /*read    a particular   ruleset.      */
0009 call execRules j                  /*execute "     "            "         */
0010 say 'result for ruleset'      j      "───►"      !.j
0011 end   /*j*/
0012 exit                                             /*stick a fork in it,  we're all done. */
0013 /*──────────────────────────────────────────────────────────────────────────────────────*/
0014 execRules: parse arg q .;           if tellE | tellR  then say      /*show a blank line?*/
0015 do f=1
0016 do k=1  while @.k\=='';      if left(@.k, 1)=='#' | @.k=''  then iterate
0017 parse var  @.k   a   ' ->'    b  /*obtain the  A  &  B  parts from rule.*/
0018 a=strip(a);      b=strip(b)      /*strip leading and/or trailing blanks.*/
0019 fullstop= left(b, 1)==.          /*is this a  "fullstop"  rule?   1≡yes */
0020 if fullstop  then b=substr(b, 2) /*purify the  B  part of the rule.     */
0021 old=!.q                          /*remember the value before the change.*/
0022 !.q=changestr(a, !.q, b)         /*implement the  ruleset  change.      */
0023 if fullstop   then if old\==!.q  then return          /*should we stop? */
0024 if old\==!.q  then iterate f     /*Has Entry changed?   Then start over.*/
0025 end   /*k*/
0026 return
0027 end     /*f*/
0028 return
0029 /*──────────────────────────────────────────────────────────────────────────────────────*/
0030 readEntry: eFID= 'MARKOV.ENT';     if tellE  then say               /*show a blank line?*/
0031 !.=                                   /*placeholder for all the test entries.*/
0032 do e=1  while lines(eFID)\==0  /*read the input file until End-Of-File*/
0033 !.e=linein(eFID);  if tellE  then say 'test entry'    e    "───►"    !.e
0034 end   /*e*/                    /* [↑]  read and maybe echo the entry. */
0035 return
0036 /*──────────────────────────────────────────────────────────────────────────────────────*/
0037 readRules: parse arg ? .;  rFID= 'MARKOV_R.'?;  if tellR  then say  /*show a blank line?*/
0038 @.=                                   /*placeholder for all the Markov rules.*/
0039 do r=1  while lines(rFID)\==0  /*read the input file until End-Of-File*/
0040 @.r=linein(rFID);  if tellR  then say 'ruleSet' ?"."left(r,4) '───►' @.r
0041 end   /*r*/                    /* [↑]  read and maybe echo the rule.  */
0042 return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 rFID             37
002 r                39
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           17 38 40
002 !.               -> newV2.           22 31 33
003 ?                -> newV3            37
