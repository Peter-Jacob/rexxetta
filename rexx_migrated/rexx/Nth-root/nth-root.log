-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:22
-------------------------------------------------------------------------
0001 /*REXX program calculates the  Nth root  of  X,  with  DIGS  (decimal digits) accuracy. */
0002 parse arg x root digs .                          /*obtain optional arguments from the CL*/
0003 if    x=='' |    x==","   then    x= 2           /*Not specified?  Then use the default.*/
0004 if root=='' | root==","   then root= 2           /* "       "        "   "   "      "   */
0005 if digs=='' | digs==","   then digs=65           /* "       "        "   "   "      "   */
0006 numeric digits digs                              /*set the  decimal digits  to   DIGS.  */
0007 say '       x = '    x                           /*echo the value of   X.               */
0008 say '    root = '    root                        /*  "   "    "    "   ROOT.            */
0009 say '  digits = '    digs                        /*  "   "    "    "   DIGS.            */
0010 say '  answer = '    root(x, root)               /*show the value of   ANSWER.          */
0011 exit                                             /*stick a fork in it,  we're all done. */
0012 /*──────────────────────────────────────────────────────────────────────────────────────*/
0013 root: procedure;  parse arg x 1 Ox, r 1 Or             /*arg1 ──► x & Ox, 2nd ──► r & Or*/
0014 if r==''  then r=2                               /*Was root specified?  Assume √. */
0015 if r=0    then return '[n/a]'                    /*oops-ay!  Can't do zeroth root.*/
0016 complex= x<0 & R//2==0                           /*will the result be complex?    */
0017 oDigs=digits()                                   /*get the current number of digs.*/
0018 if x=0 | r=1  then return x/1                    /*handle couple of special cases.*/
0019 dm=oDigs+5                                       /*we need a little guard room.   */
0020 r=abs(r);   x=abs(x)                             /*the absolute values of R and X.*/
0021 rm=r-1                                           /*just a fast version of  ROOT -1*/
0022 numeric form                                     /*take a good guess at the root─┐*/
0023 parse value format(x,2,1,,0) 'E0' with ? 'E' _ . /* ◄────────────────────────────┘*/
0024 g= (? / r'E'_ % r)  +  (x>1)                     /*kinda uses a crude "logarithm".*/
0025 d=5                                              /*start with five decimal digits.*/
0026 do until d==dm;   d=min(d+d,dm)             /*each time,  precision doubles. */
0027 numeric digits d                            /*tell REXX to use   D   digits. */
0028 old=-1                                      /*assume some kind of old guess. */
0029 do until old=g;   old=g              /*where da rubber meets da road─┐*/
0030 g=format((rm*g**r+x)/r/g**rm,, d-2)  /* ◄────── the root computation─┘*/
0031 end   /*until old=g*/                /*maybe until the cows come home.*/
0032 end          /*until d==dm*/                /*and wait for more cows to come.*/
0033 
0034 if g=0        then return 0                      /*in case the jillionth root = 0.*/
0035 if Or<0       then g=1/g                         /*root < 0 ?   Reciprocal it is! */
0036 if \complex   then g=g*sign(Ox)                  /*adjust the sign  (maybe).      */
0037 numeric digits oDigs                             /*reinstate the original digits. */
0038 return (g/1)  ||  left('j', complex)             /*normalize # to digs, append j ?*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                13 20
002 Ox               13
003 r                13 14 20
004 Or               13
005 complex          16
006 oDigs            17
007 dm               19
008 rm               21
009 NORMAL.9         
010 NORMAL.10        
011 NORMAL.11        
012 NORMAL.12        
013 NORMAL.13        
014 NORMAL.14        
015 NORMAL.15        
016 NORMAL.16        
017 NORMAL.17        
018 NORMAL.18        
019 NORMAL.19        
020 NORMAL.20        
021 NORMAL.21        
022 NORMAL.22        
023 g                24 30 35 36
024 d                25 26
025 until            26 29
026 old              28 29
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 ?                -> newV1            23
002 _                -> newV2            23
