-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:33
-------------------------------------------------------------------------
0001 /*REXX program counts and displays the number of textonyms that are in a dictionary file*/
0002 parse arg iFID .                                 /*obtain optional fileID from the C.L. */
0003 if iFID=='' | iFID=="," then iFID='UNIXDICT.TXT' /*Not specified?  Then use the default.*/
0004 @.= 0                                            /*the placeholder of digit combinations*/
0005 !.=;       $.=                                   /*sparse array of textonyms;  words.   */
0006 alphabet= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'           /*the supported alphabet to be used.   */
0007 digitKey=  22233344455566677778889999            /*translated alphabet to digit keys.   */
0008 digKey= 0;                 #word= 0              /*number digit combinations; word count*/
0009 ills= 0 ;    dups= 0;    longest= 0;   mostus= 0 /*illegals; duplicated words; longest..*/
0010 first=. ;    last= .;       long= 0;   most=   0 /*first, last, longest, most counts.   */
0011 call linein  iFID, 1, 0                          /*point to the first char in dictionary*/
0012 #= 0                                             /*number of textonyms in file (so far).*/
0013 
0014 do while  lines(iFID)\==0;     x= linein(iFID) /*keep reading the file until exhausted*/
0015 y= x;     upper x                              /*save a copy of  X;    uppercase  X.  */
0016 if \datatype(x, 'U')  then do;  ills= ills + 1;  iterate;  end     /*Not legal?  Skip.*/
0017 if $.x==.             then do;  dups= dups + 1;  iterate;  end     /*Duplicate?  Skip.*/
0018 $.x= .                                         /*indicate that it's a righteous word. */
0019 #word= #word + 1                               /*bump the word count  (for the file). */
0020 z= translate(x, digitKey, alphabet)            /*build a translated digit key word.   */
0021 @.z= @.z + 1                                   /*flag that the digit key word exists. */
0022 !.z= !.z  y;        _= words(!.z)              /*build list of equivalent digit key(s)*/
0023 
0024 if _>most  then do; mostus= z;  most= _;  end  /*remember the  "mostus"  digit keys.  */
0025 
0026 if @.z==2  then do; #= # + 1                   /*bump the count of the  textonyms.    */
0027 if first==.   then first=z /*the first textonym found.            */
0028 last= z                    /* "   last     "      "               */
0029 _= length(!.z)             /*the length (# chars) of the digit key*/
0030 if _>longest  then long= z /*is this the  longest  textonym ?     */
0031 longest= max(_, longest)   /*now, use this length as a target/goal*/
0032 end                            /* [↑]  discretionary  (extra credit). */
0033 
0034 if @.z==1  then digKey= digKey + 1             /*bump the count of digit key words.   */
0035 end   /*while*/
0036 
0037 @dict= 'in the dictionary file'                  /*literal used for some displayed text.*/
0038 L= length(commas(max(#word,ills,dups,digKey,#))) /*find length of max # being displayed.*/
0039 say 'The dictionary file being used is: '   iFID
0040 say
0041 call tell #word,  'words'                                           @dict,
0042 "which can be represented by digit key mapping"
0043 if ills>0  then call tell ills,   'word's(ills)  "that contain illegal characters"  @dict
0044 if dups>0  then call tell dups,   'duplicate word's(dups)  "detected"               @dict
0045 call tell digKey, 'combination's(digKey)   "required to represent them"
0046 call tell      #, 'digit combination's(#)  "that can represent Textonyms"
0047 say
0048 if first \== .  then say '    first digit key='   !.first
0049 if  last \== .  then say '     last digit key='   !.last
0050 if  long \== 0  then say '  longest digit key='   !.long
0051 if  most \== 0  then say ' numerous digit key='   !.mostus   " ("most   'words)'
0052 exit #                                           /*stick a fork in it,  we're all done. */
0053 /*──────────────────────────────────────────────────────────────────────────────────────*/
0054 commas: parse arg _;  do jc=length(_)-3  to 1  by -3; _=insert(',', _, jc); end;  return _
0055 tell:   arg ##; say 'There are ' right(commas(##), L)' ' arg(2).; return   /*commatize #*/
0056 s:      if arg(1)==1  then return '';      return "s"             /*a simple pluralizer.*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 jc               54
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #word            -> newV1            8 19
002 @dict            -> newV2            37
003 @.               -> newV3.           4 21
004 !.               -> newV4.           5 22
005 $.               -> newV5.           5 18
006 #                -> newV6            12 26
007 _                -> newV7            22 29 54 54
