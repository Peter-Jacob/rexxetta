-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:11
-------------------------------------------------------------------------
0001 /*REXX program can  generate and display several  EKG  sequences  (with various starts).*/
0002 parse arg nums start                             /*obtain optional arguments from the CL*/
0003 if  nums=='' |  nums==","  then  nums= 50        /*Not specified?  Then use the default.*/
0004 if start= '' | start= ","  then start=2 5 7 9 10 /* "      "         "   "   "     "    */
0005 
0006 do s=1  for words(start);   $=              /*step through the specified  STARTs.  */
0007 second= word(start, s);     say             /*obtain the second integer in the seq.*/
0008 
0009 do j=1  for nums
0010 if j<3  then do; #=1;  if j==2  then #=second;  end   /*handle 1st & 2nd number*/
0011 else #= ekg(#)
0012 $= $ right(#,  max(2, length(#) ) )     /*append the EKG integer to the $ list.*/
0013 end   /*j*/                             /* [↑] the RIGHT BIF aligns the numbers*/
0014 say '(start'  right(second,  max(2, length(second) ) )"):"$      /*display EKG seq.*/
0015 end       /*s*/
0016 exit                                             /*stick a fork in it,  we're all done. */
0017 /*──────────────────────────────────────────────────────────────────────────────────────*/
0018 add_:   do  while z//j == 0;    z=z%j;    _=_ j;    w=w+1;    end;         return strip(_)
0019 /*──────────────────────────────────────────────────────────────────────────────────────*/
0020 ekg: procedure expose $; parse arg x 1 z,,_
0021 w=0                                                        /*W:  number of factors.*/
0022 do k=1  to 11  by 2;     j=k;  if j==1  then j=2   /*divide by low primes. */
0023 if j==9  then iterate;   call add_                 /*skip ÷ 9; add to list.*/
0024 end   /*k*/
0025 /*↓ skips multiples of 3*/
0026 do y=0  by 2;  j= j + 2 + y//4                     /*increment J by 2 or 4.*/
0027 parse var  j  ''  -1  r;  if r==5  then iterate    /*divisible by five ?   */
0028 if j*j>x | j>z  then leave                         /*passed the sqrt(x) ?  */
0029 _= add_()                                          /*add a factor to list. */
0030 end   /*y*/
0031 j=z;                    if z\==1  then _= add_()           /*Z¬=1? Then add──►list.*/
0032 if _=''  then _=x                                          /*Null? Then use prime. */
0033 do   j=3;                          done=1
0034 do k=1  for w
0035 if j // word(_, k)==0  then do;  done=0;  leave;  end
0036 end   /*k*/
0037 if done  then iterate
0038 if wordpos(j, $)==0  then return j             /*return an EKG integer.*/
0039 end     /*j*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j                27 31 33
002 r                27
003 done             33 35
004 k                34
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $                -> newV1            6 12
002 #                -> newV2            10 10
003 _                -> newV3            18 20 29 31 32
