-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:04
-------------------------------------------------------------------------
0001 /*REXX program  computes and displays  the first    N    K─almost primes from  1 ──► K. */
0002 parse arg N K .                                  /*obtain optional arguments from the CL*/
0003 if N=='' | N==','  then N=10                     /*N  not specified?   Then use default.*/
0004 if K=='' | K==','  then K= 5                     /*K   "      "          "   "     "    */
0005 nn=N;  N=abs(N);   w=length(K)                   /*N positive? Then show K─almost primes*/
0006 limit= (2**K) * N / 2                            /*this is the limit for most K-primes. */
0007 if N==1  then limit=limit * 2                    /*  "   "  "    "    "  a    N    of 1.*/
0008 if K==1  then limit=limit * 4                    /*  "   "  "    "    "  a K─prime  " 2.*/
0009 if K==2  then limit=limit * 2                    /*  "   "  "    "    "  "    "     " 4.*/
0010 if K==3  then limit=limit * 3 % 2                /*  "   "  "    "    "  "    "     " 8.*/
0011 call genPrimes  limit + 1                        /*generate primes up to the  LIMIT + 1.*/
0012 say 'The highest prime computed: '        @.#        " (under the limit of " limit').'
0013 say                                              /* [↓]  define where 1st K─prime is odd*/
0014 d.=0;  d.2=  2;  d.3 =  4;  d.4 =  7;  d.5 = 13;  d.6 = 22;  d.7 =  38;   d.8=63
0015 d.9=102;  d.10=168;  d.11=268;  d.12=426;  d.13=673;  d.14=1064
0016 d!=0
0017 do m=1  for  K;    d!=max(d!,d.m)            /*generate & assign 1st K─almost prime.*/
0018 mr=right(m,w);     mm=m-1
0019 
0020 $=;           do #=1  to min(N, d!)          /*assign some doubled K─almost primes. */
0021 $=$  d.mm.# * 2
0022 end   /*#*/
0023 #=#-1
0024 if m==1  then from=2
0025 else from=1 + word($, words($) )
0026 
0027 do j=from   until  #==N                  /*process an  K─almost prime  N  times.*/
0028 if factr()\==m  then iterate             /*not the correct  K─almost  prime?    */
0029 #=#+1;   $=$ j                           /*bump K─almost counter; append it to $*/
0030 end   /*j*/                              /* [↑]   generate  N  K─almost  primes.*/
0031 
0032 if nn>0  then say mr"─almost ("N') primes:'     $
0033 else say '    the last'  mr  "K─almost prime: "   word($, words($))
0034 /* [↓]  assign K─almost primes.*/
0035 do q=1  for #;     d.m.q=word($,q)             ;   end  /*q*/
0036 do q=1  for #;  if d.m.q\==d.mm.q*2  then leave;   end  /*q*/
0037 /* [↑]  count doubly-duplicates*/
0038 /*──── say copies('─',40)  'for '   m", "   q-1   'numbers were doubly─duplicated.' ────*/
0039 /*──── say                                                                          ────*/
0040 end       /*m*/                              /* [↑]  display a line for each K─prime*/
0041 exit                                             /*stick a fork in it,  we're all done. */
0042 /*──────────────────────────────────────────────────────────────────────────────────────*/
0043 factr: if #.j\==.  then return #.j
0044 z=j;                                do f=0 while z// 2==0; z=z% 2; end   /*÷ by 2*/
0045 do f=f while z// 3==0; z=z% 3; end   /*÷ "  3*/
0046 do f=f while z// 5==0; z=z% 5; end   /*÷ "  5*/
0047 do f=f while z// 7==0; z=z% 7; end   /*÷ "  7*/
0048 do f=f while z//11==0; z=z%11; end   /*÷ " 11*/
0049 do f=f while z//13==0; z=z%13; end   /*÷ " 13*/
0050 do f=f while z//17==0; z=z%17; end   /*÷ " 17*/
0051 do f=f while z//19==0; z=z%19; end   /*÷ " 19*/
0052 
0053 do i=9    while  @.i<=z;       d=@.i    /*divide by some higher primes.        */
0054 do f=f  while z//d==0;   z=z%d;  end  /*is  Z  divisible by the  prime  D ?  */
0055 end   /*i*/                             /* [↑]  find all factors in  Z.        */
0056 
0057 if f==0  then f=1;   #.j=f;   return f    /*Is prime (f≡0)?   Then return unity. */
0058 /*──────────────────────────────────────────────────────────────────────────────────────*/
0059 genPrimes: arg x;             @.=;      @.1=2;     @.2=3;    #.=.;     #=2;     s.#=@.#**2
0060 do j=@.# +2  by 2  to x             /*only find odd primes from here on.   */
0061 do p=2  while s.p<=j             /*divide by some known low odd primes. */
0062 if j//@.p==0  then iterate j     /*Is  J  divisible by X?  Then ¬ prime.*/
0063 end   /*p*/                      /* [↓]  a prime  (J)  has been found.  */
0064 #=#+1;    @.#=j;   #.j=1;   s.#=j*j /*bump prime count, and also assign ···*/
0065 end      /*j*/                      /* ··· the # of factors, prime, prime².*/
0066 return                                /* [↑]  not an optimal prime generator.*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 N                2 3 5
002 K                2 4
003 nn               5
004 w                5
005 limit            6 7 8 9 10
006 d.               14 14 14 14 14 14 14 14 15 15 15 15 15 15 35
007 d!               16 17
008 m                17
009 mr               18
010 mm               18
011 from             24
012 j                27 60
013 q                35 36
014 z                44 44 45 46 47 48 49 50 51 54
015 f                44 45 46 47 48 49 50 51 54 57
016 i                53
017 d                53
018 s.               59 64
019 p                61
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #.               -> newV1.           57 59 64
002 @.               -> newV2.           59 59 59 64
003 $                -> newV3            20 21 29
004 #                -> newV4            20 23 29 59 64
