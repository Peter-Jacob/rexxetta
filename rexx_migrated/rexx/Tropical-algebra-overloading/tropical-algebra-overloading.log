-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:33
-------------------------------------------------------------------------
0001 /*REXX pgm demonstrates max tropical semi─ring with overloading: topAdd, topMul, topExp.*/
0002 call negInf;   @x= '(x)';   @a= '(+)';   @h= '(^)';   @e= 'expression';   @c= 'comparison'
0003 numeric digits 1000                              /*be able to handle negative infinity. */
0004 x=   2      ; y=   -2     ;  say is(@x)  LS(x)                 RS(y)           $Mul(x,y)
0005 x=  -0.001  ; y=  nInf    ;  say is(@a)  LS(x)                 RS(y)           $Add(x,y)
0006 x=   0      ; y=  nInf    ;  say is(@x)  LS(x)                 RS(y)           $Mul(x,y)
0007 x=   1.5    ; y=   -1     ;  say is(@a)  LS(x)                 RS(y)           $Add(x,y)
0008 x=  -0.5    ; y=    0     ;  say is(@x)  LS(x)                 RS(y)           $Mul(x,y)
0009 x=   5      ; y=    7     ;  say is(@h)  LS(x)                 RS(y)           $Exp(x,y)
0010 x=   5      ; y= $Add(8,7);  say is(@e)  LS(x  @x)             RS(@a"(8,7)")   $Mul(x,y)
0011 x= $Mul(5,8); y= $Mul(5,7);  say is(@e)  LS(@x"(5,8)"  @a)     RS(@x'(5,7)')   $Add(x,y)
0012 x=   5      ; y= $Add(8,7);      blanks= left('', 26)
0013 a= $Mul(5,8); b= $Mul(5,7);  say is(@c)  LS(x  @x)     @a"(8,7)"       '   compared to'
0014 say blanks  LS(@x"(5,8)")         RS(@a @x'(5,7)')   ,
0015 $ToF( $Mul(x,y) == $Add(a,b) )
0016 exit 0                                           /*stick a fork in it,  we're all done. */
0017 /*──────────────────────────────────────────────────────────────────────────────────────*/
0018 ABnInf: if b==''  then b=a;  __= negInf();  _= nInf();  return a==__ | a==_ | b==__ | b==_
0019 negInf: negInf= '-1e' || (digits()-1);  call nInf;  return negInf /*simulate a -∞ value.*/
0020 nInf:   nInf= '-∞';                     return nInf         /*return the "diagraph": -∞ */
0021 notNum: call sayErr "argument isn't numeric or minus infinity:", arg(1)    /*tell error.*/
0022 is:     return 'max tropical' center(arg(1), 10)    "of"    /*center what is to be shown*/
0023 LS:     return right( arg(1), 12)                 ' with '  /*pad  left─side of equation*/
0024 RS:     return  left( arg(1), 12)                 ' ───► '  /* "  right─side "     "    */
0025 sayErr: say;  say '***error***' arg(1) arg(2); say; exit 13 /*issue error message──►term*/
0026 $Add:   procedure; parse arg a,b; return max(isRing(a),isRing(b)) /*simulate max add  ƒ */
0027 $ToF:   procedure; parse arg ?; return word('false true',1+?)     /*return true │ false.*/
0028 /*──────────────────────────────────────────────────────────────────────────────────────*/
0029 $Exp:   procedure; parse arg a,b; if ABnInf() then return _ /*return the "diagraph": -∞ */
0030 return isRing(a) * isRing(b)                        /*simulate exponentiation ƒ */
0031 /*──────────────────────────────────────────────────────────────────────────────────────*/
0032 $Mul:   procedure; parse arg a,b; if ABnInf() then return _ /*return the "diagraph": -∞ */
0033 return isRing(a) + isRing(b)                        /*simulate multiplication ƒ */
0034 /*──────────────────────────────────────────────────────────────────────────────────────*/
0035 isNum:  procedure; parse arg a,b; if ABnInf() then a= negInf()   /*replace  A  with -∞? */
0036 return datatype(a, 'Num')                           /*Arg numeric? Return 1 or 0*/
0037 /*──────────────────────────────────────────────────────────────────────────────────────*/
0038 isRing: procedure; parse arg a,b; if ABnInf() then return negInf           /*return  -∞ */
0039 if isNum(a) | a==negInf()  then return a;  call notNum a           /*show error.*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 a                38
002 b                38
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @x               -> newV1            2
002 @a               -> newV2            2
003 @h               -> newV3            2
004 @e               -> newV4            2
005 @c               -> newV5            2
006 __               -> newV6            18
007 _                -> newV7            18
008 ?                -> newV8            27
