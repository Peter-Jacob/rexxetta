-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:18
-------------------------------------------------------------------------
0001 /*REXX pgm generates & counts (& maybe shows) some Kaprekar #s using the cast─out─9 test*/
0002 parse arg A B .                                  /*obtain optional arguments from the CL*/
0003 if A=='' | A=","  then A=    10000               /*Not specified?  Then use the default.*/
0004 if B=='' | B=","  then B= -1000000               /* "      "         "   "   "     "    */
0005 call Kaprekar          A                         /*gen Kaprekar numbers and display 'em.*/
0006 call Kaprekar          B                         /* "     "        "   don't    "     " */
0007 exit 0                                           /*stick a fork in it,  we're all done. */
0008 /*──────────────────────────────────────────────────────────────────────────────────────*/
0009 Kaprekar: procedure; parse arg N;  aN= abs(N)    /*obtain the limit;   use  │N│  value. */
0010 numeric digits max(9, 2 * length(aN) ) /*use enough decimal digits for square.*/
0011 d= digits();         tell= N>0         /*set D to number of digits;  set TELL.*/
0012 #= 0;       if aN>0  then do;    #= 1;    if tell  then say right(1, d);    end
0013 /* [↑]  handle case of  N  being unity.*/
0014 if aN>1  then do j=9  for aN-9;        /*calculate the  square  of  J   (S).  */
0015 jc= j//9                 /*JC:   J modulo 9   (cast out nines). */
0016 if jc >2  then iterate   /*Is  J mod 9 > two?  Then skip this J.*/
0017 s= j*j                   /*calculate the  square  of  J   (S).  */
0018 if jc==s//9  then do k=1  for length(s)%2   /*≡ casted out 9's? */
0019 parse var    s      L   +(k)   R
0020 if j\==L+R  then iterate
0021 #= # + 1;   if tell  then say right(j, d); leave
0022 end   /*k*/
0023 end   /*j*/
0024 say
0025 say center(" There're "     #     ' Kaprekar numbers below '     aN" ", 79, "═")
0026 return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 s                19
002 L                19
003 R                19
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 +(k)             -> newV1            19
002 #                -> newV2            12 12 21
