-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:27
-------------------------------------------------------------------------
0001 /*REXX program  encodes and displays a string  by using a  run─length  encoding scheme. */
0002 parse arg input .                                /*normally, input would be in a file.  */
0003 default= 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'
0004 if input=='' | input==","  then input=   default /*Not specified?  Then use the default.*/
0005 encode= RLE(input) ;     say '  input='  input   /*encode input string;  display input. */
0006 say 'encoded='  encode  /*                      display run─len*/
0007 decode= RLD(encode);     say 'decoded='  decode  /*decode the run─len;   display decode.*/
0008 if decode==input  then say 'OK'; else say "¬ OK" /*display yay or nay (success/failure).*/
0009 exit 0                                           /*stick a fork in it,  we're all done. */
0010 /*──────────────────────────────────────────────────────────────────────────────────────*/
0011 err: say;    say "***error***  input data isn't alphabetic:"   c;       say;     exit 13
0012 /*──────────────────────────────────────────────────────────────────────────────────────*/
0013 RLE: procedure;  parse arg x;     $=             /*$:  is the output string  (so far).  */
0014 Lx= length(x)            /*get length of the plain text string. */
0015 do j=1  by 0  to Lx;  c= substr(x, j, 1)  /*obtain a character from plain text.  */
0016 if \datatype(c, 'M')  then call err       /*Character not a letter?  Issue error.*/
0017 r= 0                                      /*R:  is NOT the number of characters. */
0018 do k=j+1  to Lx  while substr(x, k, 1)==c   /*while characters ≡ C */
0019 r= r + 1                    /*bump the replication count for a char*/
0020 end   /*k*/
0021 j= j + r + 1                              /*increment (add to) the DO loop index.*/
0022 if r==0  then $= $ ||      c              /*don't use  R  if it is equal to zero.*/
0023 else $= $ || r || c              /*add character to the encoded string. */
0024 end   /*j*/;                   return $   /*return the encoded string to caller. */
0025 /*──────────────────────────────────────────────────────────────────────────────────────*/
0026 RLD: procedure;  parse arg x;     $=             /*$:  is the output string  (so far).  */
0027 Lx= length(x)            /*get the length of the encoded string.*/
0028 do j=1  by 0  to Lx;  c= substr(x, j, 1)  /*obtain a character from run encoding.*/
0029 if \datatype(c, 'W')  then do;   $= $ || c;     j= j + 1;     iterate /*j*/
0030 end            /* [↑]  a loner char, add it to output.*/
0031 #= 1                                      /*          [↓]  W:  use a Whole number*/
0032 do k=j+1  to Lx  while datatype(substr(x,k,1), 'w') /*while numeric*/
0033 #= # + 1                           /*bump the count of the numeric chars. */
0034 end   /*k*/
0035 n= substr(x, j, #) + 1                    /*#:  the length of encoded character. */
0036 $= $  ||  copies( substr(x, k, 1), n)     /*N:  is now the number of characters. */
0037 j= j + # + 1                              /*increment the DO loop index by D+1.  */
0038 end   /*j*/;                   return $   /*return the decoded string to caller. */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                26
002 Lx               27
003 j                28 29 37
004 c                28
005 k                32
006 n                35
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $                -> newV1            13 22 26 29 36
002 #                -> newV2            31 33
