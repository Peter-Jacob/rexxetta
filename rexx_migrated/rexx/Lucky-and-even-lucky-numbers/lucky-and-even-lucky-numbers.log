-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:20
-------------------------------------------------------------------------
0001 /*REXX program displays  lucky  or  evenLucky  integers   (numbers  or  a number range).*/
0002 parse arg bot top func _ .                       /*obtain required & optional arguments.*/
0003 if func==''  then func= 'lucky'                  /*Not specified?  Then use the default.*/
0004 s= left('s', bot\==top  &  top\==",")            /*plural results (or maybe not plural).*/
0005 say func  'number's":"   bot  top   '───►'   $lucky(bot, top, func, _)
0006 exit 0                                           /*stick a fork in it,  we're all done. */
0007 /*──────────────────────────────────────────────────────────────────────────────────────*/
0008 $lucky: arg x,y,f,?;   if y=='' | y==","  then y= x      /*obtain some arguments; set Y.*/
0009 #= 0;          $=;                    ny= y<0    /*set variable NOY: value range*/
0010 if f==''  then f= 'LUCKY';   lucky= (f=="LUCKY") /*assume  LUCKY  if omitted.   */
0011 if f\=='LUCKY' & f\=='EVENLUCKY'  then return  'function not valid: '     f
0012 if arg()>3  &  ?\=''      then return  "too many arguments entered: "     ?
0013 if x=''                   then return  "1st argument is missing."
0014 if x<1                    then return  "1st argument isn't a positive integer: " x
0015 if \datatype(x,'W')       then return  "1st argument isn't an integer: "  x
0016 if \datatype(y,'W')       then return  "2nd argument isn't an integer: "  y
0017 if x>ay                   then return  "2nd argument is less than 1st arg."
0018 ay=abs(y); yL=ay; if y>0  then yL= y*10  + y + y /*adjust the upper  Y  limit.  */
0019 /* [↓]  build LUCKY | EVENLUCKY*/
0020 do j=1  until j>=yL                          /*construct list pos. integers.*/
0021 if j//2==(\lucky)  then iterate              /*EVENLUCKY? Use only even ints*/
0022 
0023 if lucky  then if (j+1)//6==0  then iterate  /*prune       if  mod 6 ≡ zero.*/
0024 else nop      /*balance the   IF-THEN  logic.*/
0025 else if  j   //8==0  then iterate  /*prune next  if  mod 8 ≡ zero.*/
0026 #= # + 1                                     /*bump the counter of numbers. */
0027 $= $ j                                       /*append integer to the $ list.*/
0028 end   /*j*/
0029 q=0
0030 do p=3  until  q=='';       q= word($, p)    /*start to prune  integer list.*/
0031 if q>#  then leave                           /*if integer is too large, stop*/
0032 do j=#%q*q  by -q  to q  /*elide every  Qth  integer.   */
0033 $= delword($, j, 1)      /*delete a particular number.  */
0034 #= # -1                  /*decrease the integer count.  */
0035 end   /*j*/              /*delete from the right side.  */
0036 end   /*p*/
0037 @.=
0038 do k=1;  parse var $ q $;       if q==''  then leave;       @.k= q
0039 end   /*k*/
0040 @.0=k-1
0041 do m=1  for #                          /*restrict the found integers. */
0042 if (\ny  &  (m<x  |  m>ay))  |  (ny  &  (@.m<x | @.m>ay))  then @.m=
0043 end   /*m*/                            /* [↑]  a list of #s or a range*/
0044 _=
0045 do b=1  for @.0;     _= _ @.b          /*construct a list of integers.*/
0046 end   /*b*/
0047 return space(_)                                  /*remove superfluous blanks.   */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 q                38
002 m                41
003 b                45
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           37 38 40 42
002 _                -> newV2            2 44 45
003 #                -> newV3            9 26 34
004 $                -> newV4            9 27 33 38 38
