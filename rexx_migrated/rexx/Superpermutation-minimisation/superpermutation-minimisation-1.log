-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:32
-------------------------------------------------------------------------
0001 /*REXX program attempts  to find better  minimizations  for computing superpermutations.*/
0002 parse arg cycles .                               /*obtain optional arguments from the CL*/
0003 if cycles=='' | cycles==","  then cycles= 7      /*Not specified?  Then use the default.*/
0004 
0005 do n=0  to  cycles
0006 #= 0;                           $.=        /*populate the first permutation.      */
0007 do pop=1  for n;        @.pop= d2x(pop);        $.0= $.0  ||  @.pop
0008 end  /*pop*/
0009 
0010 do  while aPerm(n, 0)
0011 if n\==0  then #= #+1;  $.#=
0012 do j=1  for n;        $.#= $.#  ||  @.j
0013 end   /*j*/
0014 end     /*while*/
0015 z= $.0
0016 nm= n-1
0017 do p=1  for #;      if $.j==''          then iterate
0018 if pos($.p, z)\==0  then iterate
0019 parse  var   $.p    h  2  R  1  L  =(n)
0020 if  left(z, nm)==R  then do;    z= h  ||  z;    iterate;   end
0021 if right(z,  1)==h  then do;    z= z  ||  R;    iterate;   end
0022 z= z  ||  $.p
0023 end   /*p*/                        /* [↑]  more IFs could be added for opt*/
0024 
0025 L= commas( length(z) )
0026 say 'length of superpermutation('n") ="      right(L, max(length(L), cycles+2) )
0027 end   /*cycle*/
0028 exit 0                                           /*stick a fork in it,  we're all done. */
0029 /*──────────────────────────────────────────────────────────────────────────────────────*/
0030 commas: parse arg ?;  do jc=length(?)-3  to 1  by -3; ?=insert(',', ?, jc); end;  return ?
0031 /*──────────────────────────────────────────────────────────────────────────────────────*/
0032 aPerm: procedure expose @.;    parse arg n,i;      nm= n - 1;      if n==0  then return 0
0033 do k=nm  by -1  for nm; kp=k+1; if @.k<@.kp  then do; i=k; leave; end; end /*k*/
0034 do j=i+1  while  j<n;  parse value  @.j @.n  with  @.n @.j;    n= n-1; end /*j*/
0035 if i==0  then return 0
0036 do m=i+1  while @.m<@.i; end /*m*/;    parse value  @.m  @.i   with   @.i  @.m
0037 return 1
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 n                32 34
002 i                32 33
003 nm               32
004 k                33
005 kp               33
006 j                34
007 p                17
008 NORMAL.8         
009 NORMAL.9         
010 NORMAL.10        
011 NORMAL.11        
012 NORMAL.12        
013 NORMAL.13        
014 NORMAL.14        
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 =(n)             -> newV1            19
002 $.               -> newV2.           6 7 11 12 19
003 @.               -> newV3.           7 34 34 36 36
004 #                -> newV4            6 11
005 ?                -> newV5            30 30
