-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:23
-------------------------------------------------------------------------
0001 /*REXX program computes and shows the Padovan sequences for  M  steps  for  N  numbers. */
0002 parse arg n m .                                  /*obtain optional arguments from the CL*/
0003 if  n=='' |  n==","  then  n= 15                 /*Not specified?  Then use the default.*/
0004 if  m=='' |  m==","  then  m=  8                 /* "      "         "   "   "     "    */
0005 w.= 1                                            /*W.c:  the maximum width of a column. */
0006 do #=2  for m-1
0007 @.= 0;    @.0= 1;    @.1= 1;    @.2= 1   /*initialize 3 terms of the Padovan seq*/
0008 $= @.0                                   /*initials the list with the zeroth #. */
0009 do k=2  for  n-1;      z= pd(k-1)
0010 w.k= max(w.k, length(z));  $= $ z /*find maximum width for a specific col*/
0011 end   /*k*/
0012 $.#= $                                   /*save each unaligned line for later.  */
0013 end          /*#*/
0014 oW= 1
0015 do col=1  for n;  oW= oW + w.col + 1     /*add up the width of each column.     */
0016 end   /*col*/
0017 iW= length(m) + 2;       pad= left('', 20*(n<21))    /*maybe indent.*/
0018 say pad center('M', iW, " ")"│"center('first ' n " Padovan sequence with step  M", oW)
0019 say pad center('',  iW, "─")"┼"center('',  oW,  "─")
0020 
0021 do out=2  for m-1;   $=                  /*align columnar elements for outputs. */
0022 do j=1  for n;  $= $ right(word($.out, j),  w.j)      /*align the columns. */
0023 end     /*j*/
0024 say pad center(out,length(m)+2)'│'$      /*display a line of columnar elements. */
0025 end          /*out*/
0026 
0027 say pad center('',  length(m)+2, "─")"┴"center('',  oW,  "─")
0028 exit 0                                           /*stick a fork in it,  we're all done. */
0029 /*──────────────────────────────────────────────────────────────────────────────────────*/
0030 pd:    procedure expose @. #; parse arg x;  if @.x\==0  then return @.x   /*@.x defined?*/
0031 do k=1  for  #;   _= x-1-k;    @.x= @.x + @._;    end;      return @.x
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                30
002 k                31
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           7 7 7 7 31
002 $.               -> newV2.           12
003 #                -> newV3            6
004 $                -> newV4            8 10 21 22
005 _                -> newV5            31
