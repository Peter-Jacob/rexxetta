-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:08
-------------------------------------------------------------------------
0001 /*REXX program finds & displays circular primes (with a title & in a horizontal format).*/
0002 parse arg N hp .                                 /*obtain optional arguments from the CL*/
0003 if  N=='' |  N==","  then N=        19           /* "      "         "   "   "     "    */
0004 if hp=='' | hp==","  then hip= 1000000           /* "      "         "   "   "     "    */
0005 call genP                                        /*gen primes up to  hp      (200,000). */
0006 q= 024568                                        /*digs that most circular P can't have.*/
0007 found= 0;                           $=           /*found:  circular P count; $:  a list.*/
0008 do j=1  until found==N;       p= @.j       /* [↓]  traipse through all the primes.*/
0009 if p>9 & verify(p, q, 'M')>0  then iterate /*Does J contain forbidden digs?  Skip.*/
0010 if \circP(p)                  then iterate /*Not circular?  Then skip this number.*/
0011 found= found + 1                           /*bump the  count  of circular primes. */
0012 $= $  p                                    /*add this prime number  ──►  $  list. */
0013 end   /*j*/                                /*at this point, $ has a leading blank.*/
0014 
0015 say center(' first '       found        " circular primes ",  79, '─')
0016 say strip($)
0017 exit 0                                           /*stick a fork in it,  we're all done. */
0018 /*──────────────────────────────────────────────────────────────────────────────────────*/
0019 circP: procedure expose @. !.;  parse arg x 1 ox /*obtain a prime number to be examined.*/
0020 do length(x)-1; parse var x f 2 y /*parse  X  number, rotating the digits*/
0021 x= y || f                         /*construct a new possible circular P. */
0022 if x<ox  then return 0            /*is number < the original?  ¬ circular*/
0023 if \!.x  then return 0            /* "    "   not prime?       ¬ circular*/
0024 end   /*length(x)···*/
0025 return 1                                  /*passed all tests,  X is a circular P.*/
0026 /*──────────────────────────────────────────────────────────────────────────────────────*/
0027 genP: @.1=2; @.2=3; @.3=5; @.4=7; @.5=11; @.6=13; @.7=17; @.8=19        /*assign Ps; #Ps*/
0028 !.= 0; !.2=1; !.3=1; !.5=1; !.7=1; !.11=1; !.13=1; !.17=1; !.19=1 /*   " primality*/
0029 #= 8;  sq.#= @.# **2  /*number of primes so far; prime square*/
0030 do j=@.#+4  by 2  to hip;  parse var j  ''  -1  _ /*get last decimal digit of J. */
0031 if     _==5  then iterate;   if j// 3==0  then iterate;   if j// 7==0  then iterate
0032 if j//11==0  then iterate;   if j//13==0  then iterate;   if j//17==0  then iterate
0033 do k=8  while sq.k<=j                 /*divide by some generated odd primes. */
0034 if j // @.k==0  then iterate j        /*Is J divisible by  P?  Then not prime*/
0035 end   /*k*/                           /* [↓]  a prime  (J)  has been found.  */
0036 #= #+1;   !.j= 1;   sq.#= j*j;   @.#= j   /*bump P cnt;  assign P to @.  and  !. */
0037 end       /*j*/;                 return
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j                30
002 k                33
003 sq.              36
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           27 27 27 27 27 27 27 36
002 !.               -> newV2.           28 28 28 28 28 28 28 28 28 36
003 $                -> newV3            7 12
004 #                -> newV4            29 36
005 _                -> newV5            30
