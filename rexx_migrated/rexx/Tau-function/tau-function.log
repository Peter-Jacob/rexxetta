-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:32
-------------------------------------------------------------------------
0001 /*REXX program counts the number of divisors (tau,  or sigma_0)  up to and including  N.*/
0002 parse arg LO HI cols .                           /*obtain optional argument from the CL.*/
0003 if   LO=='' |   LO==","  then  LO=   1           /*Not specified?  Then use the default.*/
0004 if   HI=='' |   HI==","  then  HI=  LO + 100 - 1 /*Not specified?  Then use the default.*/
0005 if cols=='' | cols==","  then cols= 20           /* "      "         "   "   "     "    */
0006 w= 2 + (HI>45359)                                /*W:  used to align the output columns.*/
0007 say 'The number of divisors  (tau)  for integers up to '    n    " (inclusive):";      say
0008 say '─index─'   center(" tau (number of divisors) ",  cols * (w+1)  +  1,  '─')
0009 $=;                                   c= 0       /*$:  the output list,  shown ROW/line.*/
0010 do j=LO  to HI;       c= c + 1   /*list # proper divisors (tau) 1 ──► N */
0011 $= $  right( tau(j), w)          /*add a tau number to the output list. */
0012 if c//cols \== 0  then iterate   /*Not a multiple of ROW? Don't display.*/
0013 idx= j - cols + 1                /*calculate index value (for this row).*/
0014 say center(idx, 7)    $;  $=     /*display partial list to the terminal.*/
0015 end   /*j*/
0016 
0017 if $\==''  then say center(idx+cols, 7)    $     /*there any residuals left to display ?*/
0018 exit 0                                           /*stick a fork in it,  we're all done. */
0019 /*──────────────────────────────────────────────────────────────────────────────────────*/
0020 tau: procedure; parse arg x 1 y                  /*X  and  $  are both set from the arg.*/
0021 if x<6  then return 2 + (x==4) - (x==1)     /*some low #s should be handled special*/
0022 odd= x // 2                                 /*check if  X  is odd (remainder of 1).*/
0023 if odd  then       #= 2                     /*Odd?    Assume divisor count of  2.  */
0024 else do;   #= 4;   y= x % 2;   end  /*Even?      "      "      "    "  4.  */
0025 /* [↑]  start with known number of divs*/
0026 do j=3  for x%2-3  by 1+odd  while j<y   /*for odd number,  skip even numbers.  */
0027 if x//j==0  then do                      /*if no remainder, then found a divisor*/
0028 #= # + 2;   y= x % j    /*bump # of divisors;  calculate limit.*/
0029 if j>=y  then do;   #= # - 1;   leave;   end   /*reached limit?*/
0030 end                     /*                     ___             */
0031 else if j*j>x  then leave    /*only divide up to   √ x              */
0032 end   /*j*/;               return #      /* [↑]  this form of DO loop is faster.*/
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                20
002 y                20 24 28
003 odd              22
004 j                26
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $                -> newV1            9 11 14
002 #                -> newV2            23 24 28 29
