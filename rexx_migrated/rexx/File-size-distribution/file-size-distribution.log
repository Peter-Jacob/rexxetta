-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:13
-------------------------------------------------------------------------
0001 /*REXX program displays a histogram of filesize distribution of a directory structure(s)*/
0002 numeric digits 30                                /*ensure enough decimal digits for a #.*/
0003 parse arg ds .                                   /*obtain optional argument from the CL.*/
0004 parse source . . path .                          /*   "   the path of this REXX program.*/
0005 fID= substr(path, 1 + lastpos('\', path) )       /*   "   the filename and the filetype.*/
0006 parse var  fID   fn  '.'                         /*   "   just the pure filename of pgm.*/
0007 sw=max(79, linesize() - 1)                       /*   "   terminal width (linesize) - 1.*/
0008 work= fn".OUT"   /*filename for workfile output of  DIR.*/
0009 'DIR'   ds   '/s /-c /a-d  >'   work             /*do (DOS) DIR cmd for a data structure*/
0010 call linein 0, 1                                 /*open output file, point to 1st record*/
0011 maxL= 0;    @.= 00;      g= 0                    /*max len size; log array; # good recs.*/
0012 $=0                                              /*$:  total bytes used by files found. */
0013 do while lines(work)\==0;  _= linein(work)  /*process the data in the DIR work file*/
0014 if left(_, 1)==' '    then iterate          /*Is the record not legitimate?  Skip. */
0015 parse upper  var   _    .  .  sz  .         /*uppercase the suffix  (if any).      */
0016 sz= space( translate(sz, , ','),  0)        /*remove any commas if present in the #*/
0017 
0018 if \datatype(sz,'W')  then do; #= left(sz, length(sz) - 1)       /*SZ has a suffix?*/
0019 if \datatype(#,'N')  then iterate /*Meat ¬ numeric? */
0020 sz= # * 1024 ** pos( right(sz, 1), 'KMGTPEZYXWVU') / 1
0021 end                                   /* [↑]  use suffix*/
0022 $= $ + sz                                   /*keep a running total for the filesize*/
0023 if sz==0  then L= 0                         /*handle special case for an empty file*/
0024 else L= length(sz)                /*obtain the length of filesize number.*/
0025 g= g + 1                                    /*bump the counter of # of good records*/
0026 maxL= max(L, maxL)                          /*get max length filesize for alignment*/
0027 @.L= @.L + 1                                /*bump counter of record size category.*/
0028 end   /*j*/                                 /* [↑]   categories:  split by log ten.*/
0029 
0030 if g==0  then do;  say 'file not found: '  ds;  exit 13;    end        /*no good records*/
0031 say  ' record size range    count   '
0032 hdr= '══════════════════ ══════════ ';     say hdr;         Lhdr=length(hdr)
0033 mC=0                                             /*mC:  the maximum count for any range.*/
0034 do   t=1  to 2                              /*T==1   is used to find the max count.*/
0035 do k=0  to maxL;  mC= max(mC, @.k);  if t==1  then iterate           /*1st pass? */
0036 if k==0  then y= center('zero',  length( word(hdr, 1)  ) )
0037 else y= '10^'left(k-1,2)  "──► 10^"left(k,2)  '-1'
0038 say y || right( commas(@.k), 11)   copies('─', max(1, (@.k / mC * sw % 1) - LHdr) )
0039 end   /*k*/
0040 end     /*y*/
0041 say
0042 trace off;   'ERASE'  work                       /*perform clean─up (erase a work file).*/
0043 say commas(g)      ' files detected, '       commas($)        " total bytes."
0044 exit                                             /*stick a fork in it,  we're all done. */
0045 /*──────────────────────────────────────────────────────────────────────────────────────*/
0046 commas: parse arg _;  do j#=length(_)-3  to 1  by -3; _=insert(',', _, j#); end;  return _
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 j#               46
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           11 27
002 $                -> newV2            12 22
003 _                -> newV3            13 15 46 46
004 #                -> newV4            18
