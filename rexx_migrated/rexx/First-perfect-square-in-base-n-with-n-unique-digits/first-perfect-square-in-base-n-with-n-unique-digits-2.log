-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:13
-------------------------------------------------------------------------
0001 /*REXX program finds/displays the first perfect square with  N  unique digits in base N.*/
0002 numeric digits 40                                /*ensure enough decimal digits for a #.*/
0003 parse arg LO HI .                                /*obtain optional argument from the CL.*/
0004 if LO==''            then do;  LO=2;  HI=16; end /*not specified?  Then use the default.*/
0005 if LO==','           then      LO=2              /* "      "         "   "   "     "    */
0006 if HI=='' | HI==","  then             HI=LO      /* "      "         "   "   "     "    */
0007 @start= 1023456789abcdefghijklmnopqrstuvwxyz     /*contains the start # (up to base 36).*/
0008 call base                                        /*initialize 2 arrays for BASE function*/
0009 /* [↓]  find the smallest square with  */
0010 do j=LO  to HI;        beg= left(@start, j)  /*      N  unique digits in base  N.   */
0011 do k=iSqrt( base(beg,10,j) )  until #==0  /*start each search from smallest sqrt.*/
0012 $= base(k*k, j, 10)                       /*calculate square, convert to base J. */
0013 #= verify(beg, $)                         /*count differences between 2 numbers. */
0014 end   /*k*/
0015 say 'base'            right(j, length(HI) )                   "   root="   ,
0016 lower( right( base(k, j, 10), max(5, HI) ) )   '   square='    lower($)
0017 end      /*j*/
0018 exit                                             /*stick a fork in it,  we're all done. */
0019 /*──────────────────────────────────────────────────────────────────────────────────────*/
0020 base: procedure expose !. !!.; arg x 1 #,toB,inB /*obtain:  three arguments.            */
0021 @= 0123456789abcdefghijklmnopqrstuvwxyz    /*the characters for the Latin alphabet*/
0022 if x==''  then do i=1  for length(@);   _= substr(@, i, 1);    m= i - 1;    !._= m
0023 !!.m= substr(@, i, 1)
0024 if i==length(@) then return /*Done with shortcuts?  Then go back.  */
0025 end   /*i*/                 /* [↑]  assign shortcut radix values.  */
0026 if inb\==10  then                          /*only convert if  not  base 10.       */
0027 do 1;  #= 0                             /*result of converted  X  (in base 10).*/
0028 if inb==2   then do; #= b2d(x); leave; end  /*convert   binary    to decimal.  */
0029 if inb==16  then do; #= x2d(x); leave; end  /*   "    hexadecimal  "    "      */
0030 do j=1  for length(x)                 /*convert  X:   base inB  ──► base 10. */
0031 _= substr(x, j, 1);  #= # * inB + !._ /*build a new number,  digit by digit. */
0032 end    /*j*/                          /* [↑]  this also verifies digits.     */
0033 end
0034 y=                                         /*the value of  X  in base  B (so far).*/
0035 if tob==10  then return #                  /*if TOB is ten,  then simply return #.*/
0036 if tob==2   then return d2b(#)             /*convert base 10 number to binary.    */
0037 if tob==16  then return d2x(#)             /*   "      "   "    "    " hexadecimal*/
0038 do  while  # >= toB                     /*convert #:    base 10  ──►  base toB.*/
0039 _= # // toB;           y= !!._ || y     /*construct the output number.         */
0040 #= # % toB                              /*      ··· and whittle  #  down also. */
0041 end    /*while*/                        /* [↑]  algorithm may leave a residual.*/
0042 return !!.# || y                           /*prepend the residual, if any.        */
0043 /*──────────────────────────────────────────────────────────────────────────────────────*/
0044 iSqrt: procedure; parse arg x;  r=0;  q=1;             do while q<=x;  q=q*4;  end
0045 do while q>1; q=q%4; _=x-r-q; r=r%2; if _>=0 then do;x=_;r=r+q; end; end; return r
0046 /*──────────────────────────────────────────────────────────────────────────────────────*/
0047 b2d:   return x2d( b2x( arg(1) ) )               /*convert binary      number to decimal*/
0048 d2b:   return x2b( d2x( arg(1) ) )  +  0         /*   "    hexadecimal    "    "    "   */
0049 lower: @abc= 'abcdefghijklmnopqrstuvwxyz'; return translate(arg(1), @abc, translate(@abc))
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                44 45
002 r                44 45 45
003 q                44 44 45
004 while            44
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @start           -> newV1            7
002 !!.              -> newV2.           23
003 !.               -> newV3.           22
004 $                -> newV4            12
005 #                -> newV5            13 27 28 29 31 40
006 @                -> newV6            21
007 _                -> newV7            22 31 39 45
