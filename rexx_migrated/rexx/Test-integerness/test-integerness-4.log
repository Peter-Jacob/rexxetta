-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:33
-------------------------------------------------------------------------
0001 /*REXX program  tests  if a number  (possibly complex)  is  equivalent  to an integer.  */
0002 numeric digits 3000                              /*be able to handle gihugic integers.  */
0003 unaB= '++ -- -+ +-'                              /*a list of            unary operators.*/
0004 unaA= '+  +  -  -'                               /*"   "   " translated   "       "     */
0005 parse arg #s                                     /*obtain optional numbers list from CL.*/
0006 if #s=''  then #s= '245+-00.0e-12i   245++++++0e+12j   --3450d-1----0.0d-1j' ,
0007 '4.5e11111222223333344444555556666677777888889999900'
0008 /* [↑]  use these numbers for defaults.*/
0009 do j=1  for words(#s);   ox=word(#s, j)        /*obtain a number from the numbers list*/
0010 parse  upper  var  ox  x                       /*obtain an uppercase version of  OX.  */
0011 x=translate(x, 'EEJ', "QDI")                   /*translate exponent and imag indicator*/
0012 
0013 do k=1  for words(unaB)                      /*process every possible unary operator*/
0014 _=word(unaB, k)                              /*a unary operator to be changed, maybe*/
0015 
0016 do  while  pos(_, x) \== 0                 /*keep changing until no more are left.*/
0017 x=changestr(_, x, word(unaA, k) )          /*reduce all unary operators  (if any).*/
0018 end   /*while*/
0019 end     /*k*/
0020 
0021 if right(x, 1)=='J'  then call tImag           /*has the  X  number an imaginary part?*/
0022 if isInt(x)  then say  right(ox, 55)  "     is an integer."      /*yuppers, it does.  */
0023 else say  right(ox, 55)  "  isn't an integer."      /*noppers, it doesn't*/
0024 end   /*j*/                                    /* [↑]  process each number in the list*/
0025 exit                                             /*stick a fork in it,  we're all done. */
0026 /*──────────────────────────────────────────────────────────────────────────────────────*/
0027 isInt:  procedure;  parse arg n                  /*obtain the number in question.       */
0028 if datatype(n, 'Whole')  then return 1   /*it's a simple integer (small).       */
0029 parse  var  n   m  'E'  p                /*separate base from the  10's  power. */
0030 if \datatype(p, 'Numb')  then return 0   /*Not an integer if  P  not an integer.*/
0031 return  p>0  |  m=0                      /*is   power>0   or   mantissa = zero? */
0032 /*──────────────────────────────────────────────────────────────────────────────────────*/
0033 isSign: parse arg ? 2;   return ?=='+' | ?=="-"  /*a method to test for a leading sign. */
0034 /*──────────────────────────────────────────────────────────────────────────────────────*/
0035 tImag:  x=left(x, length(x) -1)                  /*strip the trailing I or J from number*/
0036 if isInt(x)   then do                    /*is what's remaining an integer ?     */
0037 if x\=0  then x=.     /*what's remaining isn't equal to zero.*/
0038 return                /*return to invoker in either case.    */
0039 end                   /* [↑]  handle simple imaginary case.  */
0040 if isSign(x)  then x=substr(x, 2)        /*X has a sign?  Strip the leading sign*/
0041 e=verify(x, .0123456789)                 /*find 1st char not a digit or a  dot. */
0042 if e==0       then do; x=.; return; end  /*Nothing?  Then it's not an integer.  */
0043 y=substr(x, e, 1)                        /*Y  is the suspect character.         */
0044 if isSign(y)  then do                    /*is suspect character a plus or minus?*/
0045 z=substr(x, e+1)      /*obtain the imaginary part of  X.     */
0046 x=  left(x, e-1)      /*   "    "    real      "   "  "      */
0047 if isInt(z)  then if z=0  then return   /*imaginary part is 0*/
0048 x=.                   /*the imaginary part isn't zero.       */
0049 end                   /* [↑]  end of imaginary part of  X.   */
0050 if y\=='E'    then return                /*real part of X doesn't have an expon.*/
0051 p=substr(x, e+1)                         /*obtain power of real part of  X.     */
0052 _=  left(p, 1)                           /*obtain the possible sign of the power*/
0053 if isSign(_)  then p=substr(p, 2)        /*strip the sign from the exponent.    */
0054 s=verify(p, '-+', "M")                   /*is there an imaginary separator char?*/
0055 if s==0       then do; x=.; return; end  /*No sign?   Then isn't not an integer.*/
0056 z=substr(p, s+1)                         /*obtain the the imaginary part of  X. */
0057 x=  left(x, e+s)                         /*   "    "   "     real     "   "  "  */
0058 if isInt(z)   then if z\=0  then x=.     /*Not imaginary part=0? Not an integer.*/
0059 return                                   /*return to the invoker of this sub.   */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                37 40 42 46 48 55 57 58
002 e                41
003 y                43
004 z                45 56
005 p                51 53
006 s                54
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 #s               -> newV1            5 6
002 _                -> newV2            14 52
003 ?                -> newV3            33
