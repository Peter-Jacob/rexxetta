-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:25
-------------------------------------------------------------------------
0001 /*REXX pgm displays Ramanujan's constant to at least  100  decimal digits of precision. */
0002 d= min( length(pi()), length(e()) )  - length(.) /*calculate max #decimal digs supported*/
0003 parse arg digs sDigs . 1 . . $                   /*obtain optional arguments from the CL*/
0004 if  digs=='' |  digs==","  then  digs= d         /*Not specified?  Then use the default.*/
0005 if sDigs=='' | sDigs==","  then sDigs= d % 2     /* "      "         "   "   "      "   */
0006 if     $=''  |     $=","   then $= 19 43 67 163  /* "      "         "   "   "      "   */
0007 digs= min( digs, d)                             /*the minimum decimal digs for calc.   */
0008 sDigs= min(sDigs, d)                             /* "     "       "      "      display.*/
0009 numeric digits digs                              /*inform REXX how many dec digs to use.*/
0010 say "The value of Ramanujan's constant calculated with " d ' decimal digits of precision.'
0011 say "shown with "    sDigs    ' decimal digits past the decimal point:'
0012 say
0013 do  j=1  for words($);   #= word($, j)    /*process each of the Heegner numbers. */
0014 say 'When using the Heegner number: '  #  /*display which Heegner # is being used*/
0015 z= exp(pi * sqrt(#) )                     /*perform some heavy lifting here.     */
0016 say format(z, 25, sDigs);           say   /*display a limited amount of dec digs.*/
0017 end   /*j*/
0018 exit                                             /*stick a fork in it,  we're all done. */
0019 /*──────────────────────────────────────────────────────────────────────────────────────*/
0020 pi:    pi= 3.1415926535897932384626433832795028841971693993751058209749445923078164062862,
0021 || 089986280348253421170679821480865132823066470938446095505822317253594081284,
0022 || 8111745028410270193852110555964462294895493038196;     return pi
0023 /*──────────────────────────────────────────────────────────────────────────────────────*/
0024 e:     e = 2.7182818284590452353602874713526624977572470936999595749669676277240766303535,
0025 || 475945713821785251664274274663919320030599218174135966290435729003342952605,
0026 || 9563073813232862794349076323382988075319525101901;     return  e
0027 /*──────────────────────────────────────────────────────────────────────────────────────*/
0028 exp:   procedure; parse arg x;  ix= x%1;  if abs(x-ix)>.5  then ix= ix + sign(x);  x= x-ix
0029 z=1;  _=1;   w=z;     do j=1; _= _*x/j;  z=(z+_)/1; if z==w  then leave;  w=z;  end
0030 if z\==0  then z= z * e() ** ix;                                         return z/1
0031 /*──────────────────────────────────────────────────────────────────────────────────────*/
0032 sqrt:  procedure; parse arg x;  if x=0  then return 0;  d=digits();  h=d+6; numeric digits
0033 numeric form; m.=9; parse value format(x,2,1,,0) 'E0' with g 'E' _ .;  g=g*.5'e'_%2
0034 do j=0  while h>9;      m.j=h;               h=h % 2  +  1;   end /*j*/
0035 do k=j+5  to 0  by -1;  numeric digits m.k;  g=(g+x/g) * .5;  end /*k*/; return g
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 x                32
002 d                32
003 h                32 34
004 m.               33 34
005 j                29 34
006 NORMAL.6         
007 NORMAL.7         
008 NORMAL.8         
009 NORMAL.9         
010 NORMAL.10        
011 NORMAL.11        
012 NORMAL.12        
013 NORMAL.13        
014 NORMAL.14        
015 NORMAL.15        
016 NORMAL.16        
017 NORMAL.17        
018 NORMAL.18        
019 NORMAL.19        
020 NORMAL.20        
021 NORMAL.21        
022 NORMAL.22        
023 g                33 33 35
024 k                35
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 $                -> newV1            3 6
002 #                -> newV2            13
003 _                -> newV3            29 29 33
