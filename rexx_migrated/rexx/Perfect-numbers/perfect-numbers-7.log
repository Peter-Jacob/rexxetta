-------------------------------------------------------------------------
Initial REXX INFILE on 23 Mar 2025 at 10:43:24
-------------------------------------------------------------------------
0001 /*REXX program tests if a number  (or a range of numbers)   is/are  perfect.            */
0002 parse arg low high .                             /*obtain optional arguments from the CL*/
0003 if high=='' & low==""  then high=34000000        /*No arguments?    Then use a range.   */
0004 if  low==''            then  low=1               /*if no   LOW,  then assume unity.     */
0005 low=low+low//2                                   /*if LOW is odd,  bump it by one.      */
0006 if high==''            then high=low             /*if no  HIGH,  then assume  LOW.      */
0007 w=length(high)                                   /*use   W   for formatting the output. */
0008 numeric digits max(9,w+2)                        /*ensure enough decimal digits for nums*/
0009 @. =0;    @.1=2;     !.=2;     _=' 6'            /*highest  magic number  and its index.*/
0010 !._=22;   !.16=12;   !.28=8;   !.36=20;   !.56=20;   !.76=20;   !.96=20
0011 /* [↑]   "Lucas' numbers,  in 1891.    */
0012 do i=low  to high  by 0              /*process the single number or a range.*/
0013 if isPerfect(i)  then say  right(i,w)   'is a perfect number.'
0014 i=i+!.?                              /*use a fast advance for the DO index. */
0015 end   /*i*/                          /* [↑]  note: the DO index is modified.*/
0016 exit                                             /*stick a fork in it,  we're all done. */
0017 /*──────────────────────────────────────────────────────────────────────────────────────*/
0018 isPerfect: procedure expose @. !. ?              /*expose (make global) some variables. */
0019 parse arg  x  1  y  ''  -2  ?         /*#  (and copy), and the last 2 digits.*/
0020 if x==6    then return 1              /*handle the special case of  six.     */
0021 if !.?==2  then return 0              /*test last two digits: François Lucas.*/
0022 /*╔═════════════════════════════════════════════╗
0023 ║ Lucas─Lehmer know that perfect numbers can  ║
0024 ║ be expressed as:    [2^n -1] * {2^(n-1) }   ║
0025 ╚═════════════════════════════════════════════╝*/
0026 if @.0<x  then do @.1=@.1  while @._<=x;  _=(2**@.1-1)*2**(@.1-1); @.0=_; @._=_
0027 end   /*@.1*/          /* [↑]  uses memoization for formula.  */
0028 
0029 if @.x==0  then return 0              /*Didn't pass Lucas-Lehmer? Not perfect*/
0030 /*[↓]  perfect numbers digital root = 1*/
0031 do  until  y<10                 /*find the digital root of  Y.         */
0032 parse var y d 2;  do k=2  for length(y)-1; d=d+substr(y,k,1);  end  /*k*/
0033 y=d                             /*find digital root of the digital root*/
0034 end   /*until*/                 /*wash, rinse, repeat ···              */
0035 
0036 if d\==1  then return 0               /*Is digital root ¬ 1?  Then ¬ perfect.*/
0037 s=3 + x%2                             /*we know the following factors: unity,*/
0038 z=x                                   /*2,  and  x÷2   (x is even).          */
0039 q=1;  do  while q<=z;   q=q*4 ;  end  /*while q≤z*/            /*       _____*/
0040 r=0                                   /* [↓]    R  will be the integer √  X  */
0041 do  while q>1;  q=q%4; _=z-r-q; r=r%2;  if _>=0  then do; z=_; r=r+q; end
0042 end   /*while q>1*/             /* [↑]  compute the integer SQRT of  X.*/
0043 /*                                _____*/
0044 do j=3  to r               /*starting at 3,  find factors ≤ √  X  */
0045 if x//j==0  then s=s+j+x%j /*J divisible by X? Then add J and  X÷J*/
0046 end   /*j*/
0047 return s==x                           /*if the sum matches X,  then perfect! */
-------------------------------------------------------------------------
Cross Reference Table Solid Variable Names
-------------------------------------------------------------------------
001 y                32 33
002 d                32 32
003 k                32
004 s                37 45
005 z                38 41
006 q                39 39 41
007 while            39
008 r                40 41 41
009 j                44
-------------------------------------------------------------------------
Cross Reference Table Bizarre Variable Names
-------------------------------------------------------------------------
001 @.               -> newV1.           9 9 26 26 26
002 !.               -> newV2.           9 10 10 10 10 10 10 10
003 _                -> newV3            9 26 41
004 ?                -> newV4            19
